<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - btrfstest.info - fs/btrfs/ctree.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">fs/btrfs</a> - ctree.c<span style="font-size: 80%;"> (source / <a href="ctree.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">btrfstest.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1909</td>
            <td class="headerCovTableEntry">2186</td>
            <td class="headerCovTableEntryMed">87.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2014-11-28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">93</td>
            <td class="headerCovTableEntry">94</td>
            <td class="headerCovTableEntryHi">98.9 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (C) 2007,2008 Oracle.  All rights reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * This program is free software; you can redistribute it and/or
<span class="lineNum">       5 </span>            :  * modify it under the terms of the GNU General Public
<span class="lineNum">       6 </span>            :  * License v2 as published by the Free Software Foundation.
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * This program is distributed in the hope that it will be useful,
<span class="lineNum">       9 </span>            :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      10 </span>            :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<span class="lineNum">      11 </span>            :  * General Public License for more details.
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  * You should have received a copy of the GNU General Public
<span class="lineNum">      14 </span>            :  * License along with this program; if not, write to the
<span class="lineNum">      15 </span>            :  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
<span class="lineNum">      16 </span>            :  * Boston, MA 021110-1307, USA.
<span class="lineNum">      17 </span>            :  */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &lt;linux/sched.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;linux/slab.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;linux/rbtree.h&gt;
<span class="lineNum">      22 </span>            : #include &quot;ctree.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;disk-io.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;transaction.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;print-tree.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;locking.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root
<span class="lineNum">      29 </span>            :                       *root, struct btrfs_path *path, int level);
<span class="lineNum">      30 </span>            : static int split_leaf(struct btrfs_trans_handle *trans, struct btrfs_root
<span class="lineNum">      31 </span>            :                       *root, struct btrfs_key *ins_key,
<span class="lineNum">      32 </span>            :                       struct btrfs_path *path, int data_size, int extend);
<span class="lineNum">      33 </span>            : static int push_node_left(struct btrfs_trans_handle *trans,
<span class="lineNum">      34 </span>            :                           struct btrfs_root *root, struct extent_buffer *dst,
<span class="lineNum">      35 </span>            :                           struct extent_buffer *src, int empty);
<span class="lineNum">      36 </span>            : static int balance_node_right(struct btrfs_trans_handle *trans,
<span class="lineNum">      37 </span>            :                               struct btrfs_root *root,
<span class="lineNum">      38 </span>            :                               struct extent_buffer *dst_buf,
<span class="lineNum">      39 </span>            :                               struct extent_buffer *src_buf);
<span class="lineNum">      40 </span>            : static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,
<span class="lineNum">      41 </span>            :                     int level, int slot);
<span class="lineNum">      42 </span>            : static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,
<a name="43"><span class="lineNum">      43 </span>            :                                  struct extent_buffer *eb);</a>
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span><span class="lineCov">    1854047 : struct btrfs_path *btrfs_alloc_path(void)</span>
<a name="46"><span class="lineNum">      46 </span>            : {</a>
<span class="lineNum">      47 </span>            :         struct btrfs_path *path;
<span class="lineNum">      48 </span><span class="lineCov">    1855831 :         path = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);</span>
<span class="lineNum">      49 </span><span class="lineCov">    1854158 :         return path;</span>
<span class="lineNum">      50 </span>            : }
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : /*
<span class="lineNum">      53 </span>            :  * set all locked nodes in the path to blocking locks.  This should
<a name="54"><span class="lineNum">      54 </span>            :  * be done before scheduling</a>
<span class="lineNum">      55 </span>            :  */
<span class="lineNum">      56 </span><span class="lineCov">    2594767 : noinline void btrfs_set_path_blocking(struct btrfs_path *p)</span>
<span class="lineNum">      57 </span>            : {
<span class="lineNum">      58 </span>            :         int i;
<span class="lineNum">      59 </span><span class="lineCov">   23375417 :         for (i = 0; i &lt; BTRFS_MAX_LEVEL; i++) {</span>
<span class="lineNum">      60 </span><span class="lineCov">   20777480 :                 if (!p-&gt;nodes[i] || !p-&gt;locks[i])</span>
<span class="lineNum">      61 </span><span class="lineCov">   19637098 :                         continue;</span>
<span class="lineNum">      62 </span><span class="lineCov">    1140382 :                 btrfs_set_lock_blocking_rw(p-&gt;nodes[i], p-&gt;locks[i]);</span>
<span class="lineNum">      63 </span><span class="lineCov">    1143552 :                 if (p-&gt;locks[i] == BTRFS_READ_LOCK)</span>
<span class="lineNum">      64 </span><span class="lineCov">     409973 :                         p-&gt;locks[i] = BTRFS_READ_LOCK_BLOCKING;</span>
<span class="lineNum">      65 </span><span class="lineCov">     733579 :                 else if (p-&gt;locks[i] == BTRFS_WRITE_LOCK)</span>
<span class="lineNum">      66 </span><span class="lineCov">     713014 :                         p-&gt;locks[i] = BTRFS_WRITE_LOCK_BLOCKING;</span>
<span class="lineNum">      67 </span>            :         }
<span class="lineNum">      68 </span><span class="lineCov">    2597937 : }</span>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : /*
<span class="lineNum">      71 </span>            :  * reset all the locked nodes in the patch to spinning locks.
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  * held is used to keep lockdep happy, when lockdep is enabled
<span class="lineNum">      74 </span>            :  * we set held to a blocking lock before we go around and
<span class="lineNum">      75 </span>            :  * retake all the spinlocks in the path.  You can safely use NULL
<a name="76"><span class="lineNum">      76 </span>            :  * for held</a>
<span class="lineNum">      77 </span>            :  */
<span class="lineNum">      78 </span><span class="lineCov">    5212087 : noinline void btrfs_clear_path_blocking(struct btrfs_path *p,</span>
<span class="lineNum">      79 </span>            :                                         struct extent_buffer *held, int held_rw)
<span class="lineNum">      80 </span>            : {
<span class="lineNum">      81 </span>            :         int i;
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : #ifdef CONFIG_DEBUG_LOCK_ALLOC
<span class="lineNum">      84 </span>            :         /* lockdep really cares that we take all of these spinlocks
<span class="lineNum">      85 </span>            :          * in the right order.  If any of the locks in the path are not
<span class="lineNum">      86 </span>            :          * currently blocking, it is going to complain.  So, make really
<span class="lineNum">      87 </span>            :          * really sure by forcing the path to blocking before we clear
<span class="lineNum">      88 </span>            :          * the path blocking.
<span class="lineNum">      89 </span>            :          */
<span class="lineNum">      90 </span>            :         if (held) {
<span class="lineNum">      91 </span>            :                 btrfs_set_lock_blocking_rw(held, held_rw);
<span class="lineNum">      92 </span>            :                 if (held_rw == BTRFS_WRITE_LOCK)
<span class="lineNum">      93 </span>            :                         held_rw = BTRFS_WRITE_LOCK_BLOCKING;
<span class="lineNum">      94 </span>            :                 else if (held_rw == BTRFS_READ_LOCK)
<span class="lineNum">      95 </span>            :                         held_rw = BTRFS_READ_LOCK_BLOCKING;
<span class="lineNum">      96 </span>            :         }
<span class="lineNum">      97 </span>            :         btrfs_set_path_blocking(p);
<span class="lineNum">      98 </span>            : #endif
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span><span class="lineCov">   46861138 :         for (i = BTRFS_MAX_LEVEL - 1; i &gt;= 0; i--) {</span>
<span class="lineNum">     101 </span><span class="lineCov">   41652998 :                 if (p-&gt;nodes[i] &amp;&amp; p-&gt;locks[i]) {</span>
<span class="lineNum">     102 </span><span class="lineCov">    3786076 :                         btrfs_clear_lock_blocking_rw(p-&gt;nodes[i], p-&gt;locks[i]);</span>
<span class="lineNum">     103 </span><span class="lineCov">    3782129 :                         if (p-&gt;locks[i] == BTRFS_WRITE_LOCK_BLOCKING)</span>
<span class="lineNum">     104 </span><span class="lineCov">     326601 :                                 p-&gt;locks[i] = BTRFS_WRITE_LOCK;</span>
<span class="lineNum">     105 </span><span class="lineCov">    3455528 :                         else if (p-&gt;locks[i] == BTRFS_READ_LOCK_BLOCKING)</span>
<span class="lineNum">     106 </span><span class="lineCov">       5404 :                                 p-&gt;locks[i] = BTRFS_READ_LOCK;</span>
<span class="lineNum">     107 </span>            :                 }
<span class="lineNum">     108 </span>            :         }
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : #ifdef CONFIG_DEBUG_LOCK_ALLOC
<span class="lineNum">     111 </span>            :         if (held)
<span class="lineNum">     112 </span>            :                 btrfs_clear_lock_blocking_rw(held, held_rw);
<span class="lineNum">     113 </span>            : #endif
<span class="lineNum">     114 </span><span class="lineCov">    5208140 : }</span>
<a name="115"><span class="lineNum">     115 </span>            : </a>
<span class="lineNum">     116 </span>            : /* this also releases the path */
<span class="lineNum">     117 </span><span class="lineCov">    1855866 : void btrfs_free_path(struct btrfs_path *p)</span>
<span class="lineNum">     118 </span>            : {
<span class="lineNum">     119 </span><span class="lineCov">    1855866 :         if (!p)</span>
<span class="lineNum">     120 </span><span class="lineCov">    1855760 :                 return;</span>
<span class="lineNum">     121 </span><span class="lineCov">    1855874 :         btrfs_release_path(p);</span>
<span class="lineNum">     122 </span><span class="lineCov">    1855739 :         kmem_cache_free(btrfs_path_cachep, p);</span>
<span class="lineNum">     123 </span>            : }
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : /*
<span class="lineNum">     126 </span>            :  * path release drops references on the extent buffers in the path
<span class="lineNum">     127 </span>            :  * and it drops any locks held by this path
<span class="lineNum">     128 </span>            :  *
<a name="129"><span class="lineNum">     129 </span>            :  * It is safe to call this on paths that no locks or extent buffers held.</a>
<span class="lineNum">     130 </span>            :  */
<span class="lineNum">     131 </span><span class="lineCov">    4493213 : noinline void btrfs_release_path(struct btrfs_path *p)</span>
<span class="lineNum">     132 </span>            : {
<span class="lineNum">     133 </span>            :         int i;
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span><span class="lineCov">   40453389 :         for (i = 0; i &lt; BTRFS_MAX_LEVEL; i++) {</span>
<span class="lineNum">     136 </span><span class="lineCov">   35957959 :                 p-&gt;slots[i] = 0;</span>
<span class="lineNum">     137 </span><span class="lineCov">   35957959 :                 if (!p-&gt;nodes[i])</span>
<span class="lineNum">     138 </span><span class="lineCov">   30953674 :                         continue;</span>
<span class="lineNum">     139 </span><span class="lineCov">    5004285 :                 if (p-&gt;locks[i]) {</span>
<span class="lineNum">     140 </span><span class="lineCov">    1384137 :                         btrfs_tree_unlock_rw(p-&gt;nodes[i], p-&gt;locks[i]);</span>
<span class="lineNum">     141 </span><span class="lineCov">    1384409 :                         p-&gt;locks[i] = 0;</span>
<span class="lineNum">     142 </span>            :                 }
<span class="lineNum">     143 </span><span class="lineCov">    5004557 :                 free_extent_buffer(p-&gt;nodes[i]);</span>
<span class="lineNum">     144 </span><span class="lineCov">    5006502 :                 p-&gt;nodes[i] = NULL;</span>
<span class="lineNum">     145 </span>            :         }
<span class="lineNum">     146 </span><span class="lineCov">    4495430 : }</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : /*
<span class="lineNum">     149 </span>            :  * safely gets a reference on the root node of a tree.  A lock
<span class="lineNum">     150 </span>            :  * is not taken, so a concurrent writer may put a different node
<span class="lineNum">     151 </span>            :  * at the root of the tree.  See btrfs_lock_root_node for the
<span class="lineNum">     152 </span>            :  * looping required.
<span class="lineNum">     153 </span>            :  *
<span class="lineNum">     154 </span>            :  * The extent buffer returned by this has a reference taken, so
<span class="lineNum">     155 </span>            :  * it won't disappear.  It may stop being the root of the tree
<a name="156"><span class="lineNum">     156 </span>            :  * at any time because there are no locks held.</a>
<span class="lineNum">     157 </span>            :  */
<span class="lineNum">     158 </span><span class="lineCov">    1872073 : struct extent_buffer *btrfs_root_node(struct btrfs_root *root)</span>
<span class="lineNum">     159 </span>            : {
<span class="lineNum">     160 </span>            :         struct extent_buffer *eb;
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :         while (1) {
<span class="lineNum">     163 </span>            :                 rcu_read_lock();
<span class="lineNum">     164 </span><span class="lineCov">    1872156 :                 eb = rcu_dereference(root-&gt;node);</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :                 /*
<span class="lineNum">     167 </span>            :                  * RCU really hurts here, we could free up the root node because
<span class="lineNum">     168 </span>            :                  * it was cow'ed but we may not get the new root node yet so do
<span class="lineNum">     169 </span>            :                  * the inc_not_zero dance and if it doesn't work then
<span class="lineNum">     170 </span>            :                  * synchronize_rcu and try again.
<span class="lineNum">     171 </span>            :                  */
<span class="lineNum">     172 </span><span class="lineCov">    1873751 :                 if (atomic_inc_not_zero(&amp;eb-&gt;refs)) {</span>
<span class="lineNum">     173 </span>            :                         rcu_read_unlock();
<span class="lineNum">     174 </span>            :                         break;
<span class="lineNum">     175 </span>            :                 }
<span class="lineNum">     176 </span>            :                 rcu_read_unlock();
<span class="lineNum">     177 </span>            :                 synchronize_rcu();
<span class="lineNum">     178 </span>            :         }
<span class="lineNum">     179 </span><span class="lineCov">    1873755 :         return eb;</span>
<span class="lineNum">     180 </span>            : }
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : /* loop around taking references on and locking the root node of the
<span class="lineNum">     183 </span>            :  * tree until you end up with a lock on the root.  A locked buffer
<a name="184"><span class="lineNum">     184 </span>            :  * is returned, with a reference held.</a>
<span class="lineNum">     185 </span>            :  */
<span class="lineNum">     186 </span><span class="lineCov">     635185 : struct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)</span>
<span class="lineNum">     187 </span>            : {
<span class="lineNum">     188 </span>            :         struct extent_buffer *eb;
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :         while (1) {
<span class="lineNum">     191 </span><span class="lineCov">     635210 :                 eb = btrfs_root_node(root);</span>
<span class="lineNum">     192 </span><span class="lineCov">     635225 :                 btrfs_tree_lock(eb);</span>
<span class="lineNum">     193 </span><span class="lineCov">     635245 :                 if (eb == root-&gt;node)</span>
<span class="lineNum">     194 </span>            :                         break;
<span class="lineNum">     195 </span><span class="lineCov">         25 :                 btrfs_tree_unlock(eb);</span>
<span class="lineNum">     196 </span><span class="lineCov">         25 :                 free_extent_buffer(eb);</span>
<span class="lineNum">     197 </span><span class="lineCov">         25 :         }</span>
<span class="lineNum">     198 </span><span class="lineCov">     635220 :         return eb;</span>
<span class="lineNum">     199 </span>            : }
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : /* loop around taking references on and locking the root node of the
<span class="lineNum">     202 </span>            :  * tree until you end up with a lock on the root.  A locked buffer
<a name="203"><span class="lineNum">     203 </span>            :  * is returned, with a reference held.</a>
<span class="lineNum">     204 </span>            :  */
<span class="lineNum">     205 </span><span class="lineCov">    1211496 : static struct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root)</span>
<span class="lineNum">     206 </span>            : {
<span class="lineNum">     207 </span>            :         struct extent_buffer *eb;
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :         while (1) {
<span class="lineNum">     210 </span><span class="lineCov">    1211636 :                 eb = btrfs_root_node(root);</span>
<span class="lineNum">     211 </span><span class="lineCov">    1212206 :                 btrfs_tree_read_lock(eb);</span>
<span class="lineNum">     212 </span><span class="lineCov">    1212141 :                 if (eb == root-&gt;node)</span>
<span class="lineNum">     213 </span>            :                         break;
<span class="lineNum">     214 </span><span class="lineCov">        140 :                 btrfs_tree_read_unlock(eb);</span>
<span class="lineNum">     215 </span><span class="lineCov">        140 :                 free_extent_buffer(eb);</span>
<span class="lineNum">     216 </span><span class="lineCov">        140 :         }</span>
<span class="lineNum">     217 </span><span class="lineCov">    1212001 :         return eb;</span>
<span class="lineNum">     218 </span>            : }
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : /* cowonly root (everything not a reference counted cow subvolume), just get
<span class="lineNum">     221 </span>            :  * put onto a simple dirty list.  transaction.c walks this to make sure they
<a name="222"><span class="lineNum">     222 </span>            :  * get properly updated on disk.</a>
<span class="lineNum">     223 </span>            :  */
<span class="lineNum">     224 </span><span class="lineCov">      13659 : static void add_root_to_dirty_list(struct btrfs_root *root)</span>
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span><span class="lineCov">      13659 :         spin_lock(&amp;root-&gt;fs_info-&gt;trans_lock);</span>
<span class="lineNum">     227 </span><span class="lineCov">      19174 :         if (test_bit(BTRFS_ROOT_TRACK_DIRTY, &amp;root-&gt;state) &amp;&amp;</span>
<span class="lineNum">     228 </span><span class="lineCov">       5515 :             list_empty(&amp;root-&gt;dirty_list)) {</span>
<span class="lineNum">     229 </span><span class="lineCov">       4833 :                 list_add(&amp;root-&gt;dirty_list,</span>
<span class="lineNum">     230 </span><span class="lineCov">       4833 :                          &amp;root-&gt;fs_info-&gt;dirty_cowonly_roots);</span>
<span class="lineNum">     231 </span>            :         }
<span class="lineNum">     232 </span><span class="lineCov">      13659 :         spin_unlock(&amp;root-&gt;fs_info-&gt;trans_lock);</span>
<span class="lineNum">     233 </span><span class="lineCov">      13659 : }</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : /*
<span class="lineNum">     236 </span>            :  * used by snapshot creation to make a copy of a root for a tree with
<span class="lineNum">     237 </span>            :  * a given objectid.  The buffer with the new root node is returned in
<a name="238"><span class="lineNum">     238 </span>            :  * cow_ret, and this func returns zero on success or a negative error code.</a>
<span class="lineNum">     239 </span>            :  */
<span class="lineNum">     240 </span><span class="lineCov">        585 : int btrfs_copy_root(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">     241 </span>            :                       struct btrfs_root *root,
<span class="lineNum">     242 </span><span class="lineCov">       1170 :                       struct extent_buffer *buf,</span>
<span class="lineNum">     243 </span>            :                       struct extent_buffer **cow_ret, u64 new_root_objectid)
<span class="lineNum">     244 </span>            : {
<span class="lineNum">     245 </span><span class="lineCov">       1316 :         struct extent_buffer *cow;</span>
<span class="lineNum">     246 </span>            :         int ret = 0;
<span class="lineNum">     247 </span>            :         int level;
<span class="lineNum">     248 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineCov">        585 :         WARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &amp;root-&gt;state) &amp;&amp;</span>
<span class="lineNum">     251 </span>            :                 trans-&gt;transid != root-&gt;fs_info-&gt;running_transaction-&gt;transid);
<span class="lineNum">     252 </span><span class="lineCov">        585 :         WARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &amp;root-&gt;state) &amp;&amp;</span>
<span class="lineNum">     253 </span>            :                 trans-&gt;transid != root-&gt;last_trans);
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineCov">        585 :         level = btrfs_header_level(buf);</span>
<span class="lineNum">     256 </span><span class="lineCov">        585 :         if (level == 0)</span>
<span class="lineNum">     257 </span>            :                 btrfs_item_key(buf, &amp;disk_key, 0);
<span class="lineNum">     258 </span>            :         else
<span class="lineNum">     259 </span><span class="lineCov">         79 :                 btrfs_node_key(buf, &amp;disk_key, 0);</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span><span class="lineCov">        585 :         cow = btrfs_alloc_free_block(trans, root, buf-&gt;len, 0,</span>
<span class="lineNum">     262 </span>            :                                      new_root_objectid, &amp;disk_key, level,
<span class="lineNum">     263 </span>            :                                      buf-&gt;start, 0);
<span class="lineNum">     264 </span><span class="lineCov">        585 :         if (IS_ERR(cow))</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :                 return PTR_ERR(cow);</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineCov">        585 :         copy_extent_buffer(cow, buf, 0, 0, cow-&gt;len);</span>
<span class="lineNum">     268 </span><span class="lineCov">        585 :         btrfs_set_header_bytenr(cow, cow-&gt;start);</span>
<span class="lineNum">     269 </span><span class="lineCov">        585 :         btrfs_set_header_generation(cow, trans-&gt;transid);</span>
<span class="lineNum">     270 </span>            :         btrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);
<span class="lineNum">     271 </span>            :         btrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |
<span class="lineNum">     272 </span>            :                                      BTRFS_HEADER_FLAG_RELOC);
<span class="lineNum">     273 </span><span class="lineCov">        585 :         if (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)</span>
<span class="lineNum">     274 </span>            :                 btrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);
<span class="lineNum">     275 </span>            :         else
<span class="lineNum">     276 </span>            :                 btrfs_set_header_owner(cow, new_root_objectid);
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineCov">        585 :         write_extent_buffer(cow, root-&gt;fs_info-&gt;fsid, btrfs_header_fsid(),</span>
<span class="lineNum">     279 </span>            :                             BTRFS_FSID_SIZE);
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineCov">        585 :         WARN_ON(btrfs_header_generation(buf) &gt; trans-&gt;transid);</span>
<span class="lineNum">     282 </span><span class="lineCov">        585 :         if (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)</span>
<span class="lineNum">     283 </span><span class="lineCov">        439 :                 ret = btrfs_inc_ref(trans, root, cow, 1);</span>
<span class="lineNum">     284 </span>            :         else
<span class="lineNum">     285 </span><span class="lineCov">        146 :                 ret = btrfs_inc_ref(trans, root, cow, 0);</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineCov">        585 :         if (ret)</span>
<span class="lineNum">     288 </span>            :                 return ret;
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineCov">        585 :         btrfs_mark_buffer_dirty(cow);</span>
<span class="lineNum">     291 </span><span class="lineCov">        585 :         *cow_ret = cow;</span>
<span class="lineNum">     292 </span><span class="lineCov">        585 :         return 0;</span>
<span class="lineNum">     293 </span>            : }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : enum mod_log_op {
<span class="lineNum">     296 </span>            :         MOD_LOG_KEY_REPLACE,
<span class="lineNum">     297 </span>            :         MOD_LOG_KEY_ADD,
<span class="lineNum">     298 </span>            :         MOD_LOG_KEY_REMOVE,
<span class="lineNum">     299 </span>            :         MOD_LOG_KEY_REMOVE_WHILE_FREEING,
<span class="lineNum">     300 </span>            :         MOD_LOG_KEY_REMOVE_WHILE_MOVING,
<span class="lineNum">     301 </span>            :         MOD_LOG_MOVE_KEYS,
<span class="lineNum">     302 </span>            :         MOD_LOG_ROOT_REPLACE,
<span class="lineNum">     303 </span>            : };
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : struct tree_mod_move {
<span class="lineNum">     306 </span>            :         int dst_slot;
<span class="lineNum">     307 </span>            :         int nr_items;
<span class="lineNum">     308 </span>            : };
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            : struct tree_mod_root {
<span class="lineNum">     311 </span>            :         u64 logical;
<span class="lineNum">     312 </span>            :         u8 level;
<span class="lineNum">     313 </span>            : };
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            : struct tree_mod_elem {
<span class="lineNum">     316 </span>            :         struct rb_node node;
<span class="lineNum">     317 </span>            :         u64 index;              /* shifted logical */
<span class="lineNum">     318 </span>            :         u64 seq;
<span class="lineNum">     319 </span>            :         enum mod_log_op op;
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :         /* this is used for MOD_LOG_KEY_* and MOD_LOG_MOVE_KEYS operations */
<span class="lineNum">     322 </span>            :         int slot;
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :         /* this is used for MOD_LOG_KEY* and MOD_LOG_ROOT_REPLACE */
<span class="lineNum">     325 </span>            :         u64 generation;
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :         /* those are used for op == MOD_LOG_KEY_{REPLACE,REMOVE} */
<span class="lineNum">     328 </span>            :         struct btrfs_disk_key key;
<span class="lineNum">     329 </span>            :         u64 blockptr;
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :         /* this is used for op == MOD_LOG_MOVE_KEYS */
<span class="lineNum">     332 </span>            :         struct tree_mod_move move;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :         /* this is used for op == MOD_LOG_ROOT_REPLACE */
<span class="lineNum">     335 </span>            :         struct tree_mod_root old_root;
<span class="lineNum">     336 </span>            : };
<span class="lineNum">     337 </span>            : 
<a name="338"><span class="lineNum">     338 </span>            : static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)</a>
<span class="lineNum">     339 </span>            : {
<span class="lineNum">     340 </span><span class="lineCov">      21988 :         read_lock(&amp;fs_info-&gt;tree_mod_log_lock);</span>
<span class="lineNum">     341 </span>            : }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)
<span class="lineNum">     344 </span>            : {
<span class="lineNum">     345 </span>            :         read_unlock(&amp;fs_info-&gt;tree_mod_log_lock);
<span class="lineNum">     346 </span>            : }
<span class="lineNum">     347 </span>            : 
<a name="348"><span class="lineNum">     348 </span>            : static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)</a>
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span><span class="lineCov">      10596 :         write_lock(&amp;fs_info-&gt;tree_mod_log_lock);</span>
<span class="lineNum">     351 </span>            : }
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            : static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)
<span class="lineNum">     354 </span>            : {
<span class="lineNum">     355 </span>            :         write_unlock(&amp;fs_info-&gt;tree_mod_log_lock);
<span class="lineNum">     356 </span>            : }
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : /*
<span class="lineNum">     359 </span>            :  * Pull a new tree mod seq number for our operation.
<span class="lineNum">     360 </span>            :  */
<a name="361"><span class="lineNum">     361 </span>            : static inline u64 btrfs_inc_tree_mod_seq(struct btrfs_fs_info *fs_info)</a>
<span class="lineNum">     362 </span>            : {
<span class="lineNum">     363 </span><span class="lineCov">      15698 :         return atomic64_inc_return(&amp;fs_info-&gt;tree_mod_seq);</span>
<span class="lineNum">     364 </span>            : }
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : /*
<span class="lineNum">     367 </span>            :  * This adds a new blocker to the tree mod log's blocker list if the @elem
<span class="lineNum">     368 </span>            :  * passed does not already have a sequence number set. So when a caller expects
<span class="lineNum">     369 </span>            :  * to record tree modifications, it should ensure to set elem-&gt;seq to zero
<span class="lineNum">     370 </span>            :  * before calling btrfs_get_tree_mod_seq.
<span class="lineNum">     371 </span>            :  * Returns a fresh, unused tree log modification sequence number, even if no new
<span class="lineNum">     372 </span>            :  * blocker was added.
<span class="lineNum">     373 </span>            :  */
<span class="lineNum">     374 </span><span class="lineCov">       4917 : u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,</span>
<span class="lineNum">     375 </span>            :                            struct seq_list *elem)
<span class="lineNum">     376 </span>            : {
<span class="lineNum">     377 </span>            :         tree_mod_log_write_lock(fs_info);
<span class="lineNum">     378 </span>            :         spin_lock(&amp;fs_info-&gt;tree_mod_seq_lock);
<span class="lineNum">     379 </span><span class="lineCov">       4917 :         if (!elem-&gt;seq) {</span>
<span class="lineNum">     380 </span><span class="lineCov">       4917 :                 elem-&gt;seq = btrfs_inc_tree_mod_seq(fs_info);</span>
<span class="lineNum">     381 </span><span class="lineCov">       4917 :                 list_add_tail(&amp;elem-&gt;list, &amp;fs_info-&gt;tree_mod_seq_list);</span>
<span class="lineNum">     382 </span>            :         }
<span class="lineNum">     383 </span>            :         spin_unlock(&amp;fs_info-&gt;tree_mod_seq_lock);
<span class="lineNum">     384 </span>            :         tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineCov">       4917 :         return elem-&gt;seq;</span>
<span class="lineNum">     387 </span>            : }
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span><span class="lineCov">      17271 : void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,</span>
<span class="lineNum">     390 </span>            :                             struct seq_list *elem)
<span class="lineNum">     391 </span>            : {
<span class="lineNum">     392 </span>            :         struct rb_root *tm_root;
<span class="lineNum">     393 </span>            :         struct rb_node *node;
<span class="lineNum">     394 </span>            :         struct rb_node *next;
<span class="lineNum">     395 </span>            :         struct seq_list *cur_elem;
<span class="lineNum">     396 </span>            :         struct tree_mod_elem *tm;
<span class="lineNum">     397 </span>            :         u64 min_seq = (u64)-1;
<span class="lineNum">     398 </span><span class="lineCov">      17271 :         u64 seq_putting = elem-&gt;seq;</span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineCov">      17271 :         if (!seq_putting)</span>
<span class="lineNum">     401 </span>            :                 return;
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :         spin_lock(&amp;fs_info-&gt;tree_mod_seq_lock);
<span class="lineNum">     404 </span><span class="lineCov">       4917 :         list_del(&amp;elem-&gt;list);</span>
<span class="lineNum">     405 </span><span class="lineCov">       4917 :         elem-&gt;seq = 0;</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">      30418 :         list_for_each_entry(cur_elem, &amp;fs_info-&gt;tree_mod_seq_list, list) {</span>
<span class="lineNum">     408 </span><span class="lineCov">      26763 :                 if (cur_elem-&gt;seq &lt; min_seq) {</span>
<span class="lineNum">     409 </span><span class="lineCov">       2262 :                         if (seq_putting &gt; cur_elem-&gt;seq) {</span>
<span class="lineNum">     410 </span>            :                                 /*
<span class="lineNum">     411 </span>            :                                  * blocker with lower sequence number exists, we
<span class="lineNum">     412 </span>            :                                  * cannot remove anything from the log
<span class="lineNum">     413 </span>            :                                  */
<span class="lineNum">     414 </span>            :                                 spin_unlock(&amp;fs_info-&gt;tree_mod_seq_lock);
<span class="lineNum">     415 </span>            :                                 return;
<span class="lineNum">     416 </span>            :                         }
<span class="lineNum">     417 </span>            :                         min_seq = cur_elem-&gt;seq;
<span class="lineNum">     418 </span>            :                 }
<span class="lineNum">     419 </span>            :         }
<span class="lineNum">     420 </span>            :         spin_unlock(&amp;fs_info-&gt;tree_mod_seq_lock);
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :         /*
<span class="lineNum">     423 </span>            :          * anything that's lower than the lowest existing (read: blocked)
<span class="lineNum">     424 </span>            :          * sequence number can be removed from the tree.
<span class="lineNum">     425 </span>            :          */
<span class="lineNum">     426 </span>            :         tree_mod_log_write_lock(fs_info);
<span class="lineNum">     427 </span><span class="lineCov">       3655 :         tm_root = &amp;fs_info-&gt;tree_mod_log;</span>
<span class="lineNum">     428 </span><span class="lineCov">     216105 :         for (node = rb_first(tm_root); node; node = next) {</span>
<span class="lineNum">     429 </span><span class="lineCov">     208795 :                 next = rb_next(node);</span>
<span class="lineNum">     430 </span>            :                 tm = container_of(node, struct tree_mod_elem, node);
<span class="lineNum">     431 </span><span class="lineCov">     208795 :                 if (tm-&gt;seq &gt; min_seq)</span>
<span class="lineNum">     432 </span><span class="lineCov">     205863 :                         continue;</span>
<span class="lineNum">     433 </span><span class="lineCov">       2932 :                 rb_erase(node, tm_root);</span>
<span class="lineNum">     434 </span><span class="lineCov">       2932 :                 kfree(tm);</span>
<span class="lineNum">     435 </span>            :         }
<span class="lineNum">     436 </span>            :         tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     437 </span>            : }
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : /*
<span class="lineNum">     440 </span>            :  * key order of the log:
<span class="lineNum">     441 </span>            :  *       index -&gt; sequence
<span class="lineNum">     442 </span>            :  *
<span class="lineNum">     443 </span>            :  * the index is the shifted logical of the *new* root node for root replace
<span class="lineNum">     444 </span>            :  * operations, or the shifted logical of the affected block for all other
<span class="lineNum">     445 </span>            :  * operations.
<span class="lineNum">     446 </span>            :  *
<span class="lineNum">     447 </span>            :  * Note: must be called with write lock (tree_mod_log_write_lock).
<span class="lineNum">     448 </span>            :  */
<span class="lineNum">     449 </span>            : static noinline int
<span class="lineNum">     450 </span><span class="lineCov">       2932 : __tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)</span>
<span class="lineNum">     451 </span>            : {
<span class="lineNum">     452 </span>            :         struct rb_root *tm_root;
<span class="lineNum">     453 </span>            :         struct rb_node **new;
<span class="lineNum">     454 </span>            :         struct rb_node *parent = NULL;
<span class="lineNum">     455 </span>            :         struct tree_mod_elem *cur;
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span><span class="lineCov">       2932 :         BUG_ON(!tm);</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineCov">       2932 :         tm-&gt;seq = btrfs_inc_tree_mod_seq(fs_info);</span>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineCov">       2932 :         tm_root = &amp;fs_info-&gt;tree_mod_log;</span>
<span class="lineNum">     462 </span><span class="lineCov">       2932 :         new = &amp;tm_root-&gt;rb_node;</span>
<span class="lineNum">     463 </span><span class="lineCov">      32774 :         while (*new) {</span>
<span class="lineNum">     464 </span>            :                 cur = container_of(*new, struct tree_mod_elem, node);
<span class="lineNum">     465 </span>            :                 parent = *new;
<span class="lineNum">     466 </span><span class="lineCov">      26910 :                 if (cur-&gt;index &lt; tm-&gt;index)</span>
<span class="lineNum">     467 </span><span class="lineCov">        352 :                         new = &amp;((*new)-&gt;rb_left);</span>
<span class="lineNum">     468 </span><span class="lineCov">      26558 :                 else if (cur-&gt;index &gt; tm-&gt;index)</span>
<span class="lineNum">     469 </span><span class="lineCov">       4232 :                         new = &amp;((*new)-&gt;rb_right);</span>
<span class="lineNum">     470 </span><span class="lineCov">      22326 :                 else if (cur-&gt;seq &lt; tm-&gt;seq)</span>
<span class="lineNum">     471 </span><span class="lineCov">      22326 :                         new = &amp;((*new)-&gt;rb_left);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                 else if (cur-&gt;seq &gt; tm-&gt;seq)</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                         new = &amp;((*new)-&gt;rb_right);</span>
<span class="lineNum">     474 </span>            :                 else
<span class="lineNum">     475 </span>            :                         return -EEXIST;
<span class="lineNum">     476 </span>            :         }
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">       2932 :         rb_link_node(&amp;tm-&gt;node, parent, new);</span>
<span class="lineNum">     479 </span><span class="lineCov">       2932 :         rb_insert_color(&amp;tm-&gt;node, tm_root);</span>
<span class="lineNum">     480 </span><span class="lineCov">       2932 :         return 0;</span>
<span class="lineNum">     481 </span>            : }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            : /*
<span class="lineNum">     484 </span>            :  * Determines if logging can be omitted. Returns 1 if it can. Otherwise, it
<span class="lineNum">     485 </span>            :  * returns zero with the tree_mod_log_lock acquired. The caller must hold
<span class="lineNum">     486 </span>            :  * this until all tree mod log insertions are recorded in the rb tree and then
<span class="lineNum">     487 </span>            :  * call tree_mod_log_write_unlock() to release.
<span class="lineNum">     488 </span>            :  */
<span class="lineNum">     489 </span><span class="lineCov">       2024 : static inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,</span>
<span class="lineNum">     490 </span><span class="lineCov">       2011 :                                     struct extent_buffer *eb) {</span>
<span class="lineNum">     491 </span><span class="lineCov">       2024 :         smp_mb();</span>
<span class="lineNum">     492 </span><span class="lineCov">       4048 :         if (list_empty(&amp;(fs_info)-&gt;tree_mod_seq_list))</span>
<span class="lineNum">     493 </span>            :                 return 1;
<span class="lineNum">     494 </span><span class="lineCov">       4035 :         if (eb &amp;&amp; btrfs_header_level(eb) == 0)</span>
<span class="lineNum">     495 </span>            :                 return 1;
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :         tree_mod_log_write_lock(fs_info);
<span class="lineNum">     498 </span><span class="lineCov">       2024 :         if (list_empty(&amp;(fs_info)-&gt;tree_mod_seq_list)) {</span>
<span class="lineNum">     499 </span>            :                 tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     501 </span>            :         }
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :         return 0;
<span class="lineNum">     504 </span>            : }
<span class="lineNum">     505 </span>            : 
<a name="506"><span class="lineNum">     506 </span>            : /* Similar to tree_mod_dont_log, but doesn't acquire any locks. */</a>
<span class="lineNum">     507 </span>            : static inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,
<a name="508"><span class="lineNum">     508 </span><span class="lineCov">       2011 :                                     struct extent_buffer *eb)</span></a>
<span class="lineNum">     509 </span>            : {
<span class="lineNum">     510 </span><span class="lineCov">      79644 :         smp_mb();</span>
<span class="lineNum">     511 </span><span class="lineCov">     159290 :         if (list_empty(&amp;(fs_info)-&gt;tree_mod_seq_list))</span>
<span class="lineNum">     512 </span>            :                 return 0;
<span class="lineNum">     513 </span><span class="lineCov">       4022 :         if (eb &amp;&amp; btrfs_header_level(eb) == 0)</span>
<span class="lineNum">     514 </span>            :                 return 0;
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            :         return 1;
<span class="lineNum">     517 </span>            : }
<a name="518"><span class="lineNum">     518 </span>            : </a>
<span class="lineNum">     519 </span>            : static struct tree_mod_elem *
<span class="lineNum">     520 </span><span class="lineCov">       2697 : alloc_tree_mod_elem(struct extent_buffer *eb, int slot,</span>
<span class="lineNum">     521 </span>            :                     enum mod_log_op op, gfp_t flags)
<span class="lineNum">     522 </span>            : {
<span class="lineNum">     523 </span>            :         struct tree_mod_elem *tm;
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span><span class="lineCov">       2697 :         tm = kzalloc(sizeof(*tm), flags);</span>
<span class="lineNum">     526 </span><span class="lineCov">       2697 :         if (!tm)</span>
<span class="lineNum">     527 </span>            :                 return NULL;
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineCov">       2697 :         tm-&gt;index = eb-&gt;start &gt;&gt; PAGE_CACHE_SHIFT;</span>
<span class="lineNum">     530 </span><span class="lineCov">       2697 :         if (op != MOD_LOG_KEY_ADD) {</span>
<span class="lineNum">     531 </span><span class="lineCov">       2448 :                 btrfs_node_key(eb, &amp;tm-&gt;key, slot);</span>
<span class="lineNum">     532 </span><span class="lineCov">       2448 :                 tm-&gt;blockptr = btrfs_node_blockptr(eb, slot);</span>
<span class="lineNum">     533 </span>            :         }
<span class="lineNum">     534 </span><span class="lineCov">       2697 :         tm-&gt;op = op;</span>
<span class="lineNum">     535 </span><span class="lineCov">       2697 :         tm-&gt;slot = slot;</span>
<span class="lineNum">     536 </span><span class="lineCov">       2697 :         tm-&gt;generation = btrfs_node_ptr_generation(eb, slot);</span>
<span class="lineNum">     537 </span><span class="lineCov">       2697 :         RB_CLEAR_NODE(&amp;tm-&gt;node);</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineCov">       2697 :         return tm;</span>
<span class="lineNum">     540 </span>            : }
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            : static noinline int
<span class="lineNum">     543 </span><span class="lineCov">      58000 : tree_mod_log_insert_key(struct btrfs_fs_info *fs_info,</span>
<span class="lineNum">     544 </span>            :                         struct extent_buffer *eb, int slot,
<span class="lineNum">     545 </span>            :                         enum mod_log_op op, gfp_t flags)
<span class="lineNum">     546 </span>            : {
<span class="lineNum">     547 </span>            :         struct tree_mod_elem *tm;
<span class="lineNum">     548 </span>            :         int ret;
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineCov">      58001 :         if (!tree_mod_need_log(fs_info, eb))</span>
<span class="lineNum">     551 </span>            :                 return 0;
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineCov">       1783 :         tm = alloc_tree_mod_elem(eb, slot, op, flags);</span>
<span class="lineNum">     554 </span><span class="lineCov">       1783 :         if (!tm)</span>
<span class="lineNum">     555 </span>            :                 return -ENOMEM;
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineCov">       1783 :         if (tree_mod_dont_log(fs_info, eb)) {</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                 kfree(tm);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     560 </span>            :         }
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineCov">       1783 :         ret = __tree_mod_log_insert(fs_info, tm);</span>
<span class="lineNum">     563 </span>            :         tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     564 </span><span class="lineCov">       1783 :         if (ret)</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :                 kfree(tm);</span>
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span><span class="lineCov">       1783 :         return ret;</span>
<span class="lineNum">     568 </span>            : }
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            : static noinline int
<span class="lineNum">     571 </span><span class="lineCov">       4522 : tree_mod_log_insert_move(struct btrfs_fs_info *fs_info,</span>
<span class="lineNum">     572 </span>            :                          struct extent_buffer *eb, int dst_slot, int src_slot,
<span class="lineNum">     573 </span>            :                          int nr_items, gfp_t flags)
<span class="lineNum">     574 </span>            : {
<span class="lineNum">     575 </span>            :         struct tree_mod_elem *tm = NULL;
<span class="lineNum">     576 </span>            :         struct tree_mod_elem **tm_list = NULL;
<span class="lineNum">     577 </span>            :         int ret = 0;
<span class="lineNum">     578 </span>            :         int i;
<span class="lineNum">     579 </span>            :         int locked = 0;
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span><span class="lineCov">       4522 :         if (!tree_mod_need_log(fs_info, eb))</span>
<span class="lineNum">     582 </span>            :                 return 0;
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span><span class="lineCov">        228 :         tm_list = kzalloc(nr_items * sizeof(struct tree_mod_elem *), flags);</span>
<span class="lineNum">     585 </span><span class="lineCov">        228 :         if (!tm_list)</span>
<span class="lineNum">     586 </span>            :                 return -ENOMEM;
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span><span class="lineCov">        228 :         tm = kzalloc(sizeof(*tm), flags);</span>
<span class="lineNum">     589 </span><span class="lineCov">        228 :         if (!tm) {</span>
<span class="lineNum">     590 </span>            :                 ret = -ENOMEM;
<span class="lineNum">     591 </span>            :                 goto free_tms;
<span class="lineNum">     592 </span>            :         }
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">        228 :         tm-&gt;index = eb-&gt;start &gt;&gt; PAGE_CACHE_SHIFT;</span>
<span class="lineNum">     595 </span><span class="lineCov">        228 :         tm-&gt;slot = src_slot;</span>
<span class="lineNum">     596 </span><span class="lineCov">        228 :         tm-&gt;move.dst_slot = dst_slot;</span>
<span class="lineNum">     597 </span><span class="lineCov">        228 :         tm-&gt;move.nr_items = nr_items;</span>
<span class="lineNum">     598 </span><span class="lineCov">        228 :         tm-&gt;op = MOD_LOG_MOVE_KEYS;</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span><span class="lineCov">        455 :         for (i = 0; i + dst_slot &lt; src_slot &amp;&amp; i &lt; nr_items; i++) {</span>
<span class="lineNum">     601 </span><span class="lineCov">        227 :                 tm_list[i] = alloc_tree_mod_elem(eb, i + dst_slot,</span>
<span class="lineNum">     602 </span>            :                     MOD_LOG_KEY_REMOVE_WHILE_MOVING, flags);
<span class="lineNum">     603 </span><span class="lineCov">        227 :                 if (!tm_list[i]) {</span>
<span class="lineNum">     604 </span>            :                         ret = -ENOMEM;
<span class="lineNum">     605 </span>            :                         goto free_tms;
<span class="lineNum">     606 </span>            :                 }
<span class="lineNum">     607 </span>            :         }
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span><span class="lineCov">        228 :         if (tree_mod_dont_log(fs_info, eb))</span>
<span class="lineNum">     610 </span>            :                 goto free_tms;
<span class="lineNum">     611 </span>            :         locked = 1;
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :         /*
<span class="lineNum">     614 </span>            :          * When we override something during the move, we log these removals.
<span class="lineNum">     615 </span>            :          * This can only happen when we move towards the beginning of the
<span class="lineNum">     616 </span>            :          * buffer, i.e. dst_slot &lt; src_slot.
<span class="lineNum">     617 </span>            :          */
<span class="lineNum">     618 </span><span class="lineCov">        227 :         for (i = 0; i + dst_slot &lt; src_slot &amp;&amp; i &lt; nr_items; i++) {</span>
<span class="lineNum">     619 </span><span class="lineCov">        227 :                 ret = __tree_mod_log_insert(fs_info, tm_list[i]);</span>
<span class="lineNum">     620 </span><span class="lineCov">        227 :                 if (ret)</span>
<span class="lineNum">     621 </span>            :                         goto free_tms;
<span class="lineNum">     622 </span>            :         }
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineCov">        228 :         ret = __tree_mod_log_insert(fs_info, tm);</span>
<span class="lineNum">     625 </span><span class="lineCov">        228 :         if (ret)</span>
<span class="lineNum">     626 </span>            :                 goto free_tms;
<span class="lineNum">     627 </span>            :         tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     628 </span><span class="lineCov">        228 :         kfree(tm_list);</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span><span class="lineCov">        228 :         return 0;</span>
<span class="lineNum">     631 </span>            : free_tms:
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; nr_items; i++) {</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :                 if (tm_list[i] &amp;&amp; !RB_EMPTY_NODE(&amp;tm_list[i]-&gt;node))</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                         rb_erase(&amp;tm_list[i]-&gt;node, &amp;fs_info-&gt;tree_mod_log);</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :                 kfree(tm_list[i]);</span>
<span class="lineNum">     636 </span>            :         }
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         if (locked)</span>
<span class="lineNum">     638 </span>            :                 tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         kfree(tm_list);</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         kfree(tm);</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">     643 </span>            : }
<a name="644"><span class="lineNum">     644 </span>            : </a>
<span class="lineNum">     645 </span>            : static inline int
<span class="lineNum">     646 </span><span class="lineCov">          6 : __tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,</span>
<span class="lineNum">     647 </span>            :                        struct tree_mod_elem **tm_list,
<span class="lineNum">     648 </span>            :                        int nritems)
<span class="lineNum">     649 </span>            : {
<span class="lineNum">     650 </span>            :         int i, j;
<span class="lineNum">     651 </span>            :         int ret;
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineCov">        227 :         for (i = nritems - 1; i &gt;= 0; i--) {</span>
<span class="lineNum">     654 </span><span class="lineCov">        221 :                 ret = __tree_mod_log_insert(fs_info, tm_list[i]);</span>
<span class="lineNum">     655 </span><span class="lineCov">        221 :                 if (ret) {</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :                         for (j = nritems - 1; j &gt; i; j--)</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                                 rb_erase(&amp;tm_list[j]-&gt;node,</span>
<span class="lineNum">     658 </span>            :                                          &amp;fs_info-&gt;tree_mod_log);
<span class="lineNum">     659 </span>            :                         return ret;
<span class="lineNum">     660 </span>            :                 }
<span class="lineNum">     661 </span>            :         }
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            :         return 0;
<span class="lineNum">     664 </span>            : }
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            : static noinline int
<span class="lineNum">     667 </span><span class="lineCov">      13659 : tree_mod_log_insert_root(struct btrfs_fs_info *fs_info,</span>
<span class="lineNum">     668 </span><span class="lineCov">         21 :                          struct extent_buffer *old_root,</span>
<span class="lineNum">     669 </span>            :                          struct extent_buffer *new_root, gfp_t flags,
<span class="lineNum">     670 </span>            :                          int log_removal)
<span class="lineNum">     671 </span>            : {
<span class="lineNum">     672 </span>            :         struct tree_mod_elem *tm = NULL;
<span class="lineNum">     673 </span>            :         struct tree_mod_elem **tm_list = NULL;
<span class="lineNum">     674 </span>            :         int nritems = 0;
<span class="lineNum">     675 </span>            :         int ret = 0;
<span class="lineNum">     676 </span>            :         int i;
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineCov">      13659 :         if (!tree_mod_need_log(fs_info, NULL))</span>
<span class="lineNum">     679 </span>            :                 return 0;
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineCov">         14 :         if (log_removal &amp;&amp; btrfs_header_level(old_root) &gt; 0) {</span>
<span class="lineNum">     682 </span><span class="lineCov">          6 :                 nritems = btrfs_header_nritems(old_root);</span>
<span class="lineNum">     683 </span><span class="lineCov">          6 :                 tm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),</span>
<span class="lineNum">     684 </span>            :                                   flags);
<span class="lineNum">     685 </span><span class="lineCov">          6 :                 if (!tm_list) {</span>
<span class="lineNum">     686 </span>            :                         ret = -ENOMEM;
<span class="lineNum">     687 </span>            :                         goto free_tms;
<span class="lineNum">     688 </span>            :                 }
<span class="lineNum">     689 </span><span class="lineCov">        221 :                 for (i = 0; i &lt; nritems; i++) {</span>
<span class="lineNum">     690 </span><span class="lineCov">        221 :                         tm_list[i] = alloc_tree_mod_elem(old_root, i,</span>
<span class="lineNum">     691 </span>            :                             MOD_LOG_KEY_REMOVE_WHILE_FREEING, flags);
<span class="lineNum">     692 </span><span class="lineCov">        221 :                         if (!tm_list[i]) {</span>
<span class="lineNum">     693 </span>            :                                 ret = -ENOMEM;
<span class="lineNum">     694 </span>            :                                 goto free_tms;
<span class="lineNum">     695 </span>            :                         }
<span class="lineNum">     696 </span>            :                 }
<span class="lineNum">     697 </span>            :         }
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">          7 :         tm = kzalloc(sizeof(*tm), flags);</span>
<span class="lineNum">     700 </span><span class="lineCov">          7 :         if (!tm) {</span>
<span class="lineNum">     701 </span>            :                 ret = -ENOMEM;
<span class="lineNum">     702 </span>            :                 goto free_tms;
<span class="lineNum">     703 </span>            :         }
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineCov">          7 :         tm-&gt;index = new_root-&gt;start &gt;&gt; PAGE_CACHE_SHIFT;</span>
<span class="lineNum">     706 </span><span class="lineCov">          7 :         tm-&gt;old_root.logical = old_root-&gt;start;</span>
<span class="lineNum">     707 </span><span class="lineCov">          7 :         tm-&gt;old_root.level = btrfs_header_level(old_root);</span>
<span class="lineNum">     708 </span><span class="lineCov">          7 :         tm-&gt;generation = btrfs_header_generation(old_root);</span>
<span class="lineNum">     709 </span><span class="lineCov">          7 :         tm-&gt;op = MOD_LOG_ROOT_REPLACE;</span>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineCov">          7 :         if (tree_mod_dont_log(fs_info, NULL))</span>
<span class="lineNum">     712 </span>            :                 goto free_tms;
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineCov">          7 :         if (tm_list)</span>
<span class="lineNum">     715 </span><span class="lineCov">          6 :                 ret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);</span>
<span class="lineNum">     716 </span><span class="lineCov">          7 :         if (!ret)</span>
<span class="lineNum">     717 </span><span class="lineCov">          7 :                 ret = __tree_mod_log_insert(fs_info, tm);</span>
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :         tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     720 </span><span class="lineCov">          7 :         if (ret)</span>
<span class="lineNum">     721 </span>            :                 goto free_tms;
<span class="lineNum">     722 </span><span class="lineCov">          7 :         kfree(tm_list);</span>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :         return ret;
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            : free_tms:
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         if (tm_list) {</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :                 for (i = 0; i &lt; nritems; i++)</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :                         kfree(tm_list[i]);</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :                 kfree(tm_list);</span>
<span class="lineNum">     731 </span>            :         }
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :         kfree(tm);</span>
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :         return ret;
<span class="lineNum">     735 </span>            : }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            : static struct tree_mod_elem *
<span class="lineNum">     738 </span><span class="lineCov">      21967 : __tree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq,</span>
<span class="lineNum">     739 </span>            :                       int smallest)
<span class="lineNum">     740 </span>            : {
<span class="lineNum">     741 </span>            :         struct rb_root *tm_root;
<span class="lineNum">     742 </span>            :         struct rb_node *node;
<span class="lineNum">     743 </span>            :         struct tree_mod_elem *cur = NULL;
<span class="lineNum">     744 </span>            :         struct tree_mod_elem *found = NULL;
<span class="lineNum">     745 </span><span class="lineCov">      21967 :         u64 index = start &gt;&gt; PAGE_CACHE_SHIFT;</span>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            :         tree_mod_log_read_lock(fs_info);
<span class="lineNum">     748 </span>            :         tm_root = &amp;fs_info-&gt;tree_mod_log;
<span class="lineNum">     749 </span><span class="lineCov">      21967 :         node = tm_root-&gt;rb_node;</span>
<span class="lineNum">     750 </span><span class="lineCov">      57305 :         while (node) {</span>
<span class="lineNum">     751 </span>            :                 cur = container_of(node, struct tree_mod_elem, node);
<span class="lineNum">     752 </span><span class="lineCov">      13371 :                 if (cur-&gt;index &lt; index) {</span>
<span class="lineNum">     753 </span><span class="lineCov">       1048 :                         node = node-&gt;rb_left;</span>
<span class="lineNum">     754 </span><span class="lineCov">      12323 :                 } else if (cur-&gt;index &gt; index) {</span>
<span class="lineNum">     755 </span><span class="lineCov">      12219 :                         node = node-&gt;rb_right;</span>
<span class="lineNum">     756 </span><span class="lineCov">        104 :                 } else if (cur-&gt;seq &lt; min_seq) {</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :                         node = node-&gt;rb_left;</span>
<span class="lineNum">     758 </span><span class="lineCov">        104 :                 } else if (!smallest) {</span>
<span class="lineNum">     759 </span>            :                         /* we want the node with the highest seq */
<span class="lineNum">     760 </span><span class="lineCov">         39 :                         if (found)</span>
<span class="lineNum">     761 </span><span class="lineCov">         18 :                                 BUG_ON(found-&gt;seq &gt; cur-&gt;seq);</span>
<span class="lineNum">     762 </span>            :                         found = cur;
<span class="lineNum">     763 </span><span class="lineCov">         39 :                         node = node-&gt;rb_left;</span>
<span class="lineNum">     764 </span><span class="lineCov">         65 :                 } else if (cur-&gt;seq &gt; min_seq) {</span>
<span class="lineNum">     765 </span>            :                         /* we want the node with the smallest seq */
<span class="lineNum">     766 </span><span class="lineCov">         65 :                         if (found)</span>
<span class="lineNum">     767 </span><span class="lineCov">         16 :                                 BUG_ON(found-&gt;seq &lt; cur-&gt;seq);</span>
<span class="lineNum">     768 </span>            :                         found = cur;
<span class="lineNum">     769 </span><span class="lineCov">         65 :                         node = node-&gt;rb_right;</span>
<span class="lineNum">     770 </span>            :                 } else {
<span class="lineNum">     771 </span>            :                         found = cur;
<span class="lineNum">     772 </span>            :                         break;
<span class="lineNum">     773 </span>            :                 }
<span class="lineNum">     774 </span>            :         }
<span class="lineNum">     775 </span>            :         tree_mod_log_read_unlock(fs_info);
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineCov">      21967 :         return found;</span>
<span class="lineNum">     778 </span>            : }
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            : /*
<span class="lineNum">     781 </span>            :  * this returns the element from the log with the smallest time sequence
<span class="lineNum">     782 </span>            :  * value that's in the log (the oldest log item). any element with a time
<span class="lineNum">     783 </span>            :  * sequence lower than min_seq will be ignored.
<span class="lineNum">     784 </span>            :  */
<span class="lineNum">     785 </span>            : static struct tree_mod_elem *
<span class="lineNum">     786 </span>            : tree_mod_log_search_oldest(struct btrfs_fs_info *fs_info, u64 start,
<a name="787"><span class="lineNum">     787 </span>            :                            u64 min_seq)</a>
<span class="lineNum">     788 </span>            : {
<span class="lineNum">     789 </span><span class="lineCov">      20677 :         return __tree_mod_log_search(fs_info, start, min_seq, 1);</span>
<span class="lineNum">     790 </span>            : }
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            : /*
<span class="lineNum">     793 </span>            :  * this returns the element from the log with the largest time sequence
<span class="lineNum">     794 </span>            :  * value that's in the log (the most recent log item). any element with
<span class="lineNum">     795 </span>            :  * a time sequence lower than min_seq will be ignored.
<span class="lineNum">     796 </span>            :  */
<span class="lineNum">     797 </span>            : static struct tree_mod_elem *
<a name="798"><span class="lineNum">     798 </span>            : tree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq)</a>
<span class="lineNum">     799 </span>            : {
<span class="lineNum">     800 </span><span class="lineCov">       1290 :         return __tree_mod_log_search(fs_info, start, min_seq, 0);</span>
<span class="lineNum">     801 </span>            : }
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : static noinline int
<span class="lineNum">     804 </span><span class="lineCov">        217 : tree_mod_log_eb_copy(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :                      struct extent_buffer *src, unsigned long dst_offset,</span>
<span class="lineNum">     806 </span>            :                      unsigned long src_offset, int nr_items)
<span class="lineNum">     807 </span>            : {
<span class="lineNum">     808 </span>            :         int ret = 0;
<span class="lineNum">     809 </span>            :         struct tree_mod_elem **tm_list = NULL;
<span class="lineNum">     810 </span>            :         struct tree_mod_elem **tm_list_add, **tm_list_rem;
<span class="lineNum">     811 </span>            :         int i;
<span class="lineNum">     812 </span>            :         int locked = 0;
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineCov">        211 :         if (!tree_mod_need_log(fs_info, NULL))</span>
<span class="lineNum">     815 </span>            :                 return 0;
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span><span class="lineCov">          6 :         if (btrfs_header_level(dst) == 0 &amp;&amp; btrfs_header_level(src) == 0)</span>
<span class="lineNum">     818 </span>            :                 return 0;
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineCov">          6 :         tm_list = kzalloc(nr_items * 2 * sizeof(struct tree_mod_elem *),</span>
<span class="lineNum">     821 </span>            :                           GFP_NOFS);
<span class="lineNum">     822 </span><span class="lineCov">          6 :         if (!tm_list)</span>
<span class="lineNum">     823 </span>            :                 return -ENOMEM;
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            :         tm_list_add = tm_list;
<span class="lineNum">     826 </span><span class="lineCov">          6 :         tm_list_rem = tm_list + nr_items;</span>
<span class="lineNum">     827 </span><span class="lineCov">        239 :         for (i = 0; i &lt; nr_items; i++) {</span>
<span class="lineNum">     828 </span><span class="lineCov">        233 :                 tm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,</span>
<span class="lineNum">     829 </span>            :                     MOD_LOG_KEY_REMOVE, GFP_NOFS);
<span class="lineNum">     830 </span><span class="lineCov">        233 :                 if (!tm_list_rem[i]) {</span>
<span class="lineNum">     831 </span>            :                         ret = -ENOMEM;
<span class="lineNum">     832 </span>            :                         goto free_tms;
<span class="lineNum">     833 </span>            :                 }
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineCov">        233 :                 tm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,</span>
<span class="lineNum">     836 </span>            :                     MOD_LOG_KEY_ADD, GFP_NOFS);
<span class="lineNum">     837 </span><span class="lineCov">        233 :                 if (!tm_list_add[i]) {</span>
<span class="lineNum">     838 </span>            :                         ret = -ENOMEM;
<span class="lineNum">     839 </span>            :                         goto free_tms;
<span class="lineNum">     840 </span>            :                 }
<span class="lineNum">     841 </span>            :         }
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span><span class="lineCov">          6 :         if (tree_mod_dont_log(fs_info, NULL))</span>
<span class="lineNum">     844 </span>            :                 goto free_tms;
<span class="lineNum">     845 </span>            :         locked = 1;
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span><span class="lineCov">        233 :         for (i = 0; i &lt; nr_items; i++) {</span>
<span class="lineNum">     848 </span><span class="lineCov">        233 :                 ret = __tree_mod_log_insert(fs_info, tm_list_rem[i]);</span>
<span class="lineNum">     849 </span><span class="lineCov">        233 :                 if (ret)</span>
<span class="lineNum">     850 </span>            :                         goto free_tms;
<span class="lineNum">     851 </span><span class="lineCov">        233 :                 ret = __tree_mod_log_insert(fs_info, tm_list_add[i]);</span>
<span class="lineNum">     852 </span><span class="lineCov">        233 :                 if (ret)</span>
<span class="lineNum">     853 </span>            :                         goto free_tms;
<span class="lineNum">     854 </span>            :         }
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            :         tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     857 </span><span class="lineCov">          6 :         kfree(tm_list);</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineCov">          6 :         return 0;</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            : free_tms:
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; nr_items * 2; i++) {</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                 if (tm_list[i] &amp;&amp; !RB_EMPTY_NODE(&amp;tm_list[i]-&gt;node))</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :                         rb_erase(&amp;tm_list[i]-&gt;node, &amp;fs_info-&gt;tree_mod_log);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :                 kfree(tm_list[i]);</span>
<span class="lineNum">     866 </span>            :         }
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         if (locked)</span>
<span class="lineNum">     868 </span>            :                 tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :         kfree(tm_list);</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">     872 </span>            : }
<a name="873"><span class="lineNum">     873 </span>            : </a>
<span class="lineNum">     874 </span>            : static inline void
<span class="lineNum">     875 </span><span class="lineCov">       4522 : tree_mod_log_eb_move(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,</span>
<span class="lineNum">     876 </span>            :                      int dst_offset, int src_offset, int nr_items)
<span class="lineNum">     877 </span>            : {
<span class="lineNum">     878 </span>            :         int ret;
<span class="lineNum">     879 </span><span class="lineCov">       4522 :         ret = tree_mod_log_insert_move(fs_info, dst, dst_offset, src_offset,</span>
<span class="lineNum">     880 </span>            :                                        nr_items, GFP_NOFS);
<span class="lineNum">     881 </span><span class="lineCov">       4522 :         BUG_ON(ret &lt; 0);</span>
<span class="lineNum">     882 </span><span class="lineCov">       4522 : }</span>
<a name="883"><span class="lineNum">     883 </span>            : </a>
<span class="lineNum">     884 </span>            : static noinline void
<span class="lineNum">     885 </span><span class="lineCov">      13775 : tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,</span>
<span class="lineNum">     886 </span>            :                           struct extent_buffer *eb, int slot, int atomic)
<span class="lineNum">     887 </span>            : {
<span class="lineNum">     888 </span>            :         int ret;
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineCov">      13775 :         ret = tree_mod_log_insert_key(fs_info, eb, slot,</span>
<span class="lineNum">     891 </span>            :                                         MOD_LOG_KEY_REPLACE,
<span class="lineNum">     892 </span>            :                                         atomic ? GFP_ATOMIC : GFP_NOFS);
<span class="lineNum">     893 </span><span class="lineCov">      13775 :         BUG_ON(ret &lt; 0);</span>
<span class="lineNum">     894 </span><span class="lineCov">      13775 : }</span>
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            : static noinline int
<span class="lineNum">     897 </span><span class="lineCov">      38288 : tree_mod_log_free_eb(struct btrfs_fs_info *fs_info, struct extent_buffer *eb)</span>
<span class="lineNum">     898 </span>            : {
<span class="lineNum">     899 </span>            :         struct tree_mod_elem **tm_list = NULL;
<span class="lineNum">     900 </span>            :         int nritems = 0;
<span class="lineNum">     901 </span>            :         int i;
<span class="lineNum">     902 </span>            :         int ret = 0;
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span><span class="lineCov">      38288 :         if (btrfs_header_level(eb) == 0)</span>
<span class="lineNum">     905 </span>            :                 return 0;
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineCov">       3252 :         if (!tree_mod_need_log(fs_info, NULL))</span>
<span class="lineNum">     908 </span>            :                 return 0;
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         nritems = btrfs_header_nritems(eb);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :         tm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),</span>
<span class="lineNum">     912 </span>            :                           GFP_NOFS);
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :         if (!tm_list)</span>
<span class="lineNum">     914 </span>            :                 return -ENOMEM;
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; nritems; i++) {</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :                 tm_list[i] = alloc_tree_mod_elem(eb, i,</span>
<span class="lineNum">     918 </span>            :                     MOD_LOG_KEY_REMOVE_WHILE_FREEING, GFP_NOFS);
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                 if (!tm_list[i]) {</span>
<span class="lineNum">     920 </span>            :                         ret = -ENOMEM;
<span class="lineNum">     921 </span>            :                         goto free_tms;
<span class="lineNum">     922 </span>            :                 }
<span class="lineNum">     923 </span>            :         }
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :         if (tree_mod_dont_log(fs_info, eb))</span>
<span class="lineNum">     926 </span>            :                 goto free_tms;
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         ret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);</span>
<span class="lineNum">     929 </span>            :         tree_mod_log_write_unlock(fs_info);
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :         if (ret)</span>
<span class="lineNum">     931 </span>            :                 goto free_tms;
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :         kfree(tm_list);</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            : free_tms:
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; nritems; i++)</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :                 kfree(tm_list[i]);</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         kfree(tm_list);</span>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">     942 </span>            : }
<a name="943"><span class="lineNum">     943 </span>            : </a>
<span class="lineNum">     944 </span>            : static noinline void
<span class="lineNum">     945 </span><span class="lineCov">      13659 : tree_mod_log_set_root_pointer(struct btrfs_root *root,</span>
<span class="lineNum">     946 </span>            :                               struct extent_buffer *new_root_node,
<span class="lineNum">     947 </span>            :                               int log_removal)
<span class="lineNum">     948 </span>            : {
<span class="lineNum">     949 </span>            :         int ret;
<span class="lineNum">     950 </span><span class="lineCov">      13659 :         ret = tree_mod_log_insert_root(root-&gt;fs_info, root-&gt;node,</span>
<span class="lineNum">     951 </span>            :                                        new_root_node, GFP_NOFS, log_removal);
<span class="lineNum">     952 </span><span class="lineCov">      13658 :         BUG_ON(ret &lt; 0);</span>
<span class="lineNum">     953 </span><span class="lineCov">      13658 : }</span>
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            : /*
<a name="956"><span class="lineNum">     956 </span>            :  * check if the tree block can be shared by multiple trees</a>
<span class="lineNum">     957 </span>            :  */
<span class="lineNum">     958 </span><span class="lineCov">      52290 : int btrfs_block_can_be_shared(struct btrfs_root *root,</span>
<span class="lineNum">     959 </span><span class="lineCov">      19589 :                               struct extent_buffer *buf)</span>
<span class="lineNum">     960 </span>            : {
<span class="lineNum">     961 </span>            :         /*
<span class="lineNum">     962 </span>            :          * Tree blocks not in refernece counted trees and tree roots
<span class="lineNum">     963 </span>            :          * are never shared. If a block was allocated after the last
<span class="lineNum">     964 </span>            :          * snapshot and the block was not allocated by tree relocation,
<span class="lineNum">     965 </span>            :          * we know the block is not shared.
<span class="lineNum">     966 </span>            :          */
<span class="lineNum">     967 </span><span class="lineCov">      75123 :         if (test_bit(BTRFS_ROOT_REF_COWS, &amp;root-&gt;state) &amp;&amp;</span>
<span class="lineNum">     968 </span><span class="lineCov">      62011 :             buf != root-&gt;node &amp;&amp; buf != root-&gt;commit_root &amp;&amp;</span>
<span class="lineNum">     969 </span>            :             (btrfs_header_generation(buf) &lt;=
<span class="lineNum">     970 </span><span class="lineCov">      18647 :              btrfs_root_last_snapshot(&amp;root-&gt;root_item) ||</span>
<span class="lineNum">     971 </span>            :              btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)))
<span class="lineNum">     972 </span>            :                 return 1;
<span class="lineNum">     973 </span>            : #ifdef BTRFS_COMPAT_EXTENT_TREE_V0
<span class="lineNum">     974 </span><span class="lineCov">      73225 :         if (test_bit(BTRFS_ROOT_REF_COWS, &amp;root-&gt;state) &amp;&amp;</span>
<span class="lineNum">     975 </span>            :             btrfs_header_backref_rev(buf) &lt; BTRFS_MIXED_BACKREF_REV)
<span class="lineNum">     976 </span>            :                 return 1;
<span class="lineNum">     977 </span>            : #endif
<span class="lineNum">     978 </span><span class="lineCov">      51341 :         return 0;</span>
<a name="979"><span class="lineNum">     979 </span>            : }</a>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineCov">      52284 : static noinline int update_ref_for_cow(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">     982 </span>            :                                        struct btrfs_root *root,
<span class="lineNum">     983 </span><span class="lineCov">      53645 :                                        struct extent_buffer *buf,</span>
<span class="lineNum">     984 </span>            :                                        struct extent_buffer *cow,
<span class="lineNum">     985 </span>            :                                        int *last_ref)
<span class="lineNum">     986 </span>            : {
<span class="lineNum">     987 </span>            :         u64 refs;
<span class="lineNum">     988 </span>            :         u64 owner;
<span class="lineNum">     989 </span>            :         u64 flags;
<span class="lineNum">     990 </span>            :         u64 new_flags = 0;
<span class="lineNum">     991 </span>            :         int ret;
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            :         /*
<span class="lineNum">     994 </span>            :          * Backrefs update rules:
<span class="lineNum">     995 </span>            :          *
<span class="lineNum">     996 </span>            :          * Always use full backrefs for extent pointers in tree block
<span class="lineNum">     997 </span>            :          * allocated by tree relocation.
<span class="lineNum">     998 </span>            :          *
<span class="lineNum">     999 </span>            :          * If a shared tree block is no longer referenced by its owner
<span class="lineNum">    1000 </span>            :          * tree (btrfs_header_owner(buf) == root-&gt;root_key.objectid),
<span class="lineNum">    1001 </span>            :          * use full backrefs for extent pointers in tree block.
<span class="lineNum">    1002 </span>            :          *
<span class="lineNum">    1003 </span>            :          * If a tree block is been relocating
<span class="lineNum">    1004 </span>            :          * (root-&gt;root_key.objectid == BTRFS_TREE_RELOC_OBJECTID),
<span class="lineNum">    1005 </span>            :          * use full backrefs for extent pointers in tree block.
<span class="lineNum">    1006 </span>            :          * The reason for this is some operations (such as drop tree)
<span class="lineNum">    1007 </span>            :          * are only allowed for blocks use full backrefs.
<span class="lineNum">    1008 </span>            :          */
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span><span class="lineCov">      52284 :         if (btrfs_block_can_be_shared(root, buf)) {</span>
<span class="lineNum">    1011 </span><span class="lineCov">        949 :                 ret = btrfs_lookup_extent_info(trans, root, buf-&gt;start,</span>
<span class="lineNum">    1012 </span>            :                                                btrfs_header_level(buf), 1,
<span class="lineNum">    1013 </span>            :                                                &amp;refs, &amp;flags);
<span class="lineNum">    1014 </span><span class="lineCov">        949 :                 if (ret)</span>
<span class="lineNum">    1015 </span>            :                         return ret;
<span class="lineNum">    1016 </span><span class="lineCov">        949 :                 if (refs == 0) {</span>
<span class="lineNum">    1017 </span>            :                         ret = -EROFS;
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :                         btrfs_std_error(root-&gt;fs_info, ret);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :                         return ret;</span>
<span class="lineNum">    1020 </span>            :                 }
<span class="lineNum">    1021 </span>            :         } else {
<span class="lineNum">    1022 </span><span class="lineCov">      51335 :                 refs = 1;</span>
<span class="lineNum">    1023 </span><span class="lineCov">     102668 :                 if (root-&gt;root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||</span>
<span class="lineNum">    1024 </span>            :                     btrfs_header_backref_rev(buf) &lt; BTRFS_MIXED_BACKREF_REV)
<span class="lineNum">    1025 </span><span class="lineCov">          2 :                         flags = BTRFS_BLOCK_FLAG_FULL_BACKREF;</span>
<span class="lineNum">    1026 </span>            :                 else
<span class="lineNum">    1027 </span><span class="lineCov">      51333 :                         flags = 0;</span>
<span class="lineNum">    1028 </span>            :         }
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            :         owner = btrfs_header_owner(buf);
<span class="lineNum">    1031 </span><span class="lineCov">      52284 :         BUG_ON(owner == BTRFS_TREE_RELOC_OBJECTID &amp;&amp;</span>
<span class="lineNum">    1032 </span>            :                !(flags &amp; BTRFS_BLOCK_FLAG_FULL_BACKREF));
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span><span class="lineCov">      52284 :         if (refs &gt; 1) {</span>
<span class="lineNum">    1035 </span><span class="lineCov">        470 :                 if ((owner == root-&gt;root_key.objectid ||</span>
<span class="lineNum">    1036 </span><span class="lineCov">        419 :                      root-&gt;root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) &amp;&amp;</span>
<span class="lineNum">    1037 </span><span class="lineCov">        419 :                     !(flags &amp; BTRFS_BLOCK_FLAG_FULL_BACKREF)) {</span>
<span class="lineNum">    1038 </span><span class="lineCov">        412 :                         ret = btrfs_inc_ref(trans, root, buf, 1);</span>
<span class="lineNum">    1039 </span><span class="lineCov">        412 :                         BUG_ON(ret); /* -ENOMEM */</span>
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span><span class="lineCov">        412 :                         if (root-&gt;root_key.objectid ==</span>
<span class="lineNum">    1042 </span>            :                             BTRFS_TREE_RELOC_OBJECTID) {
<span class="lineNum">    1043 </span><span class="lineCov">          9 :                                 ret = btrfs_dec_ref(trans, root, buf, 0);</span>
<span class="lineNum">    1044 </span><span class="lineCov">          9 :                                 BUG_ON(ret); /* -ENOMEM */</span>
<span class="lineNum">    1045 </span><span class="lineCov">          9 :                                 ret = btrfs_inc_ref(trans, root, cow, 1);</span>
<span class="lineNum">    1046 </span><span class="lineCov">          9 :                                 BUG_ON(ret); /* -ENOMEM */</span>
<span class="lineNum">    1047 </span>            :                         }
<span class="lineNum">    1048 </span>            :                         new_flags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;
<span class="lineNum">    1049 </span>            :                 } else {
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span><span class="lineCov">         58 :                         if (root-&gt;root_key.objectid ==</span>
<span class="lineNum">    1052 </span>            :                             BTRFS_TREE_RELOC_OBJECTID)
<span class="lineNum">    1053 </span><span class="lineCov">          7 :                                 ret = btrfs_inc_ref(trans, root, cow, 1);</span>
<span class="lineNum">    1054 </span>            :                         else
<span class="lineNum">    1055 </span><span class="lineCov">         51 :                                 ret = btrfs_inc_ref(trans, root, cow, 0);</span>
<span class="lineNum">    1056 </span><span class="lineCov">         58 :                         BUG_ON(ret); /* -ENOMEM */</span>
<span class="lineNum">    1057 </span>            :                 }
<span class="lineNum">    1058 </span><span class="lineCov">        470 :                 if (new_flags != 0) {</span>
<span class="lineNum">    1059 </span><span class="lineCov">        412 :                         int level = btrfs_header_level(buf);</span>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span><span class="lineCov">        412 :                         ret = btrfs_set_disk_extent_flags(trans, root,</span>
<span class="lineNum">    1062 </span>            :                                                           buf-&gt;start,
<span class="lineNum">    1063 </span><span class="lineCov">        412 :                                                           buf-&gt;len,</span>
<span class="lineNum">    1064 </span>            :                                                           new_flags, level, 0);
<span class="lineNum">    1065 </span><span class="lineCov">        412 :                         if (ret)</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :                                 return ret;</span>
<span class="lineNum">    1067 </span>            :                 }
<span class="lineNum">    1068 </span>            :         } else {
<span class="lineNum">    1069 </span><span class="lineCov">      51814 :                 if (flags &amp; BTRFS_BLOCK_FLAG_FULL_BACKREF) {</span>
<span class="lineNum">    1070 </span><span class="lineCov">        332 :                         if (root-&gt;root_key.objectid ==</span>
<span class="lineNum">    1071 </span>            :                             BTRFS_TREE_RELOC_OBJECTID)
<span class="lineNum">    1072 </span><span class="lineCov">          2 :                                 ret = btrfs_inc_ref(trans, root, cow, 1);</span>
<span class="lineNum">    1073 </span>            :                         else
<span class="lineNum">    1074 </span><span class="lineCov">        330 :                                 ret = btrfs_inc_ref(trans, root, cow, 0);</span>
<span class="lineNum">    1075 </span><span class="lineCov">        332 :                         BUG_ON(ret); /* -ENOMEM */</span>
<span class="lineNum">    1076 </span><span class="lineCov">        332 :                         ret = btrfs_dec_ref(trans, root, buf, 1);</span>
<span class="lineNum">    1077 </span><span class="lineCov">        332 :                         BUG_ON(ret); /* -ENOMEM */</span>
<span class="lineNum">    1078 </span>            :                 }
<span class="lineNum">    1079 </span><span class="lineCov">      51814 :                 clean_tree_block(trans, root, buf);</span>
<span class="lineNum">    1080 </span><span class="lineCov">      51814 :                 *last_ref = 1;</span>
<span class="lineNum">    1081 </span>            :         }
<span class="lineNum">    1082 </span>            :         return 0;
<span class="lineNum">    1083 </span>            : }
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            : /*
<span class="lineNum">    1086 </span>            :  * does the dirty work in cow of a single block.  The parent block (if
<span class="lineNum">    1087 </span>            :  * supplied) is updated to point to the new cow copy.  The new buffer is marked
<span class="lineNum">    1088 </span>            :  * dirty and returned locked.  If you modify the block it needs to be marked
<span class="lineNum">    1089 </span>            :  * dirty again.
<span class="lineNum">    1090 </span>            :  *
<span class="lineNum">    1091 </span>            :  * search_start -- an allocation hint for the new block
<span class="lineNum">    1092 </span>            :  *
<span class="lineNum">    1093 </span>            :  * empty_size -- a hint that you plan on doing more cow.  This is the size in
<span class="lineNum">    1094 </span>            :  * bytes the allocator should try to find free next to the block it returns.
<a name="1095"><span class="lineNum">    1095 </span>            :  * This is just a hint and may be ignored by the allocator.</a>
<span class="lineNum">    1096 </span>            :  */
<span class="lineNum">    1097 </span><span class="lineCov">      52285 : static noinline int __btrfs_cow_block(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    1098 </span><span class="lineCov">      13527 :                              struct btrfs_root *root,</span>
<span class="lineNum">    1099 </span><span class="lineCov">      52284 :                              struct extent_buffer *buf,</span>
<span class="lineNum">    1100 </span><span class="lineCov">      38757 :                              struct extent_buffer *parent, int parent_slot,</span>
<span class="lineNum">    1101 </span>            :                              struct extent_buffer **cow_ret,
<span class="lineNum">    1102 </span>            :                              u64 search_start, u64 empty_size)
<span class="lineNum">    1103 </span>            : {
<span class="lineNum">    1104 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    1105 </span><span class="lineCov">     156840 :         struct extent_buffer *cow;</span>
<span class="lineNum">    1106 </span>            :         int level, ret;
<span class="lineNum">    1107 </span><span class="lineCov">      52285 :         int last_ref = 0;</span>
<span class="lineNum">    1108 </span>            :         int unlock_orig = 0;
<span class="lineNum">    1109 </span>            :         u64 parent_start;
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span><span class="lineCov">      52285 :         if (*cow_ret == buf)</span>
<span class="lineNum">    1112 </span>            :                 unlock_orig = 1;
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineCov">      52285 :         btrfs_assert_tree_locked(buf);</span>
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span><span class="lineCov">      52283 :         WARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &amp;root-&gt;state) &amp;&amp;</span>
<span class="lineNum">    1117 </span>            :                 trans-&gt;transid != root-&gt;fs_info-&gt;running_transaction-&gt;transid);
<span class="lineNum">    1118 </span><span class="lineCov">      52284 :         WARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &amp;root-&gt;state) &amp;&amp;</span>
<span class="lineNum">    1119 </span>            :                 trans-&gt;transid != root-&gt;last_trans);
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span><span class="lineCov">      52284 :         level = btrfs_header_level(buf);</span>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineCov">      52284 :         if (level == 0)</span>
<span class="lineNum">    1124 </span>            :                 btrfs_item_key(buf, &amp;disk_key, 0);
<span class="lineNum">    1125 </span>            :         else
<span class="lineNum">    1126 </span><span class="lineCov">       7972 :                 btrfs_node_key(buf, &amp;disk_key, 0);</span>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span><span class="lineCov">      52284 :         if (root-&gt;root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {</span>
<span class="lineNum">    1129 </span><span class="lineCov">         18 :                 if (parent)</span>
<span class="lineNum">    1130 </span><span class="lineCov">         16 :                         parent_start = parent-&gt;start;</span>
<span class="lineNum">    1131 </span>            :                 else
<span class="lineNum">    1132 </span>            :                         parent_start = 0;
<span class="lineNum">    1133 </span>            :         } else
<span class="lineNum">    1134 </span>            :                 parent_start = 0;
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span><span class="lineCov">      52284 :         cow = btrfs_alloc_free_block(trans, root, buf-&gt;len, parent_start,</span>
<span class="lineNum">    1137 </span>            :                                      root-&gt;root_key.objectid, &amp;disk_key,
<span class="lineNum">    1138 </span>            :                                      level, search_start, empty_size);
<span class="lineNum">    1139 </span><span class="lineCov">      52286 :         if (IS_ERR(cow))</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                 return PTR_ERR(cow);</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :         /* cow is set to blocking by btrfs_init_new_buffer */
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span><span class="lineCov">      52286 :         copy_extent_buffer(cow, buf, 0, 0, cow-&gt;len);</span>
<span class="lineNum">    1145 </span><span class="lineCov">      52286 :         btrfs_set_header_bytenr(cow, cow-&gt;start);</span>
<span class="lineNum">    1146 </span><span class="lineCov">      52286 :         btrfs_set_header_generation(cow, trans-&gt;transid);</span>
<span class="lineNum">    1147 </span>            :         btrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);
<span class="lineNum">    1148 </span>            :         btrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |
<span class="lineNum">    1149 </span>            :                                      BTRFS_HEADER_FLAG_RELOC);
<span class="lineNum">    1150 </span><span class="lineCov">      52286 :         if (root-&gt;root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)</span>
<span class="lineNum">    1151 </span>            :                 btrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);
<span class="lineNum">    1152 </span>            :         else
<span class="lineNum">    1153 </span>            :                 btrfs_set_header_owner(cow, root-&gt;root_key.objectid);
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span><span class="lineCov">      52286 :         write_extent_buffer(cow, root-&gt;fs_info-&gt;fsid, btrfs_header_fsid(),</span>
<span class="lineNum">    1156 </span>            :                             BTRFS_FSID_SIZE);
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span><span class="lineCov">      52284 :         ret = update_ref_for_cow(trans, root, buf, cow, &amp;last_ref);</span>
<span class="lineNum">    1159 </span><span class="lineCov">      52284 :         if (ret) {</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :                 btrfs_abort_transaction(trans, root, ret);</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    1162 </span>            :         }
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span><span class="lineCov">      52284 :         if (test_bit(BTRFS_ROOT_REF_COWS, &amp;root-&gt;state)) {</span>
<span class="lineNum">    1165 </span><span class="lineCov">      22831 :                 ret = btrfs_reloc_cow_block(trans, root, buf, cow);</span>
<span class="lineNum">    1166 </span><span class="lineCov">      22831 :                 if (ret)</span>
<span class="lineNum">    1167 </span>            :                         return ret;
<span class="lineNum">    1168 </span>            :         }
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span><span class="lineCov">      52285 :         if (buf == root-&gt;node) {</span>
<span class="lineNum">    1171 </span><span class="lineCov">      13528 :                 WARN_ON(parent &amp;&amp; parent != buf);</span>
<span class="lineNum">    1172 </span><span class="lineCov">      27054 :                 if (root-&gt;root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||</span>
<span class="lineNum">    1173 </span>            :                     btrfs_header_backref_rev(buf) &lt; BTRFS_MIXED_BACKREF_REV)
<span class="lineNum">    1174 </span><span class="lineCov">          2 :                         parent_start = buf-&gt;start;</span>
<span class="lineNum">    1175 </span>            :                 else
<span class="lineNum">    1176 </span>            :                         parent_start = 0;
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            :                 extent_buffer_get(cow);
<span class="lineNum">    1179 </span><span class="lineCov">      13527 :                 tree_mod_log_set_root_pointer(root, cow, 1);</span>
<span class="lineNum">    1180 </span><span class="lineCov">      13527 :                 rcu_assign_pointer(root-&gt;node, cow);</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span><span class="lineCov">      13527 :                 btrfs_free_tree_block(trans, root, buf, parent_start,</span>
<span class="lineNum">    1183 </span>            :                                       last_ref);
<span class="lineNum">    1184 </span><span class="lineCov">      13528 :                 free_extent_buffer(buf);</span>
<span class="lineNum">    1185 </span><span class="lineCov">      13528 :                 add_root_to_dirty_list(root);</span>
<span class="lineNum">    1186 </span>            :         } else {
<span class="lineNum">    1187 </span><span class="lineCov">      38757 :                 if (root-&gt;root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)</span>
<span class="lineNum">    1188 </span><span class="lineCov">         16 :                         parent_start = parent-&gt;start;</span>
<span class="lineNum">    1189 </span>            :                 else
<span class="lineNum">    1190 </span>            :                         parent_start = 0;
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span><span class="lineCov">      77514 :                 WARN_ON(trans-&gt;transid != btrfs_header_generation(parent));</span>
<span class="lineNum">    1193 </span><span class="lineCov">      38757 :                 tree_mod_log_insert_key(root-&gt;fs_info, parent, parent_slot,</span>
<span class="lineNum">    1194 </span>            :                                         MOD_LOG_KEY_REPLACE, GFP_NOFS);
<span class="lineNum">    1195 </span><span class="lineCov">      38757 :                 btrfs_set_node_blockptr(parent, parent_slot,</span>
<span class="lineNum">    1196 </span>            :                                         cow-&gt;start);
<span class="lineNum">    1197 </span><span class="lineCov">      38757 :                 btrfs_set_node_ptr_generation(parent, parent_slot,</span>
<span class="lineNum">    1198 </span>            :                                               trans-&gt;transid);
<span class="lineNum">    1199 </span><span class="lineCov">      38756 :                 btrfs_mark_buffer_dirty(parent);</span>
<span class="lineNum">    1200 </span><span class="lineCov">      38758 :                 if (last_ref) {</span>
<span class="lineNum">    1201 </span><span class="lineCov">      38288 :                         ret = tree_mod_log_free_eb(root-&gt;fs_info, buf);</span>
<span class="lineNum">    1202 </span><span class="lineCov">      38288 :                         if (ret) {</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                                 btrfs_abort_transaction(trans, root, ret);</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :                                 return ret;</span>
<span class="lineNum">    1205 </span>            :                         }
<span class="lineNum">    1206 </span>            :                 }
<span class="lineNum">    1207 </span><span class="lineCov">      38758 :                 btrfs_free_tree_block(trans, root, buf, parent_start,</span>
<span class="lineNum">    1208 </span>            :                                       last_ref);
<span class="lineNum">    1209 </span>            :         }
<span class="lineNum">    1210 </span><span class="lineCov">      52286 :         if (unlock_orig)</span>
<span class="lineNum">    1211 </span><span class="lineCov">      52286 :                 btrfs_tree_unlock(buf);</span>
<span class="lineNum">    1212 </span><span class="lineCov">      52286 :         free_extent_buffer_stale(buf);</span>
<span class="lineNum">    1213 </span><span class="lineCov">      52284 :         btrfs_mark_buffer_dirty(cow);</span>
<span class="lineNum">    1214 </span><span class="lineCov">      52285 :         *cow_ret = cow;</span>
<span class="lineNum">    1215 </span><span class="lineCov">      52285 :         return 0;</span>
<span class="lineNum">    1216 </span>            : }
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            : /*
<span class="lineNum">    1219 </span>            :  * returns the logical address of the oldest predecessor of the given root.
<span class="lineNum">    1220 </span>            :  * entries older than time_seq are ignored.
<span class="lineNum">    1221 </span>            :  */
<span class="lineNum">    1222 </span>            : static struct tree_mod_elem *
<span class="lineNum">    1223 </span><span class="lineCov">      20675 : __tree_mod_log_oldest_root(struct btrfs_fs_info *fs_info,</span>
<span class="lineNum">    1224 </span>            :                            struct extent_buffer *eb_root, u64 time_seq)
<span class="lineNum">    1225 </span>            : {
<span class="lineNum">    1226 </span>            :         struct tree_mod_elem *tm;
<span class="lineNum">    1227 </span>            :         struct tree_mod_elem *found = NULL;
<span class="lineNum">    1228 </span><span class="lineCov">      20675 :         u64 root_logical = eb_root-&gt;start;</span>
<span class="lineNum">    1229 </span>            :         int looped = 0;
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span><span class="lineCov">      20675 :         if (!time_seq)</span>
<span class="lineNum">    1232 </span>            :                 return NULL;
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            :         /*
<span class="lineNum">    1235 </span>            :          * the very last operation that's logged for a root is the replacement
<span class="lineNum">    1236 </span>            :          * operation (if it is replaced at all). this has the index of the *new*
<span class="lineNum">    1237 </span>            :          * root, making it the very first operation that's logged for this root.
<span class="lineNum">    1238 </span>            :          */
<span class="lineNum">    1239 </span>            :         while (1) {
<span class="lineNum">    1240 </span>            :                 tm = tree_mod_log_search_oldest(fs_info, root_logical,
<span class="lineNum">    1241 </span>            :                                                 time_seq);
<span class="lineNum">    1242 </span><span class="lineCov">      20677 :                 if (!looped &amp;&amp; !tm)</span>
<span class="lineNum">    1243 </span>            :                         return NULL;
<span class="lineNum">    1244 </span>            :                 /*
<span class="lineNum">    1245 </span>            :                  * if there are no tree operation for the oldest root, we simply
<span class="lineNum">    1246 </span>            :                  * return it. this should only happen if that (old) root is at
<span class="lineNum">    1247 </span>            :                  * level 0.
<span class="lineNum">    1248 </span>            :                  */
<span class="lineNum">    1249 </span><span class="lineCov">         49 :                 if (!tm)</span>
<span class="lineNum">    1250 </span>            :                         break;
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span>            :                 /*
<span class="lineNum">    1253 </span>            :                  * if there's an operation that's not a root replacement, we
<span class="lineNum">    1254 </span>            :                  * found the oldest version of our root. normally, we'll find a
<span class="lineNum">    1255 </span>            :                  * MOD_LOG_KEY_REMOVE_WHILE_FREEING operation here.
<span class="lineNum">    1256 </span>            :                  */
<span class="lineNum">    1257 </span><span class="lineCov">         49 :                 if (tm-&gt;op != MOD_LOG_ROOT_REPLACE)</span>
<span class="lineNum">    1258 </span>            :                         break;
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            :                 found = tm;
<span class="lineNum">    1261 </span><span class="lineCov">          2 :                 root_logical = tm-&gt;old_root.logical;</span>
<span class="lineNum">    1262 </span>            :                 looped = 1;
<span class="lineNum">    1263 </span>            :         }
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span>            :         /* if there's no old root to return, return what we found instead */
<span class="lineNum">    1266 </span><span class="lineCov">         47 :         if (!found)</span>
<span class="lineNum">    1267 </span>            :                 found = tm;
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span>            :         return found;
<span class="lineNum">    1270 </span>            : }
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            : /*
<span class="lineNum">    1273 </span>            :  * tm is a pointer to the first operation to rewind within eb. then, all
<span class="lineNum">    1274 </span>            :  * previous operations will be rewinded (until we reach something older than
<span class="lineNum">    1275 </span>            :  * time_seq).
<span class="lineNum">    1276 </span>            :  */
<span class="lineNum">    1277 </span>            : static void
<span class="lineNum">    1278 </span><span class="lineCov">         42 : __tree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct extent_buffer *eb,</span>
<span class="lineNum">    1279 </span>            :                       u64 time_seq, struct tree_mod_elem *first_tm)
<span class="lineNum">    1280 </span>            : {
<span class="lineNum">    1281 </span>            :         u32 n;
<span class="lineNum">    1282 </span>            :         struct rb_node *next;
<span class="lineNum">    1283 </span>            :         struct tree_mod_elem *tm = first_tm;
<span class="lineNum">    1284 </span>            :         unsigned long o_dst;
<span class="lineNum">    1285 </span>            :         unsigned long o_src;
<span class="lineNum">    1286 </span>            :         unsigned long p_size = sizeof(struct btrfs_key_ptr);
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            :         n = btrfs_header_nritems(eb);
<span class="lineNum">    1289 </span>            :         tree_mod_log_read_lock(fs_info);
<span class="lineNum">    1290 </span><span class="lineCov">        238 :         while (tm &amp;&amp; tm-&gt;seq &gt;= time_seq) {</span>
<span class="lineNum">    1291 </span>            :                 /*
<span class="lineNum">    1292 </span>            :                  * all the operations are recorded with the operator used for
<span class="lineNum">    1293 </span>            :                  * the modification. as we're going backwards, we do the
<span class="lineNum">    1294 </span>            :                  * opposite of each operation here.
<span class="lineNum">    1295 </span>            :                  */
<span class="lineNum">    1296 </span><span class="lineCov">        238 :                 switch (tm-&gt;op) {</span>
<span class="lineNum">    1297 </span>            :                 case MOD_LOG_KEY_REMOVE_WHILE_FREEING:
<span class="lineNum">    1298 </span><span class="lineCov">        208 :                         BUG_ON(tm-&gt;slot &lt; n);</span>
<span class="lineNum">    1299 </span>            :                         /* Fallthrough */
<span class="lineNum">    1300 </span>            :                 case MOD_LOG_KEY_REMOVE_WHILE_MOVING:
<span class="lineNum">    1301 </span>            :                 case MOD_LOG_KEY_REMOVE:
<span class="lineNum">    1302 </span><span class="lineCov">        208 :                         btrfs_set_node_key(eb, &amp;tm-&gt;key, tm-&gt;slot);</span>
<span class="lineNum">    1303 </span><span class="lineCov">        208 :                         btrfs_set_node_blockptr(eb, tm-&gt;slot, tm-&gt;blockptr);</span>
<span class="lineNum">    1304 </span><span class="lineCov">        208 :                         btrfs_set_node_ptr_generation(eb, tm-&gt;slot,</span>
<span class="lineNum">    1305 </span>            :                                                       tm-&gt;generation);
<span class="lineNum">    1306 </span><span class="lineCov">        208 :                         n++;</span>
<span class="lineNum">    1307 </span><span class="lineCov">        208 :                         break;</span>
<span class="lineNum">    1308 </span>            :                 case MOD_LOG_KEY_REPLACE:
<span class="lineNum">    1309 </span><span class="lineCov">         27 :                         BUG_ON(tm-&gt;slot &gt;= n);</span>
<span class="lineNum">    1310 </span><span class="lineCov">         27 :                         btrfs_set_node_key(eb, &amp;tm-&gt;key, tm-&gt;slot);</span>
<span class="lineNum">    1311 </span><span class="lineCov">         27 :                         btrfs_set_node_blockptr(eb, tm-&gt;slot, tm-&gt;blockptr);</span>
<span class="lineNum">    1312 </span><span class="lineCov">         27 :                         btrfs_set_node_ptr_generation(eb, tm-&gt;slot,</span>
<span class="lineNum">    1313 </span>            :                                                       tm-&gt;generation);
<span class="lineNum">    1314 </span>            :                         break;
<span class="lineNum">    1315 </span>            :                 case MOD_LOG_KEY_ADD:
<span class="lineNum">    1316 </span>            :                         /* if a move operation is needed it's in the log */
<span class="lineNum">    1317 </span><span class="lineCov">          3 :                         n--;</span>
<span class="lineNum">    1318 </span><span class="lineCov">          3 :                         break;</span>
<span class="lineNum">    1319 </span>            :                 case MOD_LOG_MOVE_KEYS:
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :                         o_dst = btrfs_node_key_ptr_offset(tm-&gt;slot);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :                         o_src = btrfs_node_key_ptr_offset(tm-&gt;move.dst_slot);</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :                         memmove_extent_buffer(eb, o_dst, o_src,</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :                                               tm-&gt;move.nr_items * p_size);</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1325 </span>            :                 case MOD_LOG_ROOT_REPLACE:
<span class="lineNum">    1326 </span>            :                         /*
<span class="lineNum">    1327 </span>            :                          * this operation is special. for roots, this must be
<span class="lineNum">    1328 </span>            :                          * handled explicitly before rewinding.
<span class="lineNum">    1329 </span>            :                          * for non-roots, this operation may exist if the node
<span class="lineNum">    1330 </span>            :                          * was a root: root A -&gt; child B; then A gets empty and
<span class="lineNum">    1331 </span>            :                          * B is promoted to the new root. in the mod log, we'll
<span class="lineNum">    1332 </span>            :                          * have a root-replace operation for B, a tree block
<span class="lineNum">    1333 </span>            :                          * that is no root. we simply ignore that operation.
<span class="lineNum">    1334 </span>            :                          */
<span class="lineNum">    1335 </span>            :                         break;
<span class="lineNum">    1336 </span>            :                 }
<span class="lineNum">    1337 </span><span class="lineCov">        238 :                 next = rb_next(&amp;tm-&gt;node);</span>
<span class="lineNum">    1338 </span><span class="lineCov">        238 :                 if (!next)</span>
<span class="lineNum">    1339 </span>            :                         break;
<span class="lineNum">    1340 </span>            :                 tm = container_of(next, struct tree_mod_elem, node);
<span class="lineNum">    1341 </span><span class="lineCov">        217 :                 if (tm-&gt;index != first_tm-&gt;index)</span>
<span class="lineNum">    1342 </span>            :                         break;
<span class="lineNum">    1343 </span>            :         }
<span class="lineNum">    1344 </span>            :         tree_mod_log_read_unlock(fs_info);
<span class="lineNum">    1345 </span>            :         btrfs_set_header_nritems(eb, n);
<span class="lineNum">    1346 </span><span class="lineCov">         21 : }</span>
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span>            : /*
<span class="lineNum">    1349 </span>            :  * Called with eb read locked. If the buffer cannot be rewinded, the same buffer
<span class="lineNum">    1350 </span>            :  * is returned. If rewind operations happen, a fresh buffer is returned. The
<span class="lineNum">    1351 </span>            :  * returned buffer is always read-locked. If the returned buffer is not the
<span class="lineNum">    1352 </span>            :  * input buffer, the lock on the input buffer is released and the input buffer
<span class="lineNum">    1353 </span>            :  * is freed (its refcount is decremented).
<span class="lineNum">    1354 </span>            :  */
<span class="lineNum">    1355 </span>            : static struct extent_buffer *
<span class="lineNum">    1356 </span><span class="lineCov">       3188 : tree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct btrfs_path *path,</span>
<span class="lineNum">    1357 </span><span class="lineCov">       3188 :                     struct extent_buffer *eb, u64 time_seq)</span>
<span class="lineNum">    1358 </span>            : {
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :         struct extent_buffer *eb_rewin;</span>
<span class="lineNum">    1360 </span>            :         struct tree_mod_elem *tm;
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span><span class="lineCov">       3188 :         if (!time_seq)</span>
<span class="lineNum">    1363 </span>            :                 return eb;
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span><span class="lineCov">       3188 :         if (btrfs_header_level(eb) == 0)</span>
<span class="lineNum">    1366 </span>            :                 return eb;
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span><span class="lineCov">       1269 :         tm = tree_mod_log_search(fs_info, eb-&gt;start, time_seq);</span>
<span class="lineNum">    1369 </span><span class="lineCov">       1269 :         if (!tm)</span>
<span class="lineNum">    1370 </span>            :                 return eb;
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :         btrfs_set_path_blocking(path);</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :         btrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);</span>
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :         if (tm-&gt;op == MOD_LOG_KEY_REMOVE_WHILE_FREEING) {</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :                 BUG_ON(tm-&gt;slot != 0);</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :                 eb_rewin = alloc_dummy_extent_buffer(eb-&gt;start,</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :                                                 fs_info-&gt;tree_root-&gt;nodesize);</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :                 if (!eb_rewin) {</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :                         btrfs_tree_read_unlock_blocking(eb);</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :                         free_extent_buffer(eb);</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">    1383 </span>            :                 }
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :                 btrfs_set_header_bytenr(eb_rewin, eb-&gt;start);</span>
<span class="lineNum">    1385 </span>            :                 btrfs_set_header_backref_rev(eb_rewin,
<span class="lineNum">    1386 </span>            :                                              btrfs_header_backref_rev(eb));
<span class="lineNum">    1387 </span>            :                 btrfs_set_header_owner(eb_rewin, btrfs_header_owner(eb));
<span class="lineNum">    1388 </span>            :                 btrfs_set_header_level(eb_rewin, btrfs_header_level(eb));
<span class="lineNum">    1389 </span>            :         } else {
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :                 eb_rewin = btrfs_clone_extent_buffer(eb);</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :                 if (!eb_rewin) {</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :                         btrfs_tree_read_unlock_blocking(eb);</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :                         free_extent_buffer(eb);</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">    1395 </span>            :                 }
<span class="lineNum">    1396 </span>            :         }
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :         btrfs_clear_path_blocking(path, NULL, BTRFS_READ_LOCK);</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :         btrfs_tree_read_unlock_blocking(eb);</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         free_extent_buffer(eb);</span>
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            :         extent_buffer_get(eb_rewin);
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :         btrfs_tree_read_lock(eb_rewin);</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :         __tree_mod_log_rewind(fs_info, eb_rewin, time_seq, tm);</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :         WARN_ON(btrfs_header_nritems(eb_rewin) &gt;</span>
<span class="lineNum">    1406 </span>            :                 BTRFS_NODEPTRS_PER_BLOCK(fs_info-&gt;tree_root));
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :         return eb_rewin;</span>
<span class="lineNum">    1409 </span>            : }
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            : /*
<span class="lineNum">    1412 </span>            :  * get_old_root() rewinds the state of @root's root node to the given @time_seq
<span class="lineNum">    1413 </span>            :  * value. If there are no changes, the current root-&gt;root_node is returned. If
<span class="lineNum">    1414 </span>            :  * anything changed in between, there's a fresh buffer allocated on which the
<span class="lineNum">    1415 </span>            :  * rewind operations are done. In any case, the returned buffer is read locked.
<span class="lineNum">    1416 </span>            :  * Returns NULL on error (with no locks held).
<span class="lineNum">    1417 </span>            :  */
<span class="lineNum">    1418 </span>            : static inline struct extent_buffer *
<span class="lineNum">    1419 </span><span class="lineCov">       7947 : get_old_root(struct btrfs_root *root, u64 time_seq)</span>
<span class="lineNum">    1420 </span>            : {
<span class="lineNum">    1421 </span>            :         struct tree_mod_elem *tm;
<span class="lineNum">    1422 </span><span class="lineCov">         25 :         struct extent_buffer *eb = NULL;</span>
<span class="lineNum">    1423 </span><span class="lineCov">       7948 :         struct extent_buffer *eb_root;</span>
<span class="lineNum">    1424 </span>            :         struct extent_buffer *old;
<span class="lineNum">    1425 </span>            :         struct tree_mod_root *old_root = NULL;
<span class="lineNum">    1426 </span>            :         u64 old_generation = 0;
<span class="lineNum">    1427 </span>            :         u64 logical;
<span class="lineNum">    1428 </span>            :         u32 blocksize;
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span><span class="lineCov">       7947 :         eb_root = btrfs_read_lock_root_node(root);</span>
<span class="lineNum">    1431 </span><span class="lineCov">      15894 :         tm = __tree_mod_log_oldest_root(root-&gt;fs_info, eb_root, time_seq);</span>
<span class="lineNum">    1432 </span><span class="lineCov">       7947 :         if (!tm)</span>
<span class="lineNum">    1433 </span>            :                 return eb_root;
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span><span class="lineCov">         21 :         if (tm-&gt;op == MOD_LOG_ROOT_REPLACE) {</span>
<span class="lineNum">    1436 </span><span class="lineCov">          1 :                 old_root = &amp;tm-&gt;old_root;</span>
<span class="lineNum">    1437 </span><span class="lineCov">          1 :                 old_generation = tm-&gt;generation;</span>
<span class="lineNum">    1438 </span><span class="lineCov">          1 :                 logical = old_root-&gt;logical;</span>
<span class="lineNum">    1439 </span>            :         } else {
<span class="lineNum">    1440 </span><span class="lineCov">         20 :                 logical = eb_root-&gt;start;</span>
<span class="lineNum">    1441 </span>            :         }
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span><span class="lineCov">         21 :         tm = tree_mod_log_search(root-&gt;fs_info, logical, time_seq);</span>
<span class="lineNum">    1444 </span><span class="lineCov">         21 :         if (old_root &amp;&amp; tm &amp;&amp; tm-&gt;op != MOD_LOG_KEY_REMOVE_WHILE_FREEING) {</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :                 btrfs_tree_read_unlock(eb_root);</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :                 free_extent_buffer(eb_root);</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :                 blocksize = btrfs_level_size(root, old_root-&gt;level);</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :                 old = read_tree_block(root, logical, blocksize, 0);</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                 if (WARN_ON(!old || !extent_buffer_uptodate(old))) {</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :                         free_extent_buffer(old);</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :                         btrfs_warn(root-&gt;fs_info,</span>
<span class="lineNum">    1452 </span>            :                                 &quot;failed to read tree block %llu from get_old_root&quot;, logical);
<span class="lineNum">    1453 </span>            :                 } else {
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :                         eb = btrfs_clone_extent_buffer(old);</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :                         free_extent_buffer(old);</span>
<span class="lineNum">    1456 </span>            :                 }
<span class="lineNum">    1457 </span><span class="lineCov">         21 :         } else if (old_root) {</span>
<span class="lineNum">    1458 </span><span class="lineCov">          1 :                 btrfs_tree_read_unlock(eb_root);</span>
<span class="lineNum">    1459 </span><span class="lineCov">          1 :                 free_extent_buffer(eb_root);</span>
<span class="lineNum">    1460 </span><span class="lineCov">          1 :                 eb = alloc_dummy_extent_buffer(logical, root-&gt;nodesize);</span>
<span class="lineNum">    1461 </span>            :         } else {
<span class="lineNum">    1462 </span><span class="lineCov">         20 :                 btrfs_set_lock_blocking_rw(eb_root, BTRFS_READ_LOCK);</span>
<span class="lineNum">    1463 </span><span class="lineCov">         20 :                 eb = btrfs_clone_extent_buffer(eb_root);</span>
<span class="lineNum">    1464 </span><span class="lineCov">         20 :                 btrfs_tree_read_unlock_blocking(eb_root);</span>
<span class="lineNum">    1465 </span><span class="lineCov">         20 :                 free_extent_buffer(eb_root);</span>
<span class="lineNum">    1466 </span>            :         }
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span><span class="lineCov">         21 :         if (!eb)</span>
<span class="lineNum">    1469 </span>            :                 return NULL;
<span class="lineNum">    1470 </span>            :         extent_buffer_get(eb);
<span class="lineNum">    1471 </span><span class="lineCov">         21 :         btrfs_tree_read_lock(eb);</span>
<span class="lineNum">    1472 </span><span class="lineCov">         21 :         if (old_root) {</span>
<span class="lineNum">    1473 </span><span class="lineCov">          1 :                 btrfs_set_header_bytenr(eb, eb-&gt;start);</span>
<span class="lineNum">    1474 </span>            :                 btrfs_set_header_backref_rev(eb, BTRFS_MIXED_BACKREF_REV);
<span class="lineNum">    1475 </span>            :                 btrfs_set_header_owner(eb, btrfs_header_owner(eb_root));
<span class="lineNum">    1476 </span><span class="lineCov">          1 :                 btrfs_set_header_level(eb, old_root-&gt;level);</span>
<span class="lineNum">    1477 </span>            :                 btrfs_set_header_generation(eb, old_generation);
<span class="lineNum">    1478 </span>            :         }
<span class="lineNum">    1479 </span><span class="lineCov">         21 :         if (tm)</span>
<span class="lineNum">    1480 </span><span class="lineCov">         21 :                 __tree_mod_log_rewind(root-&gt;fs_info, eb, time_seq, tm);</span>
<span class="lineNum">    1481 </span>            :         else
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :                 WARN_ON(btrfs_header_level(eb) != 0);</span>
<span class="lineNum">    1483 </span><span class="lineCov">         21 :         WARN_ON(btrfs_header_nritems(eb) &gt; BTRFS_NODEPTRS_PER_BLOCK(root));</span>
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineCov">         21 :         return eb;</span>
<a name="1486"><span class="lineNum">    1486 </span>            : }</a>
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span><span class="lineCov">      12728 : int btrfs_old_root_level(struct btrfs_root *root, u64 time_seq)</span>
<span class="lineNum">    1489 </span>            : {
<span class="lineNum">    1490 </span>            :         struct tree_mod_elem *tm;
<span class="lineNum">    1491 </span>            :         int level;
<span class="lineNum">    1492 </span><span class="lineCov">      38183 :         struct extent_buffer *eb_root = btrfs_root_node(root);</span>
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span><span class="lineCov">      25456 :         tm = __tree_mod_log_oldest_root(root-&gt;fs_info, eb_root, time_seq);</span>
<span class="lineNum">    1495 </span><span class="lineCov">      12728 :         if (tm &amp;&amp; tm-&gt;op == MOD_LOG_ROOT_REPLACE) {</span>
<span class="lineNum">    1496 </span><span class="lineCov">          1 :                 level = tm-&gt;old_root.level;</span>
<span class="lineNum">    1497 </span>            :         } else {
<span class="lineNum">    1498 </span><span class="lineCov">      12727 :                 level = btrfs_header_level(eb_root);</span>
<span class="lineNum">    1499 </span>            :         }
<span class="lineNum">    1500 </span><span class="lineCov">      12728 :         free_extent_buffer(eb_root);</span>
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span><span class="lineCov">      12728 :         return level;</span>
<a name="1503"><span class="lineNum">    1503 </span>            : }</a>
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span><span class="lineCov">    1600370 : static inline int should_cow_block(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    1506 </span>            :                                    struct btrfs_root *root,
<span class="lineNum">    1507 </span><span class="lineCov">    1600379 :                                    struct extent_buffer *buf)</span>
<span class="lineNum">    1508 </span>            : {
<span class="lineNum">    1509 </span>            : #ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
<span class="lineNum">    1510 </span>            :         if (unlikely(test_bit(BTRFS_ROOT_DUMMY_ROOT, &amp;root-&gt;state)))
<span class="lineNum">    1511 </span>            :                 return 0;
<span class="lineNum">    1512 </span>            : #endif
<span class="lineNum">    1513 </span>            :         /* ensure we can see the force_cow */
<span class="lineNum">    1514 </span><span class="lineCov">    1600370 :         smp_rmb();</span>
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            :         /*
<span class="lineNum">    1517 </span>            :          * We do not need to cow a block if
<span class="lineNum">    1518 </span>            :          * 1) this block is not created or changed in this transaction;
<span class="lineNum">    1519 </span>            :          * 2) this block does not belong to TREE_RELOC tree;
<span class="lineNum">    1520 </span>            :          * 3) the root is not forced COW.
<span class="lineNum">    1521 </span>            :          *
<span class="lineNum">    1522 </span>            :          * What is forced COW:
<span class="lineNum">    1523 </span>            :          *    when we create snapshot during commiting the transaction,
<span class="lineNum">    1524 </span>            :          *    after we've finished coping src root, we must COW the shared
<span class="lineNum">    1525 </span>            :          *    block to ensure the metadata consistency.
<span class="lineNum">    1526 </span>            :          */
<span class="lineNum">    1527 </span><span class="lineCov">    3119011 :         if (btrfs_header_generation(buf) == trans-&gt;transid &amp;&amp;</span>
<span class="lineNum">    1528 </span><span class="lineCov">    1490830 :             !btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN) &amp;&amp;</span>
<span class="lineNum">    1529 </span><span class="lineCov">    2981638 :             !(root-&gt;root_key.objectid != BTRFS_TREE_RELOC_OBJECTID &amp;&amp;</span>
<span class="lineNum">    1530 </span><span class="lineCov">    1490838 :               btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)) &amp;&amp;</span>
<span class="lineNum">    1531 </span>            :             !test_bit(BTRFS_ROOT_FORCE_COW, &amp;root-&gt;state))
<span class="lineNum">    1532 </span>            :                 return 0;
<span class="lineNum">    1533 </span>            :         return 1;
<span class="lineNum">    1534 </span>            : }
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span>            : /*
<span class="lineNum">    1537 </span>            :  * cows a single block, see __btrfs_cow_block for the real work.
<span class="lineNum">    1538 </span>            :  * This version of it has extra checks so that a block isn't cow'd more than
<a name="1539"><span class="lineNum">    1539 </span>            :  * once per transaction, as long as it hasn't been written yet</a>
<span class="lineNum">    1540 </span>            :  */
<span class="lineNum">    1541 </span><span class="lineCov">      66091 : noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    1542 </span>            :                     struct btrfs_root *root, struct extent_buffer *buf,
<span class="lineNum">    1543 </span>            :                     struct extent_buffer *parent, int parent_slot,
<span class="lineNum">    1544 </span>            :                     struct extent_buffer **cow_ret)
<span class="lineNum">    1545 </span>            : {
<span class="lineNum">    1546 </span>            :         u64 search_start;
<span class="lineNum">    1547 </span>            :         int ret;
<span class="lineNum">    1548 </span>            : 
<span class="lineNum">    1549 </span><span class="lineCov">      66091 :         if (trans-&gt;transaction != root-&gt;fs_info-&gt;running_transaction)</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :                 WARN(1, KERN_CRIT &quot;trans %llu running %llu\n&quot;,</span>
<span class="lineNum">    1551 </span>            :                        trans-&gt;transid,
<span class="lineNum">    1552 </span>            :                        root-&gt;fs_info-&gt;running_transaction-&gt;transid);
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span><span class="lineCov">      66091 :         if (trans-&gt;transid != root-&gt;fs_info-&gt;generation)</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :                 WARN(1, KERN_CRIT &quot;trans %llu running %llu\n&quot;,</span>
<span class="lineNum">    1556 </span>            :                        trans-&gt;transid, root-&gt;fs_info-&gt;generation);
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span><span class="lineCov">      66091 :         if (!should_cow_block(trans, root, buf)) {</span>
<span class="lineNum">    1559 </span><span class="lineCov">      13805 :                 *cow_ret = buf;</span>
<span class="lineNum">    1560 </span><span class="lineCov">      13805 :                 return 0;</span>
<span class="lineNum">    1561 </span>            :         }
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineCov">      52286 :         search_start = buf-&gt;start &amp; ~((u64)(1024 * 1024 * 1024) - 1);</span>
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span><span class="lineCov">      52286 :         if (parent)</span>
<span class="lineNum">    1566 </span>            :                 btrfs_set_lock_blocking(parent);
<span class="lineNum">    1567 </span>            :         btrfs_set_lock_blocking(buf);
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span><span class="lineCov">      52285 :         ret = __btrfs_cow_block(trans, root, buf, parent,</span>
<span class="lineNum">    1570 </span>            :                                  parent_slot, cow_ret, search_start, 0);
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineCov">      52284 :         trace_btrfs_cow_block(root, buf, *cow_ret);</span>
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span><span class="lineCov">      52284 :         return ret;</span>
<span class="lineNum">    1575 </span>            : }
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span>            : /*
<span class="lineNum">    1578 </span>            :  * helper function for defrag to decide if two blocks pointed to by a
<span class="lineNum">    1579 </span>            :  * node are actually close by
<span class="lineNum">    1580 </span>            :  */
<a name="1581"><span class="lineNum">    1581 </span>            : static int close_blocks(u64 blocknr, u64 other, u32 blocksize)</a>
<span class="lineNum">    1582 </span>            : {
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :         if (blocknr &lt; other &amp;&amp; other - (blocknr + blocksize) &lt; 32768)</span>
<span class="lineNum">    1584 </span>            :                 return 1;
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :         if (blocknr &gt; other &amp;&amp; blocknr - (other + blocksize) &lt; 32768)</span>
<span class="lineNum">    1586 </span>            :                 return 1;
<span class="lineNum">    1587 </span>            :         return 0;
<span class="lineNum">    1588 </span>            : }
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span>            : /*
<span class="lineNum">    1591 </span>            :  * compare two keys in a memcmp fashion
<span class="lineNum">    1592 </span>            :  */
<span class="lineNum">    1593 </span>            : static int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)
<span class="lineNum">    1594 </span>            : {
<span class="lineNum">    1595 </span>            :         struct btrfs_key k1;
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span>            :         btrfs_disk_key_to_cpu(&amp;k1, disk);
<span class="lineNum">    1598 </span>            : 
<span class="lineNum">    1599 </span>            :         return btrfs_comp_cpu_keys(&amp;k1, k2);
<span class="lineNum">    1600 </span>            : }
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span>            : /*
<a name="1603"><span class="lineNum">    1603 </span>            :  * same as comp_keys only with two btrfs_key's</a>
<span class="lineNum">    1604 </span>            :  */
<a name="1605"><span class="lineNum">    1605 </span><span class="lineCov">     275675 : int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)</span></a>
<span class="lineNum">    1606 </span>            : {
<span class="lineNum">    1607 </span><span class="lineCov">   28437019 :         if (k1-&gt;objectid &gt; k2-&gt;objectid)</span>
<span class="lineNum">    1608 </span>            :                 return 1;
<span class="lineNum">    1609 </span><span class="lineCov">   20136305 :         if (k1-&gt;objectid &lt; k2-&gt;objectid)</span>
<span class="lineNum">    1610 </span>            :                 return -1;
<span class="lineNum">    1611 </span><span class="lineCov">   12375604 :         if (k1-&gt;type &gt; k2-&gt;type)</span>
<span class="lineNum">    1612 </span>            :                 return 1;
<span class="lineNum">    1613 </span><span class="lineCov">   11863499 :         if (k1-&gt;type &lt; k2-&gt;type)</span>
<span class="lineNum">    1614 </span>            :                 return -1;
<span class="lineNum">    1615 </span><span class="lineCov">   11495661 :         if (k1-&gt;offset &gt; k2-&gt;offset)</span>
<span class="lineNum">    1616 </span>            :                 return 1;
<span class="lineNum">    1617 </span><span class="lineCov">    7012757 :         if (k1-&gt;offset &lt; k2-&gt;offset)</span>
<span class="lineNum">    1618 </span>            :                 return -1;
<span class="lineNum">    1619 </span><span class="lineCov">       6644 :         return 0;</span>
<span class="lineNum">    1620 </span>            : }
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            : /*
<span class="lineNum">    1623 </span>            :  * this is used by the defrag code to go through all the
<span class="lineNum">    1624 </span>            :  * leaves pointed to by a node and reallocate them so that
<span class="lineNum">    1625 </span>            :  * disk order is close to key order
<span class="lineNum">    1626 </span>            :  */
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 : int btrfs_realloc_node(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :                        struct btrfs_root *root, struct extent_buffer *parent,</span>
<span class="lineNum">    1629 </span>            :                        int start_slot, u64 *last_ret,
<span class="lineNum">    1630 </span>            :                        struct btrfs_key *progress)
<span class="lineNum">    1631 </span>            : {
<span class="lineNum">    1632 </span>            :         struct extent_buffer *cur;
<span class="lineNum">    1633 </span>            :         u64 blocknr;
<span class="lineNum">    1634 </span>            :         u64 gen;
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :         u64 search_start = *last_ret;</span>
<span class="lineNum">    1636 </span>            :         u64 last_block = 0;
<span class="lineNum">    1637 </span>            :         u64 other;
<span class="lineNum">    1638 </span>            :         u32 parent_nritems;
<span class="lineNum">    1639 </span>            :         int end_slot;
<span class="lineNum">    1640 </span>            :         int i;
<span class="lineNum">    1641 </span>            :         int err = 0;
<span class="lineNum">    1642 </span>            :         int parent_level;
<span class="lineNum">    1643 </span>            :         int uptodate;
<span class="lineNum">    1644 </span>            :         u32 blocksize;
<span class="lineNum">    1645 </span>            :         int progress_passed = 0;
<span class="lineNum">    1646 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span>            :         parent_level = btrfs_header_level(parent);
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :         WARN_ON(trans-&gt;transaction != root-&gt;fs_info-&gt;running_transaction);</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :         WARN_ON(trans-&gt;transid != root-&gt;fs_info-&gt;generation);</span>
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            :         parent_nritems = btrfs_header_nritems(parent);
<span class="lineNum">    1654 </span>            :         blocksize = btrfs_level_size(root, parent_level - 1);
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :         end_slot = parent_nritems;</span>
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :         if (parent_nritems == 1)</span>
<span class="lineNum">    1658 </span>            :                 return 0;
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span>            :         btrfs_set_lock_blocking(parent);
<span class="lineNum">    1661 </span>            : 
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :         for (i = start_slot; i &lt; end_slot; i++) {</span>
<span class="lineNum">    1663 </span>            :                 int close = 1;
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :                 btrfs_node_key(parent, &amp;disk_key, i);</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :                 if (!progress_passed &amp;&amp; comp_keys(&amp;disk_key, progress) &lt; 0)</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span>            :                 progress_passed = 1;
<span class="lineNum">    1670 </span>            :                 blocknr = btrfs_node_blockptr(parent, i);
<span class="lineNum">    1671 </span>            :                 gen = btrfs_node_ptr_generation(parent, i);
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :                 if (last_block == 0)</span>
<span class="lineNum">    1673 </span>            :                         last_block = blocknr;
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :                 if (i &gt; 0) {</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :                         other = btrfs_node_blockptr(parent, i - 1);</span>
<span class="lineNum">    1677 </span>            :                         close = close_blocks(blocknr, other, blocksize);
<span class="lineNum">    1678 </span>            :                 }
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :                 if (!close &amp;&amp; i &lt; end_slot - 2) {</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :                         other = btrfs_node_blockptr(parent, i + 1);</span>
<span class="lineNum">    1681 </span>            :                         close = close_blocks(blocknr, other, blocksize);
<span class="lineNum">    1682 </span>            :                 }
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :                 if (close) {</span>
<span class="lineNum">    1684 </span>            :                         last_block = blocknr;
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1686 </span>            :                 }
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :                 cur = btrfs_find_tree_block(root, blocknr, blocksize);</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :                 if (cur)</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :                         uptodate = btrfs_buffer_uptodate(cur, gen, 0);</span>
<span class="lineNum">    1691 </span>            :                 else
<span class="lineNum">    1692 </span>            :                         uptodate = 0;
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :                 if (!cur || !uptodate) {</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :                         if (!cur) {</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :                                 cur = read_tree_block(root, blocknr,</span>
<span class="lineNum">    1696 </span>            :                                                          blocksize, gen);
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :                                 if (!cur || !extent_buffer_uptodate(cur)) {</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :                                         free_extent_buffer(cur);</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :                                         return -EIO;</span>
<span class="lineNum">    1700 </span>            :                                 }
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :                         } else if (!uptodate) {</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :                                 err = btrfs_read_buffer(cur, gen);</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :                                 if (err) {</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :                                         free_extent_buffer(cur);</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :                                         return err;</span>
<span class="lineNum">    1706 </span>            :                                 }
<span class="lineNum">    1707 </span>            :                         }
<span class="lineNum">    1708 </span>            :                 }
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :                 if (search_start == 0)</span>
<span class="lineNum">    1710 </span>            :                         search_start = last_block;
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :                 btrfs_tree_lock(cur);</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :                 btrfs_set_lock_blocking(cur);</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :                 err = __btrfs_cow_block(trans, root, cur, parent, i,</span>
<span class="lineNum">    1715 </span>            :                                         &amp;cur, search_start,
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :                                         min(16 * blocksize,</span>
<span class="lineNum">    1717 </span>            :                                             (end_slot - i) * blocksize));
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :                 if (err) {</span>
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :                         btrfs_tree_unlock(cur);</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :                         free_extent_buffer(cur);</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1722 </span>            :                 }
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :                 search_start = cur-&gt;start;</span>
<span class="lineNum">    1724 </span>            :                 last_block = cur-&gt;start;
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :                 *last_ret = search_start;</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :                 btrfs_tree_unlock(cur);</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :                 free_extent_buffer(cur);</span>
<span class="lineNum">    1728 </span>            :         }
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :         return err;</span>
<span class="lineNum">    1730 </span>            : }
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span>            : /*
<span class="lineNum">    1733 </span>            :  * The leaf data grows from end-to-front in the node.
<span class="lineNum">    1734 </span>            :  * this returns the address of the start of the last item,
<a name="1735"><span class="lineNum">    1735 </span>            :  * which is the stop of the leaf data stack</a>
<span class="lineNum">    1736 </span>            :  */
<span class="lineNum">    1737 </span><span class="lineCov">     524875 : static inline unsigned int leaf_data_end(struct btrfs_root *root,</span>
<span class="lineNum">    1738 </span><span class="lineCov">     524875 :                                          struct extent_buffer *leaf)</span>
<span class="lineNum">    1739 </span>            : {
<span class="lineNum">    1740 </span>            :         u32 nr = btrfs_header_nritems(leaf);
<span class="lineNum">    1741 </span><span class="lineCov">     524875 :         if (nr == 0)</span>
<span class="lineNum">    1742 </span><span class="lineCov">       1779 :                 return BTRFS_LEAF_DATA_SIZE(root);</span>
<span class="lineNum">    1743 </span><span class="lineCov">     523096 :         return btrfs_item_offset_nr(leaf, nr - 1);</span>
<span class="lineNum">    1744 </span>            : }
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            : /*
<span class="lineNum">    1748 </span>            :  * search for key in the extent_buffer.  The items start at offset p,
<span class="lineNum">    1749 </span>            :  * and they are item_size apart.  There are 'max' items in p.
<span class="lineNum">    1750 </span>            :  *
<span class="lineNum">    1751 </span>            :  * the slot in the array is returned via slot, and it points to
<span class="lineNum">    1752 </span>            :  * the place where you would insert key if it is not found in
<span class="lineNum">    1753 </span>            :  * the array.
<span class="lineNum">    1754 </span>            :  *
<span class="lineNum">    1755 </span>            :  * slot may point to max if the key is bigger than all of the keys
<span class="lineNum">    1756 </span>            :  */
<span class="lineNum">    1757 </span><span class="lineCov">    4978020 : static noinline int generic_bin_search(struct extent_buffer *eb,</span>
<span class="lineNum">    1758 </span>            :                                        unsigned long p,
<span class="lineNum">    1759 </span>            :                                        int item_size, struct btrfs_key *key,
<span class="lineNum">    1760 </span>            :                                        int max, int *slot)
<span class="lineNum">    1761 </span>            : {
<span class="lineNum">    1762 </span>            :         int low = 0;
<span class="lineNum">    1763 </span>            :         int high = max;
<span class="lineNum">    1764 </span>            :         int mid;
<span class="lineNum">    1765 </span>            :         int ret;
<span class="lineNum">    1766 </span>            :         struct btrfs_disk_key *tmp = NULL;
<span class="lineNum">    1767 </span>            :         struct btrfs_disk_key unaligned;
<span class="lineNum">    1768 </span>            :         unsigned long offset;
<span class="lineNum">    1769 </span><span class="lineCov">    4978020 :         char *kaddr = NULL;</span>
<span class="lineNum">    1770 </span><span class="lineCov">    4978020 :         unsigned long map_start = 0;</span>
<span class="lineNum">    1771 </span><span class="lineCov">    4978020 :         unsigned long map_len = 0;</span>
<span class="lineNum">    1772 </span>            :         int err;
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span><span class="lineCov">   37022947 :         while (low &lt; high) {</span>
<span class="lineNum">    1775 </span><span class="lineCov">   28139641 :                 mid = (low + high) / 2;</span>
<span class="lineNum">    1776 </span><span class="lineCov">   28139641 :                 offset = p + mid * item_size;</span>
<span class="lineNum">    1777 </span>            : 
<span class="lineNum">    1778 </span><span class="lineCov">   51123818 :                 if (!kaddr || offset &lt; map_start ||</span>
<span class="lineNum">    1779 </span><span class="lineCov">   22984177 :                     (offset + sizeof(struct btrfs_disk_key)) &gt;</span>
<span class="lineNum">    1780 </span><span class="lineCov">   22984177 :                     map_start + map_len) {</span>
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineCov">    5503721 :                         err = map_private_extent_buffer(eb, offset,</span>
<span class="lineNum">    1783 </span>            :                                                 sizeof(struct btrfs_disk_key),
<span class="lineNum">    1784 </span>            :                                                 &amp;kaddr, &amp;map_start, &amp;map_len);
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span><span class="lineCov">    5515117 :                         if (!err) {</span>
<span class="lineNum">    1787 </span><span class="lineCov">    5476843 :                                 tmp = (struct btrfs_disk_key *)(kaddr + offset -</span>
<span class="lineNum">    1788 </span>            :                                                         map_start);
<span class="lineNum">    1789 </span>            :                         } else {
<span class="lineNum">    1790 </span><span class="lineCov">      38274 :                                 read_extent_buffer(eb, &amp;unaligned,</span>
<span class="lineNum">    1791 </span>            :                                                    offset, sizeof(unaligned));
<span class="lineNum">    1792 </span>            :                                 tmp = &amp;unaligned;
<span class="lineNum">    1793 </span>            :                         }
<span class="lineNum">    1794 </span>            : 
<span class="lineNum">    1795 </span>            :                 } else {
<span class="lineNum">    1796 </span><span class="lineCov">   22635920 :                         tmp = (struct btrfs_disk_key *)(kaddr + offset -</span>
<span class="lineNum">    1797 </span>            :                                                         map_start);
<span class="lineNum">    1798 </span>            :                 }
<span class="lineNum">    1799 </span>            :                 ret = comp_keys(tmp, key);
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span><span class="lineCov">   28145279 :                 if (ret &lt; 0)</span>
<span class="lineNum">    1802 </span><span class="lineCov">   13819832 :                         low = mid + 1;</span>
<span class="lineNum">    1803 </span><span class="lineCov">   14325447 :                 else if (ret &gt; 0)</span>
<span class="lineNum">    1804 </span>            :                         high = mid;
<span class="lineNum">    1805 </span>            :                 else {
<span class="lineNum">    1806 </span><span class="lineCov">    1078372 :                         *slot = mid;</span>
<span class="lineNum">    1807 </span><span class="lineCov">    1078372 :                         return 0;</span>
<span class="lineNum">    1808 </span>            :                 }
<span class="lineNum">    1809 </span>            :         }
<span class="lineNum">    1810 </span><span class="lineCov">    3905286 :         *slot = low;</span>
<span class="lineNum">    1811 </span><span class="lineCov">    3905286 :         return 1;</span>
<span class="lineNum">    1812 </span>            : }
<span class="lineNum">    1813 </span>            : 
<span class="lineNum">    1814 </span>            : /*
<span class="lineNum">    1815 </span>            :  * simple bin_search frontend that does the right thing for
<a name="1816"><span class="lineNum">    1816 </span>            :  * leaves vs nodes</a>
<span class="lineNum">    1817 </span>            :  */
<span class="lineNum">    1818 </span><span class="lineCov">    9970782 : static int bin_search(struct extent_buffer *eb, struct btrfs_key *key,</span>
<span class="lineNum">    1819 </span>            :                       int level, int *slot)
<span class="lineNum">    1820 </span>            : {
<span class="lineNum">    1821 </span><span class="lineCov">    4985391 :         if (level == 0)</span>
<span class="lineNum">    1822 </span><span class="lineCov">    2131536 :                 return generic_bin_search(eb,</span>
<span class="lineNum">    1823 </span>            :                                           offsetof(struct btrfs_leaf, items),
<span class="lineNum">    1824 </span>            :                                           sizeof(struct btrfs_item),
<span class="lineNum">    1825 </span>            :                                           key, btrfs_header_nritems(eb),
<span class="lineNum">    1826 </span>            :                                           slot);
<span class="lineNum">    1827 </span>            :         else
<span class="lineNum">    1828 </span><span class="lineCov">    2853855 :                 return generic_bin_search(eb,</span>
<span class="lineNum">    1829 </span>            :                                           offsetof(struct btrfs_node, ptrs),
<span class="lineNum">    1830 </span>            :                                           sizeof(struct btrfs_key_ptr),
<span class="lineNum">    1831 </span>            :                                           key, btrfs_header_nritems(eb),
<span class="lineNum">    1832 </span>            :                                           slot);
<a name="1833"><span class="lineNum">    1833 </span>            : }</a>
<span class="lineNum">    1834 </span>            : 
<span class="lineNum">    1835 </span><span class="lineCov">        247 : int btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,</span>
<span class="lineNum">    1836 </span>            :                      int level, int *slot)
<span class="lineNum">    1837 </span>            : {
<span class="lineNum">    1838 </span><span class="lineCov">        247 :         return bin_search(eb, key, level, slot);</span>
<span class="lineNum">    1839 </span>            : }
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            : static void root_add_used(struct btrfs_root *root, u32 size)
<a name="1842"><span class="lineNum">    1842 </span>            : {</a>
<span class="lineNum">    1843 </span>            :         spin_lock(&amp;root-&gt;accounting_lock);
<span class="lineNum">    1844 </span><span class="lineCov">       5411 :         btrfs_set_root_used(&amp;root-&gt;root_item,</span>
<span class="lineNum">    1845 </span>            :                             btrfs_root_used(&amp;root-&gt;root_item) + size);
<span class="lineNum">    1846 </span>            :         spin_unlock(&amp;root-&gt;accounting_lock);
<span class="lineNum">    1847 </span>            : }
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span>            : static void root_sub_used(struct btrfs_root *root, u32 size)
<a name="1850"><span class="lineNum">    1850 </span>            : {</a>
<span class="lineNum">    1851 </span>            :         spin_lock(&amp;root-&gt;accounting_lock);
<span class="lineNum">    1852 </span><span class="lineCov">       1403 :         btrfs_set_root_used(&amp;root-&gt;root_item,</span>
<span class="lineNum">    1853 </span>            :                             btrfs_root_used(&amp;root-&gt;root_item) - size);
<span class="lineNum">    1854 </span>            :         spin_unlock(&amp;root-&gt;accounting_lock);
<span class="lineNum">    1855 </span>            : }
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span>            : /* given a node and slot number, this reads the blocks it points to.  The
<span class="lineNum">    1858 </span>            :  * extent buffer is returned with a reference taken (but unlocked).
<a name="1859"><span class="lineNum">    1859 </span>            :  * NULL is returned on error.</a>
<span class="lineNum">    1860 </span>            :  */
<span class="lineNum">    1861 </span><span class="lineCov">      43874 : static noinline struct extent_buffer *read_node_slot(struct btrfs_root *root,</span>
<span class="lineNum">    1862 </span><span class="lineCov">      21977 :                                    struct extent_buffer *parent, int slot)</span>
<span class="lineNum">    1863 </span>            : {
<span class="lineNum">    1864 </span><span class="lineCov">      21977 :         int level = btrfs_header_level(parent);</span>
<span class="lineNum">    1865 </span>            :         struct extent_buffer *eb;
<span class="lineNum">    1866 </span>            : 
<span class="lineNum">    1867 </span><span class="lineCov">      21977 :         if (slot &lt; 0)</span>
<span class="lineNum">    1868 </span>            :                 return NULL;
<span class="lineNum">    1869 </span><span class="lineCov">      43826 :         if (slot &gt;= btrfs_header_nritems(parent))</span>
<span class="lineNum">    1870 </span>            :                 return NULL;
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span><span class="lineCov">      21897 :         BUG_ON(level == 0);</span>
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span><span class="lineCov">      21897 :         eb = read_tree_block(root, btrfs_node_blockptr(parent, slot),</span>
<span class="lineNum">    1875 </span>            :                              btrfs_level_size(root, level - 1),
<span class="lineNum">    1876 </span>            :                              btrfs_node_ptr_generation(parent, slot));
<span class="lineNum">    1877 </span><span class="lineCov">      21897 :         if (eb &amp;&amp; !extent_buffer_uptodate(eb)) {</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :                 free_extent_buffer(eb);</span>
<span class="lineNum">    1879 </span>            :                 eb = NULL;
<span class="lineNum">    1880 </span>            :         }
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span><span class="lineCov">      21897 :         return eb;</span>
<span class="lineNum">    1883 </span>            : }
<span class="lineNum">    1884 </span>            : 
<span class="lineNum">    1885 </span>            : /*
<span class="lineNum">    1886 </span>            :  * node level balancing, used to make sure nodes are in proper order for
<span class="lineNum">    1887 </span>            :  * item deletion.  We balance from the top down, so we have to make sure
<span class="lineNum">    1888 </span>            :  * that a deletion won't leave an node completely empty later on.
<span class="lineNum">    1889 </span>            :  */
<span class="lineNum">    1890 </span><span class="lineCov">     190233 : static noinline int balance_level(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    1891 </span><span class="lineCov">         32 :                          struct btrfs_root *root,</span>
<span class="lineNum">    1892 </span>            :                          struct btrfs_path *path, int level)
<span class="lineNum">    1893 </span>            : {
<span class="lineNum">    1894 </span><span class="lineCov">     190233 :         struct extent_buffer *right = NULL;</span>
<span class="lineNum">    1895 </span><span class="lineCov">     380487 :         struct extent_buffer *mid;</span>
<span class="lineNum">    1896 </span><span class="lineCov">     190233 :         struct extent_buffer *left = NULL;</span>
<span class="lineNum">    1897 </span>            :         struct extent_buffer *parent = NULL;
<span class="lineNum">    1898 </span>            :         int ret = 0;
<span class="lineNum">    1899 </span>            :         int wret;
<span class="lineNum">    1900 </span>            :         int pslot;
<span class="lineNum">    1901 </span><span class="lineCov">     190233 :         int orig_slot = path-&gt;slots[level];</span>
<span class="lineNum">    1902 </span>            :         u64 orig_ptr;
<span class="lineNum">    1903 </span>            : 
<span class="lineNum">    1904 </span><span class="lineCov">     190233 :         if (level == 0)</span>
<span class="lineNum">    1905 </span>            :                 return 0;
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span><span class="lineCov">     190233 :         mid = path-&gt;nodes[level];</span>
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span><span class="lineCov">     190233 :         WARN_ON(path-&gt;locks[level] != BTRFS_WRITE_LOCK &amp;&amp;</span>
<span class="lineNum">    1910 </span>            :                 path-&gt;locks[level] != BTRFS_WRITE_LOCK_BLOCKING);
<span class="lineNum">    1911 </span><span class="lineCov">     190233 :         WARN_ON(btrfs_header_generation(mid) != trans-&gt;transid);</span>
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span>            :         orig_ptr = btrfs_node_blockptr(mid, orig_slot);
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span><span class="lineCov">     190232 :         if (level &lt; BTRFS_MAX_LEVEL - 1) {</span>
<span class="lineNum">    1916 </span><span class="lineCov">     190233 :                 parent = path-&gt;nodes[level + 1];</span>
<span class="lineNum">    1917 </span><span class="lineCov">     190233 :                 pslot = path-&gt;slots[level + 1];</span>
<span class="lineNum">    1918 </span>            :         }
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span>            :         /*
<span class="lineNum">    1921 </span>            :          * deal with the case where there is only one pointer in the root
<span class="lineNum">    1922 </span>            :          * by promoting the node below to a root
<span class="lineNum">    1923 </span>            :          */
<span class="lineNum">    1924 </span><span class="lineCov">     190232 :         if (!parent) {</span>
<span class="lineNum">    1925 </span>            :                 struct extent_buffer *child;
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span><span class="lineCov">     178923 :                 if (btrfs_header_nritems(mid) != 1)</span>
<span class="lineNum">    1928 </span><span class="lineCov">     178923 :                         return 0;</span>
<span class="lineNum">    1929 </span>            : 
<span class="lineNum">    1930 </span>            :                 /* promote the child to a root */
<span class="lineNum">    1931 </span><span class="lineCov">         32 :                 child = read_node_slot(root, mid, 0);</span>
<span class="lineNum">    1932 </span><span class="lineCov">         32 :                 if (!child) {</span>
<span class="lineNum">    1933 </span>            :                         ret = -EROFS;
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                         btrfs_std_error(root-&gt;fs_info, ret);</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :                         goto enospc;</span>
<span class="lineNum">    1936 </span>            :                 }
<span class="lineNum">    1937 </span>            : 
<span class="lineNum">    1938 </span><span class="lineCov">         32 :                 btrfs_tree_lock(child);</span>
<span class="lineNum">    1939 </span><span class="lineCov">         32 :                 btrfs_set_lock_blocking(child);</span>
<span class="lineNum">    1940 </span><span class="lineCov">         32 :                 ret = btrfs_cow_block(trans, root, child, mid, 0, &amp;child);</span>
<span class="lineNum">    1941 </span><span class="lineCov">         32 :                 if (ret) {</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :                         btrfs_tree_unlock(child);</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :                         free_extent_buffer(child);</span>
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :                         goto enospc;</span>
<span class="lineNum">    1945 </span>            :                 }
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span><span class="lineCov">         64 :                 tree_mod_log_set_root_pointer(root, child, 1);</span>
<span class="lineNum">    1948 </span><span class="lineCov">         32 :                 rcu_assign_pointer(root-&gt;node, child);</span>
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span><span class="lineCov">         32 :                 add_root_to_dirty_list(root);</span>
<span class="lineNum">    1951 </span><span class="lineCov">         32 :                 btrfs_tree_unlock(child);</span>
<span class="lineNum">    1952 </span>            : 
<span class="lineNum">    1953 </span><span class="lineCov">         32 :                 path-&gt;locks[level] = 0;</span>
<span class="lineNum">    1954 </span><span class="lineCov">         32 :                 path-&gt;nodes[level] = NULL;</span>
<span class="lineNum">    1955 </span><span class="lineCov">         32 :                 clean_tree_block(trans, root, mid);</span>
<span class="lineNum">    1956 </span><span class="lineCov">         32 :                 btrfs_tree_unlock(mid);</span>
<span class="lineNum">    1957 </span>            :                 /* once for the path */
<span class="lineNum">    1958 </span><span class="lineCov">         32 :                 free_extent_buffer(mid);</span>
<span class="lineNum">    1959 </span>            : 
<span class="lineNum">    1960 </span><span class="lineCov">         32 :                 root_sub_used(root, mid-&gt;len);</span>
<span class="lineNum">    1961 </span><span class="lineCov">         32 :                 btrfs_free_tree_block(trans, root, mid, 0, 1);</span>
<span class="lineNum">    1962 </span>            :                 /* once for the root ptr */
<span class="lineNum">    1963 </span><span class="lineCov">         32 :                 free_extent_buffer_stale(mid);</span>
<span class="lineNum">    1964 </span><span class="lineCov">         32 :                 return 0;</span>
<span class="lineNum">    1965 </span>            :         }
<span class="lineNum">    1966 </span><span class="lineCov">      22618 :         if (btrfs_header_nritems(mid) &gt;</span>
<span class="lineNum">    1967 </span><span class="lineCov">      11309 :             BTRFS_NODEPTRS_PER_BLOCK(root) / 4)</span>
<span class="lineNum">    1968 </span>            :                 return 0;
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span><span class="lineCov">         11 :         left = read_node_slot(root, parent, pslot - 1);</span>
<span class="lineNum">    1971 </span><span class="lineCov">         27 :         if (left) {</span>
<span class="lineNum">    1972 </span><span class="lineCov">          8 :                 btrfs_tree_lock(left);</span>
<span class="lineNum">    1973 </span><span class="lineCov">          8 :                 btrfs_set_lock_blocking(left);</span>
<span class="lineNum">    1974 </span><span class="lineCov">          8 :                 wret = btrfs_cow_block(trans, root, left,</span>
<span class="lineNum">    1975 </span>            :                                        parent, pslot - 1, &amp;left);
<span class="lineNum">    1976 </span><span class="lineCov">          8 :                 if (wret) {</span>
<span class="lineNum">    1977 </span>            :                         ret = wret;
<span class="lineNum">    1978 </span>            :                         goto enospc;
<span class="lineNum">    1979 </span>            :                 }
<span class="lineNum">    1980 </span>            :         }
<span class="lineNum">    1981 </span><span class="lineCov">         11 :         right = read_node_slot(root, parent, pslot + 1);</span>
<span class="lineNum">    1982 </span><span class="lineCov">         20 :         if (right) {</span>
<span class="lineNum">    1983 </span><span class="lineCov">          9 :                 btrfs_tree_lock(right);</span>
<span class="lineNum">    1984 </span><span class="lineCov">          9 :                 btrfs_set_lock_blocking(right);</span>
<span class="lineNum">    1985 </span><span class="lineCov">          9 :                 wret = btrfs_cow_block(trans, root, right,</span>
<span class="lineNum">    1986 </span>            :                                        parent, pslot + 1, &amp;right);
<span class="lineNum">    1987 </span><span class="lineCov">          9 :                 if (wret) {</span>
<span class="lineNum">    1988 </span>            :                         ret = wret;
<span class="lineNum">    1989 </span>            :                         goto enospc;
<span class="lineNum">    1990 </span>            :                 }
<span class="lineNum">    1991 </span>            :         }
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span>            :         /* first, try to make some room in the middle buffer */
<span class="lineNum">    1994 </span><span class="lineCov">         11 :         if (left) {</span>
<span class="lineNum">    1995 </span><span class="lineCov">          8 :                 orig_slot += btrfs_header_nritems(left);</span>
<span class="lineNum">    1996 </span><span class="lineCov">          8 :                 wret = push_node_left(trans, root, left, mid, 1);</span>
<span class="lineNum">    1997 </span><span class="lineCov">          8 :                 if (wret &lt; 0)</span>
<span class="lineNum">    1998 </span>            :                         ret = wret;
<span class="lineNum">    1999 </span>            :         }
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span>            :         /*
<span class="lineNum">    2002 </span>            :          * then try to empty the right most buffer into the middle
<span class="lineNum">    2003 </span>            :          */
<span class="lineNum">    2004 </span><span class="lineCov">         11 :         if (right) {</span>
<span class="lineNum">    2005 </span><span class="lineCov">          9 :                 wret = push_node_left(trans, root, mid, right, 1);</span>
<span class="lineNum">    2006 </span><span class="lineCov">          9 :                 if (wret &lt; 0 &amp;&amp; wret != -ENOSPC)</span>
<span class="lineNum">    2007 </span>            :                         ret = wret;
<span class="lineNum">    2008 </span><span class="lineCov">         18 :                 if (btrfs_header_nritems(right) == 0) {</span>
<span class="lineNum">    2009 </span><span class="lineCov">          9 :                         clean_tree_block(trans, root, right);</span>
<span class="lineNum">    2010 </span><span class="lineCov">          9 :                         btrfs_tree_unlock(right);</span>
<span class="lineNum">    2011 </span><span class="lineCov">          9 :                         del_ptr(root, path, level + 1, pslot + 1);</span>
<span class="lineNum">    2012 </span><span class="lineCov">          9 :                         root_sub_used(root, right-&gt;len);</span>
<span class="lineNum">    2013 </span><span class="lineCov">          9 :                         btrfs_free_tree_block(trans, root, right, 0, 1);</span>
<span class="lineNum">    2014 </span><span class="lineCov">          9 :                         free_extent_buffer_stale(right);</span>
<span class="lineNum">    2015 </span><span class="lineCov">          9 :                         right = NULL;</span>
<span class="lineNum">    2016 </span>            :                 } else {
<span class="lineNum">    2017 </span>            :                         struct btrfs_disk_key right_key;
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :                         btrfs_node_key(right, &amp;right_key, 0);</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :                         tree_mod_log_set_node_key(root-&gt;fs_info, parent,</span>
<span class="lineNum">    2020 </span>            :                                                   pslot + 1, 0);
<span class="lineNum">    2021 </span>            :                         btrfs_set_node_key(parent, &amp;right_key, pslot + 1);
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :                         btrfs_mark_buffer_dirty(parent);</span>
<span class="lineNum">    2023 </span>            :                 }
<span class="lineNum">    2024 </span>            :         }
<span class="lineNum">    2025 </span><span class="lineCov">         11 :         if (btrfs_header_nritems(mid) == 1) {</span>
<span class="lineNum">    2026 </span>            :                 /*
<span class="lineNum">    2027 </span>            :                  * we're not allowed to leave a node with one item in the
<span class="lineNum">    2028 </span>            :                  * tree during a delete.  A deletion from lower in the tree
<span class="lineNum">    2029 </span>            :                  * could try to delete the only pointer in this node.
<span class="lineNum">    2030 </span>            :                  * So, pull some keys from the left.
<span class="lineNum">    2031 </span>            :                  * There has to be a left pointer at this point because
<span class="lineNum">    2032 </span>            :                  * otherwise we would have pulled some pointers from the
<span class="lineNum">    2033 </span>            :                  * right
<span class="lineNum">    2034 </span>            :                  */
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :                 if (!left) {</span>
<span class="lineNum">    2036 </span>            :                         ret = -EROFS;
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :                         btrfs_std_error(root-&gt;fs_info, ret);</span>
<span class="lineNum">    2038 </span>            :                         goto enospc;
<span class="lineNum">    2039 </span>            :                 }
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :                 wret = balance_node_right(trans, root, mid, left);</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :                 if (wret &lt; 0) {</span>
<span class="lineNum">    2042 </span>            :                         ret = wret;
<span class="lineNum">    2043 </span>            :                         goto enospc;
<span class="lineNum">    2044 </span>            :                 }
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :                 if (wret == 1) {</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :                         wret = push_node_left(trans, root, left, mid, 1);</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :                         if (wret &lt; 0)</span>
<span class="lineNum">    2048 </span>            :                                 ret = wret;
<span class="lineNum">    2049 </span>            :                 }
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :                 BUG_ON(wret == 1);</span>
<span class="lineNum">    2051 </span>            :         }
<span class="lineNum">    2052 </span><span class="lineCov">         11 :         if (btrfs_header_nritems(mid) == 0) {</span>
<span class="lineNum">    2053 </span><span class="lineCov">          2 :                 clean_tree_block(trans, root, mid);</span>
<span class="lineNum">    2054 </span><span class="lineCov">          2 :                 btrfs_tree_unlock(mid);</span>
<span class="lineNum">    2055 </span><span class="lineCov">          2 :                 del_ptr(root, path, level + 1, pslot);</span>
<span class="lineNum">    2056 </span><span class="lineCov">          2 :                 root_sub_used(root, mid-&gt;len);</span>
<span class="lineNum">    2057 </span><span class="lineCov">          2 :                 btrfs_free_tree_block(trans, root, mid, 0, 1);</span>
<span class="lineNum">    2058 </span><span class="lineCov">          2 :                 free_extent_buffer_stale(mid);</span>
<span class="lineNum">    2059 </span>            :                 mid = NULL;
<span class="lineNum">    2060 </span>            :         } else {
<span class="lineNum">    2061 </span>            :                 /* update the parent key to reflect our changes */
<span class="lineNum">    2062 </span>            :                 struct btrfs_disk_key mid_key;
<span class="lineNum">    2063 </span><span class="lineCov">          9 :                 btrfs_node_key(mid, &amp;mid_key, 0);</span>
<span class="lineNum">    2064 </span><span class="lineCov">          9 :                 tree_mod_log_set_node_key(root-&gt;fs_info, parent,</span>
<span class="lineNum">    2065 </span>            :                                           pslot, 0);
<span class="lineNum">    2066 </span>            :                 btrfs_set_node_key(parent, &amp;mid_key, pslot);
<span class="lineNum">    2067 </span><span class="lineCov">          9 :                 btrfs_mark_buffer_dirty(parent);</span>
<span class="lineNum">    2068 </span>            :         }
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span>            :         /* update the path */
<span class="lineNum">    2071 </span><span class="lineCov">         11 :         if (left) {</span>
<span class="lineNum">    2072 </span><span class="lineCov">          8 :                 if (btrfs_header_nritems(left) &gt; orig_slot) {</span>
<span class="lineNum">    2073 </span>            :                         extent_buffer_get(left);
<span class="lineNum">    2074 </span>            :                         /* left was locked after cow */
<span class="lineNum">    2075 </span><span class="lineCov">          8 :                         path-&gt;nodes[level] = left;</span>
<span class="lineNum">    2076 </span><span class="lineCov">          8 :                         path-&gt;slots[level + 1] -= 1;</span>
<span class="lineNum">    2077 </span><span class="lineCov">          8 :                         path-&gt;slots[level] = orig_slot;</span>
<span class="lineNum">    2078 </span><span class="lineCov">          8 :                         if (mid) {</span>
<span class="lineNum">    2079 </span><span class="lineCov">          6 :                                 btrfs_tree_unlock(mid);</span>
<span class="lineNum">    2080 </span><span class="lineCov">          6 :                                 free_extent_buffer(mid);</span>
<span class="lineNum">    2081 </span>            :                         }
<span class="lineNum">    2082 </span>            :                 } else {
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :                         orig_slot -= btrfs_header_nritems(left);</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :                         path-&gt;slots[level] = orig_slot;</span>
<span class="lineNum">    2085 </span>            :                 }
<span class="lineNum">    2086 </span>            :         }
<span class="lineNum">    2087 </span>            :         /* double check we haven't messed things up */
<span class="lineNum">    2088 </span><span class="lineCov">         11 :         if (orig_ptr !=</span>
<span class="lineNum">    2089 </span><span class="lineCov">         11 :             btrfs_node_blockptr(path-&gt;nodes[level], path-&gt;slots[level]))</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">    2091 </span>            : enospc:
<span class="lineNum">    2092 </span><span class="lineCov">         11 :         if (right) {</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :                 btrfs_tree_unlock(right);</span>
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :                 free_extent_buffer(right);</span>
<span class="lineNum">    2095 </span>            :         }
<span class="lineNum">    2096 </span><span class="lineCov">         11 :         if (left) {</span>
<span class="lineNum">    2097 </span><span class="lineCov">          8 :                 if (path-&gt;nodes[level] != left)</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :                         btrfs_tree_unlock(left);</span>
<span class="lineNum">    2099 </span><span class="lineCov">          8 :                 free_extent_buffer(left);</span>
<span class="lineNum">    2100 </span>            :         }
<span class="lineNum">    2101 </span><span class="lineCov">         11 :         return ret;</span>
<span class="lineNum">    2102 </span>            : }
<span class="lineNum">    2103 </span>            : 
<span class="lineNum">    2104 </span>            : /* Node balancing for insertion.  Here we only split or push nodes around
<span class="lineNum">    2105 </span>            :  * when they are completely full.  This is also done top down, so we
<a name="2106"><span class="lineNum">    2106 </span>            :  * have to be pessimistic.</a>
<span class="lineNum">    2107 </span>            :  */
<span class="lineNum">    2108 </span><span class="lineCov">        177 : static noinline int push_nodes_for_insert(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    2109 </span>            :                                           struct btrfs_root *root,
<span class="lineNum">    2110 </span>            :                                           struct btrfs_path *path, int level)
<span class="lineNum">    2111 </span>            : {
<span class="lineNum">    2112 </span><span class="lineCov">        177 :         struct extent_buffer *right = NULL;</span>
<span class="lineNum">    2113 </span><span class="lineCov">        247 :         struct extent_buffer *mid;</span>
<span class="lineNum">    2114 </span><span class="lineCov">        177 :         struct extent_buffer *left = NULL;</span>
<span class="lineNum">    2115 </span>            :         struct extent_buffer *parent = NULL;
<span class="lineNum">    2116 </span>            :         int ret = 0;
<span class="lineNum">    2117 </span>            :         int wret;
<span class="lineNum">    2118 </span>            :         int pslot;
<span class="lineNum">    2119 </span><span class="lineCov">        177 :         int orig_slot = path-&gt;slots[level];</span>
<span class="lineNum">    2120 </span>            : 
<span class="lineNum">    2121 </span><span class="lineCov">        177 :         if (level == 0)</span>
<span class="lineNum">    2122 </span>            :                 return 1;
<span class="lineNum">    2123 </span>            : 
<span class="lineNum">    2124 </span><span class="lineCov">        177 :         mid = path-&gt;nodes[level];</span>
<span class="lineNum">    2125 </span><span class="lineCov">        177 :         WARN_ON(btrfs_header_generation(mid) != trans-&gt;transid);</span>
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span><span class="lineCov">        177 :         if (level &lt; BTRFS_MAX_LEVEL - 1) {</span>
<span class="lineNum">    2128 </span><span class="lineCov">        177 :                 parent = path-&gt;nodes[level + 1];</span>
<span class="lineNum">    2129 </span><span class="lineCov">        177 :                 pslot = path-&gt;slots[level + 1];</span>
<span class="lineNum">    2130 </span>            :         }
<span class="lineNum">    2131 </span>            : 
<span class="lineNum">    2132 </span><span class="lineCov">        177 :         if (!parent)</span>
<span class="lineNum">    2133 </span>            :                 return 1;
<span class="lineNum">    2134 </span>            : 
<span class="lineNum">    2135 </span><span class="lineCov">        177 :         left = read_node_slot(root, parent, pslot - 1);</span>
<span class="lineNum">    2136 </span>            : 
<span class="lineNum">    2137 </span>            :         /* first, try to make some room in the middle buffer */
<span class="lineNum">    2138 </span><span class="lineCov">        390 :         if (left) {</span>
<span class="lineNum">    2139 </span>            :                 u32 left_nr;
<span class="lineNum">    2140 </span>            : 
<span class="lineNum">    2141 </span><span class="lineCov">        116 :                 btrfs_tree_lock(left);</span>
<span class="lineNum">    2142 </span><span class="lineCov">        116 :                 btrfs_set_lock_blocking(left);</span>
<span class="lineNum">    2143 </span>            : 
<span class="lineNum">    2144 </span><span class="lineCov">        116 :                 left_nr = btrfs_header_nritems(left);</span>
<span class="lineNum">    2145 </span><span class="lineCov">        116 :                 if (left_nr &gt;= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {</span>
<span class="lineNum">    2146 </span>            :                         wret = 1;
<span class="lineNum">    2147 </span>            :                 } else {
<span class="lineNum">    2148 </span><span class="lineCov">         97 :                         ret = btrfs_cow_block(trans, root, left, parent,</span>
<span class="lineNum">    2149 </span>            :                                               pslot - 1, &amp;left);
<span class="lineNum">    2150 </span><span class="lineCov">         97 :                         if (ret)</span>
<span class="lineNum">    2151 </span>            :                                 wret = 1;
<span class="lineNum">    2152 </span>            :                         else {
<span class="lineNum">    2153 </span><span class="lineCov">         97 :                                 wret = push_node_left(trans, root,</span>
<span class="lineNum">    2154 </span>            :                                                       left, mid, 0);
<span class="lineNum">    2155 </span>            :                         }
<span class="lineNum">    2156 </span>            :                 }
<span class="lineNum">    2157 </span>            :                 if (wret &lt; 0)
<span class="lineNum">    2158 </span>            :                         ret = wret;
<span class="lineNum">    2159 </span><span class="lineCov">        116 :                 if (wret == 0) {</span>
<span class="lineNum">    2160 </span>            :                         struct btrfs_disk_key disk_key;
<span class="lineNum">    2161 </span><span class="lineCov">         97 :                         orig_slot += left_nr;</span>
<span class="lineNum">    2162 </span><span class="lineCov">         97 :                         btrfs_node_key(mid, &amp;disk_key, 0);</span>
<span class="lineNum">    2163 </span><span class="lineCov">         97 :                         tree_mod_log_set_node_key(root-&gt;fs_info, parent,</span>
<span class="lineNum">    2164 </span>            :                                                   pslot, 0);
<span class="lineNum">    2165 </span>            :                         btrfs_set_node_key(parent, &amp;disk_key, pslot);
<span class="lineNum">    2166 </span><span class="lineCov">         97 :                         btrfs_mark_buffer_dirty(parent);</span>
<span class="lineNum">    2167 </span><span class="lineCov">        194 :                         if (btrfs_header_nritems(left) &gt; orig_slot) {</span>
<span class="lineNum">    2168 </span><span class="lineCov">          9 :                                 path-&gt;nodes[level] = left;</span>
<span class="lineNum">    2169 </span><span class="lineCov">          9 :                                 path-&gt;slots[level + 1] -= 1;</span>
<span class="lineNum">    2170 </span><span class="lineCov">          9 :                                 path-&gt;slots[level] = orig_slot;</span>
<span class="lineNum">    2171 </span><span class="lineCov">          9 :                                 btrfs_tree_unlock(mid);</span>
<span class="lineNum">    2172 </span><span class="lineCov">          9 :                                 free_extent_buffer(mid);</span>
<span class="lineNum">    2173 </span>            :                         } else {
<span class="lineNum">    2174 </span><span class="lineCov">         88 :                                 orig_slot -=</span>
<span class="lineNum">    2175 </span>            :                                         btrfs_header_nritems(left);
<span class="lineNum">    2176 </span><span class="lineCov">         88 :                                 path-&gt;slots[level] = orig_slot;</span>
<span class="lineNum">    2177 </span><span class="lineCov">         88 :                                 btrfs_tree_unlock(left);</span>
<span class="lineNum">    2178 </span><span class="lineCov">         88 :                                 free_extent_buffer(left);</span>
<span class="lineNum">    2179 </span>            :                         }
<span class="lineNum">    2180 </span>            :                         return 0;
<span class="lineNum">    2181 </span>            :                 }
<span class="lineNum">    2182 </span><span class="lineCov">         19 :                 btrfs_tree_unlock(left);</span>
<span class="lineNum">    2183 </span><span class="lineCov">         19 :                 free_extent_buffer(left);</span>
<span class="lineNum">    2184 </span>            :         }
<span class="lineNum">    2185 </span><span class="lineCov">         80 :         right = read_node_slot(root, parent, pslot + 1);</span>
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span>            :         /*
<span class="lineNum">    2188 </span>            :          * then try to empty the right most buffer into the middle
<span class="lineNum">    2189 </span>            :          */
<span class="lineNum">    2190 </span><span class="lineCov">        146 :         if (right) {</span>
<span class="lineNum">    2191 </span>            :                 u32 right_nr;
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span><span class="lineCov">         66 :                 btrfs_tree_lock(right);</span>
<span class="lineNum">    2194 </span><span class="lineCov">         66 :                 btrfs_set_lock_blocking(right);</span>
<span class="lineNum">    2195 </span>            : 
<span class="lineNum">    2196 </span><span class="lineCov">         66 :                 right_nr = btrfs_header_nritems(right);</span>
<span class="lineNum">    2197 </span><span class="lineCov">         66 :                 if (right_nr &gt;= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {</span>
<span class="lineNum">    2198 </span>            :                         wret = 1;
<span class="lineNum">    2199 </span>            :                 } else {
<span class="lineNum">    2200 </span><span class="lineCov">         65 :                         ret = btrfs_cow_block(trans, root, right,</span>
<span class="lineNum">    2201 </span>            :                                               parent, pslot + 1,
<span class="lineNum">    2202 </span>            :                                               &amp;right);
<span class="lineNum">    2203 </span><span class="lineCov">         65 :                         if (ret)</span>
<span class="lineNum">    2204 </span>            :                                 wret = 1;
<span class="lineNum">    2205 </span>            :                         else {
<span class="lineNum">    2206 </span><span class="lineCov">         65 :                                 wret = balance_node_right(trans, root,</span>
<span class="lineNum">    2207 </span>            :                                                           right, mid);
<span class="lineNum">    2208 </span>            :                         }
<span class="lineNum">    2209 </span>            :                 }
<span class="lineNum">    2210 </span>            :                 if (wret &lt; 0)
<span class="lineNum">    2211 </span>            :                         ret = wret;
<span class="lineNum">    2212 </span><span class="lineCov">         66 :                 if (wret == 0) {</span>
<span class="lineNum">    2213 </span>            :                         struct btrfs_disk_key disk_key;
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span><span class="lineCov">         65 :                         btrfs_node_key(right, &amp;disk_key, 0);</span>
<span class="lineNum">    2216 </span><span class="lineCov">         65 :                         tree_mod_log_set_node_key(root-&gt;fs_info, parent,</span>
<span class="lineNum">    2217 </span>            :                                                   pslot + 1, 0);
<span class="lineNum">    2218 </span>            :                         btrfs_set_node_key(parent, &amp;disk_key, pslot + 1);
<span class="lineNum">    2219 </span><span class="lineCov">         65 :                         btrfs_mark_buffer_dirty(parent);</span>
<span class="lineNum">    2220 </span>            : 
<span class="lineNum">    2221 </span><span class="lineCov">         65 :                         if (btrfs_header_nritems(mid) &lt;= orig_slot) {</span>
<span class="lineNum">    2222 </span><span class="lineCov">          5 :                                 path-&gt;nodes[level] = right;</span>
<span class="lineNum">    2223 </span><span class="lineCov">          5 :                                 path-&gt;slots[level + 1] += 1;</span>
<span class="lineNum">    2224 </span><span class="lineCov">          5 :                                 path-&gt;slots[level] = orig_slot -</span>
<span class="lineNum">    2225 </span>            :                                         btrfs_header_nritems(mid);
<span class="lineNum">    2226 </span><span class="lineCov">          5 :                                 btrfs_tree_unlock(mid);</span>
<span class="lineNum">    2227 </span><span class="lineCov">          5 :                                 free_extent_buffer(mid);</span>
<span class="lineNum">    2228 </span>            :                         } else {
<span class="lineNum">    2229 </span><span class="lineCov">         60 :                                 btrfs_tree_unlock(right);</span>
<span class="lineNum">    2230 </span><span class="lineCov">         60 :                                 free_extent_buffer(right);</span>
<span class="lineNum">    2231 </span>            :                         }
<span class="lineNum">    2232 </span>            :                         return 0;
<span class="lineNum">    2233 </span>            :                 }
<span class="lineNum">    2234 </span><span class="lineCov">          1 :                 btrfs_tree_unlock(right);</span>
<span class="lineNum">    2235 </span><span class="lineCov">          1 :                 free_extent_buffer(right);</span>
<span class="lineNum">    2236 </span>            :         }
<span class="lineNum">    2237 </span>            :         return 1;
<span class="lineNum">    2238 </span>            : }
<span class="lineNum">    2239 </span>            : 
<span class="lineNum">    2240 </span>            : /*
<span class="lineNum">    2241 </span>            :  * readahead one full node of leaves, finding things that are close
<a name="2242"><span class="lineNum">    2242 </span>            :  * to the block in 'slot', and triggering ra on them.</a>
<span class="lineNum">    2243 </span>            :  */
<span class="lineNum">    2244 </span><span class="lineCov">        230 : static void reada_for_search(struct btrfs_root *root,</span>
<span class="lineNum">    2245 </span>            :                              struct btrfs_path *path,
<span class="lineNum">    2246 </span>            :                              int level, int slot, u64 objectid)
<span class="lineNum">    2247 </span>            : {
<span class="lineNum">    2248 </span><span class="lineCov">        114 :         struct extent_buffer *node;</span>
<span class="lineNum">    2249 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    2250 </span>            :         u32 nritems;
<span class="lineNum">    2251 </span>            :         u64 search;
<span class="lineNum">    2252 </span>            :         u64 target;
<span class="lineNum">    2253 </span>            :         u64 nread = 0;
<span class="lineNum">    2254 </span>            :         u64 gen;
<span class="lineNum">    2255 </span><span class="lineCov">        116 :         int direction = path-&gt;reada;</span>
<span class="lineNum">    2256 </span>            :         struct extent_buffer *eb;
<span class="lineNum">    2257 </span>            :         u32 nr;
<span class="lineNum">    2258 </span>            :         u32 blocksize;
<span class="lineNum">    2259 </span>            :         u32 nscan = 0;
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span><span class="lineCov">        116 :         if (level != 1)</span>
<span class="lineNum">    2262 </span><span class="lineCov">          2 :                 return;</span>
<span class="lineNum">    2263 </span>            : 
<span class="lineNum">    2264 </span><span class="lineCov">        114 :         if (!path-&gt;nodes[level])</span>
<span class="lineNum">    2265 </span>            :                 return;
<span class="lineNum">    2266 </span>            : 
<span class="lineNum">    2267 </span>            :         node = path-&gt;nodes[level];
<span class="lineNum">    2268 </span>            : 
<span class="lineNum">    2269 </span>            :         search = btrfs_node_blockptr(node, slot);
<span class="lineNum">    2270 </span>            :         blocksize = btrfs_level_size(root, level - 1);
<span class="lineNum">    2271 </span><span class="lineCov">        114 :         eb = btrfs_find_tree_block(root, search, blocksize);</span>
<span class="lineNum">    2272 </span><span class="lineCov">        114 :         if (eb) {</span>
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :                 free_extent_buffer(eb);</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    2275 </span>            :         }
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span>            :         target = search;
<span class="lineNum">    2278 </span>            : 
<span class="lineNum">    2279 </span>            :         nritems = btrfs_header_nritems(node);
<span class="lineNum">    2280 </span><span class="lineCov">        114 :         nr = slot;</span>
<span class="lineNum">    2281 </span>            : 
<span class="lineNum">    2282 </span>            :         while (1) {
<span class="lineNum">    2283 </span><span class="lineCov">       1308 :                 if (direction &lt; 0) {</span>
<span class="lineNum">    2284 </span><span class="lineCov">         37 :                         if (nr == 0)</span>
<span class="lineNum">    2285 </span>            :                                 break;
<span class="lineNum">    2286 </span><span class="lineCov">         37 :                         nr--;</span>
<span class="lineNum">    2287 </span><span class="lineCov">       1271 :                 } else if (direction &gt; 0) {</span>
<span class="lineNum">    2288 </span><span class="lineCov">       1271 :                         nr++;</span>
<span class="lineNum">    2289 </span><span class="lineCov">       1271 :                         if (nr &gt;= nritems)</span>
<span class="lineNum">    2290 </span>            :                                 break;
<span class="lineNum">    2291 </span>            :                 }
<span class="lineNum">    2292 </span><span class="lineCov">       1254 :                 if (path-&gt;reada &lt; 0 &amp;&amp; objectid) {</span>
<span class="lineNum">    2293 </span><span class="lineCov">         37 :                         btrfs_node_key(node, &amp;disk_key, nr);</span>
<span class="lineNum">    2294 </span><span class="lineCov">         37 :                         if (btrfs_disk_key_objectid(&amp;disk_key) != objectid)</span>
<span class="lineNum">    2295 </span>            :                                 break;
<span class="lineNum">    2296 </span>            :                 }
<span class="lineNum">    2297 </span><span class="lineCov">       1217 :                 search = btrfs_node_blockptr(node, nr);</span>
<span class="lineNum">    2298 </span><span class="lineCov">       1217 :                 if ((search &lt;= target &amp;&amp; target - search &lt;= 65536) ||</span>
<span class="lineNum">    2299 </span><span class="lineCov">        744 :                     (search &gt; target &amp;&amp; search - target &lt;= 65536)) {</span>
<span class="lineNum">    2300 </span>            :                         gen = btrfs_node_ptr_generation(node, nr);
<span class="lineNum">    2301 </span><span class="lineCov">        142 :                         readahead_tree_block(root, search, blocksize, gen);</span>
<span class="lineNum">    2302 </span><span class="lineCov">        142 :                         nread += blocksize;</span>
<span class="lineNum">    2303 </span>            :                 }
<span class="lineNum">    2304 </span><span class="lineCov">       1217 :                 nscan++;</span>
<span class="lineNum">    2305 </span><span class="lineCov">       1217 :                 if ((nread &gt; 65536 || nscan &gt; 32))</span>
<span class="lineNum">    2306 </span>            :                         break;
<span class="lineNum">    2307 </span>            :         }
<a name="2308"><span class="lineNum">    2308 </span>            : }</a>
<span class="lineNum">    2309 </span>            : 
<span class="lineNum">    2310 </span><span class="lineCov">     201896 : static noinline void reada_for_balance(struct btrfs_root *root,</span>
<span class="lineNum">    2311 </span>            :                                        struct btrfs_path *path, int level)
<span class="lineNum">    2312 </span>            : {
<span class="lineNum">    2313 </span>            :         int slot;
<span class="lineNum">    2314 </span>            :         int nritems;
<span class="lineNum">    2315 </span><span class="lineCov">      11486 :         struct extent_buffer *parent;</span>
<span class="lineNum">    2316 </span>            :         struct extent_buffer *eb;
<span class="lineNum">    2317 </span>            :         u64 gen;
<span class="lineNum">    2318 </span>            :         u64 block1 = 0;
<span class="lineNum">    2319 </span>            :         u64 block2 = 0;
<span class="lineNum">    2320 </span>            :         int blocksize;
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span><span class="lineCov">     190410 :         parent = path-&gt;nodes[level + 1];</span>
<span class="lineNum">    2323 </span><span class="lineCov">     190410 :         if (!parent)</span>
<span class="lineNum">    2324 </span><span class="lineCov">     190410 :                 return;</span>
<span class="lineNum">    2325 </span>            : 
<span class="lineNum">    2326 </span><span class="lineCov">      11486 :         nritems = btrfs_header_nritems(parent);</span>
<span class="lineNum">    2327 </span><span class="lineCov">      11486 :         slot = path-&gt;slots[level + 1];</span>
<span class="lineNum">    2328 </span>            :         blocksize = btrfs_level_size(root, level);
<span class="lineNum">    2329 </span>            : 
<span class="lineNum">    2330 </span><span class="lineCov">      11486 :         if (slot &gt; 0) {</span>
<span class="lineNum">    2331 </span><span class="lineCov">       9446 :                 block1 = btrfs_node_blockptr(parent, slot - 1);</span>
<span class="lineNum">    2332 </span>            :                 gen = btrfs_node_ptr_generation(parent, slot - 1);
<span class="lineNum">    2333 </span><span class="lineCov">       9446 :                 eb = btrfs_find_tree_block(root, block1, blocksize);</span>
<span class="lineNum">    2334 </span>            :                 /*
<span class="lineNum">    2335 </span>            :                  * if we get -eagain from btrfs_buffer_uptodate, we
<span class="lineNum">    2336 </span>            :                  * don't want to return eagain here.  That will loop
<span class="lineNum">    2337 </span>            :                  * forever
<span class="lineNum">    2338 </span>            :                  */
<span class="lineNum">    2339 </span><span class="lineCov">       9446 :                 if (eb &amp;&amp; btrfs_buffer_uptodate(eb, gen, 1) != 0)</span>
<span class="lineNum">    2340 </span>            :                         block1 = 0;
<span class="lineNum">    2341 </span><span class="lineCov">       9446 :                 free_extent_buffer(eb);</span>
<span class="lineNum">    2342 </span>            :         }
<span class="lineNum">    2343 </span><span class="lineCov">      11486 :         if (slot + 1 &lt; nritems) {</span>
<span class="lineNum">    2344 </span>            :                 block2 = btrfs_node_blockptr(parent, slot + 1);
<span class="lineNum">    2345 </span>            :                 gen = btrfs_node_ptr_generation(parent, slot + 1);
<span class="lineNum">    2346 </span><span class="lineCov">       7098 :                 eb = btrfs_find_tree_block(root, block2, blocksize);</span>
<span class="lineNum">    2347 </span><span class="lineCov">       7098 :                 if (eb &amp;&amp; btrfs_buffer_uptodate(eb, gen, 1) != 0)</span>
<span class="lineNum">    2348 </span>            :                         block2 = 0;
<span class="lineNum">    2349 </span><span class="lineCov">       7098 :                 free_extent_buffer(eb);</span>
<span class="lineNum">    2350 </span>            :         }
<span class="lineNum">    2351 </span>            : 
<span class="lineNum">    2352 </span><span class="lineCov">      11486 :         if (block1)</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :                 readahead_tree_block(root, block1, blocksize, 0);</span>
<span class="lineNum">    2354 </span><span class="lineCov">      11486 :         if (block2)</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :                 readahead_tree_block(root, block2, blocksize, 0);</span>
<span class="lineNum">    2356 </span>            : }
<span class="lineNum">    2357 </span>            : 
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            : /*
<span class="lineNum">    2360 </span>            :  * when we walk down the tree, it is usually safe to unlock the higher layers
<span class="lineNum">    2361 </span>            :  * in the tree.  The exceptions are when our path goes through slot 0, because
<span class="lineNum">    2362 </span>            :  * operations on the tree might require changing key pointers higher up in the
<span class="lineNum">    2363 </span>            :  * tree.
<span class="lineNum">    2364 </span>            :  *
<span class="lineNum">    2365 </span>            :  * callers might also have set path-&gt;keep_locks, which tells this code to keep
<span class="lineNum">    2366 </span>            :  * the lock if the path points to the last slot in the block.  This is part of
<span class="lineNum">    2367 </span>            :  * walking through the tree, and selecting the next slot in the higher block.
<span class="lineNum">    2368 </span>            :  *
<span class="lineNum">    2369 </span>            :  * lowest_unlock sets the lowest level in the tree we're allowed to unlock.  so
<a name="2370"><span class="lineNum">    2370 </span>            :  * if lowest_unlock is 1, level 0 won't be unlocked</a>
<span class="lineNum">    2371 </span>            :  */
<span class="lineNum">    2372 </span><span class="lineCov">    4948754 : static noinline void unlock_up(struct btrfs_path *path, int level,</span>
<span class="lineNum">    2373 </span>            :                                int lowest_unlock, int min_write_lock_level,
<span class="lineNum">    2374 </span>            :                                int *write_lock_level)
<span class="lineNum">    2375 </span>            : {
<span class="lineNum">    2376 </span>            :         int i;
<span class="lineNum">    2377 </span>            :         int skip_level = level;
<span class="lineNum">    2378 </span>            :         int no_skips = 0;
<span class="lineNum">    2379 </span><span class="lineCov">     105520 :         struct extent_buffer *t;</span>
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span><span class="lineCov">    7861945 :         for (i = level; i &lt; BTRFS_MAX_LEVEL; i++) {</span>
<span class="lineNum">    2382 </span><span class="lineCov">    7860331 :                 if (!path-&gt;nodes[i])</span>
<span class="lineNum">    2383 </span>            :                         break;
<span class="lineNum">    2384 </span><span class="lineCov">    6213724 :                 if (!path-&gt;locks[i])</span>
<span class="lineNum">    2385 </span>            :                         break;
<span class="lineNum">    2386 </span><span class="lineCov">    2913116 :                 if (!no_skips &amp;&amp; path-&gt;slots[i] == 0) {</span>
<span class="lineNum">    2387 </span><span class="lineCov">     262583 :                         skip_level = i + 1;</span>
<span class="lineNum">    2388 </span><span class="lineCov">     262583 :                         continue;</span>
<span class="lineNum">    2389 </span>            :                 }
<span class="lineNum">    2390 </span><span class="lineCov">    2650533 :                 if (!no_skips &amp;&amp; path-&gt;keep_locks) {</span>
<span class="lineNum">    2391 </span>            :                         u32 nritems;
<span class="lineNum">    2392 </span>            :                         t = path-&gt;nodes[i];
<span class="lineNum">    2393 </span>            :                         nritems = btrfs_header_nritems(t);
<span class="lineNum">    2394 </span><span class="lineCov">     105520 :                         if (nritems &lt; 1 || path-&gt;slots[i] &gt;= nritems - 1) {</span>
<span class="lineNum">    2395 </span><span class="lineCov">      55929 :                                 skip_level = i + 1;</span>
<span class="lineNum">    2396 </span><span class="lineCov">      55929 :                                 continue;</span>
<span class="lineNum">    2397 </span>            :                         }
<span class="lineNum">    2398 </span>            :                 }
<span class="lineNum">    2399 </span><span class="lineCov">    2594604 :                 if (skip_level &lt; i &amp;&amp; i &gt;= lowest_unlock)</span>
<span class="lineNum">    2400 </span>            :                         no_skips = 1;
<span class="lineNum">    2401 </span>            : 
<span class="lineNum">    2402 </span>            :                 t = path-&gt;nodes[i];
<span class="lineNum">    2403 </span><span class="lineCov">    2594604 :                 if (i &gt;= lowest_unlock &amp;&amp; i &gt; skip_level &amp;&amp; path-&gt;locks[i]) {</span>
<span class="lineNum">    2404 </span><span class="lineCov">     345066 :                         btrfs_tree_unlock_rw(t, path-&gt;locks[i]);</span>
<span class="lineNum">    2405 </span><span class="lineCov">     345141 :                         path-&gt;locks[i] = 0;</span>
<span class="lineNum">    2406 </span><span class="lineCov">     690282 :                         if (write_lock_level &amp;&amp;</span>
<span class="lineNum">    2407 </span><span class="lineCov">     392278 :                             i &gt; min_write_lock_level &amp;&amp;</span>
<span class="lineNum">    2408 </span><span class="lineCov">      47137 :                             i &lt;= *write_lock_level) {</span>
<span class="lineNum">    2409 </span><span class="lineCov">      21259 :                                 *write_lock_level = i - 1;</span>
<span class="lineNum">    2410 </span>            :                         }
<span class="lineNum">    2411 </span>            :                 }
<span class="lineNum">    2412 </span>            :         }
<span class="lineNum">    2413 </span><span class="lineCov">    4948829 : }</span>
<span class="lineNum">    2414 </span>            : 
<span class="lineNum">    2415 </span>            : /*
<span class="lineNum">    2416 </span>            :  * This releases any locks held in the path starting at level and
<span class="lineNum">    2417 </span>            :  * going all the way up to the root.
<span class="lineNum">    2418 </span>            :  *
<span class="lineNum">    2419 </span>            :  * btrfs_search_slot will keep the lock held on higher nodes in a few
<span class="lineNum">    2420 </span>            :  * corner cases, such as COW of the block at slot zero in the node.  This
<span class="lineNum">    2421 </span>            :  * ignores those rules, and it should only be called when there are no
<a name="2422"><span class="lineNum">    2422 </span>            :  * more updates to be done higher up in the tree.</a>
<span class="lineNum">    2423 </span>            :  */
<span class="lineNum">    2424 </span><span class="lineCov">     295102 : noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)</span>
<span class="lineNum">    2425 </span>            : {
<span class="lineNum">    2426 </span>            :         int i;
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span><span class="lineCov">     295102 :         if (path-&gt;keep_locks)</span>
<span class="lineNum">    2429 </span><span class="lineCov">     295296 :                 return;</span>
<span class="lineNum">    2430 </span>            : 
<span class="lineNum">    2431 </span><span class="lineCov">    2054782 :         for (i = level; i &lt; BTRFS_MAX_LEVEL; i++) {</span>
<span class="lineNum">    2432 </span><span class="lineCov">    2054588 :                 if (!path-&gt;nodes[i])</span>
<span class="lineNum">    2433 </span><span class="lineCov">    1749008 :                         continue;</span>
<span class="lineNum">    2434 </span><span class="lineCov">     305580 :                 if (!path-&gt;locks[i])</span>
<span class="lineNum">    2435 </span><span class="lineCov">     239717 :                         continue;</span>
<span class="lineNum">    2436 </span><span class="lineCov">      65863 :                 btrfs_tree_unlock_rw(path-&gt;nodes[i], path-&gt;locks[i]);</span>
<span class="lineNum">    2437 </span><span class="lineCov">      66057 :                 path-&gt;locks[i] = 0;</span>
<span class="lineNum">    2438 </span>            :         }
<span class="lineNum">    2439 </span>            : }
<span class="lineNum">    2440 </span>            : 
<span class="lineNum">    2441 </span>            : /*
<span class="lineNum">    2442 </span>            :  * helper function for btrfs_search_slot.  The goal is to find a block
<span class="lineNum">    2443 </span>            :  * in cache without setting the path to blocking.  If we find the block
<span class="lineNum">    2444 </span>            :  * we return zero and the path is unchanged.
<span class="lineNum">    2445 </span>            :  *
<span class="lineNum">    2446 </span>            :  * If we can't find the block, we set the path blocking and do some
<span class="lineNum">    2447 </span>            :  * reada.  -EAGAIN is returned and the search must be repeated.
<a name="2448"><span class="lineNum">    2448 </span>            :  */</a>
<span class="lineNum">    2449 </span>            : static int
<span class="lineNum">    2450 </span><span class="lineCov">    2208274 : read_block_for_search(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    2451 </span><span class="lineCov">    2207946 :                        struct btrfs_root *root, struct btrfs_path *p,</span>
<span class="lineNum">    2452 </span>            :                        struct extent_buffer **eb_ret, int level, int slot,
<span class="lineNum">    2453 </span>            :                        struct btrfs_key *key, u64 time_seq)
<span class="lineNum">    2454 </span>            : {
<span class="lineNum">    2455 </span>            :         u64 blocknr;
<span class="lineNum">    2456 </span>            :         u64 gen;
<span class="lineNum">    2457 </span>            :         u32 blocksize;
<span class="lineNum">    2458 </span><span class="lineCov">    2208274 :         struct extent_buffer *b = *eb_ret;</span>
<span class="lineNum">    2459 </span>            :         struct extent_buffer *tmp;
<span class="lineNum">    2460 </span>            :         int ret;
<span class="lineNum">    2461 </span>            : 
<span class="lineNum">    2462 </span>            :         blocknr = btrfs_node_blockptr(b, slot);
<span class="lineNum">    2463 </span>            :         gen = btrfs_node_ptr_generation(b, slot);
<span class="lineNum">    2464 </span>            :         blocksize = btrfs_level_size(root, level - 1);
<span class="lineNum">    2465 </span>            : 
<span class="lineNum">    2466 </span><span class="lineCov">    2207946 :         tmp = btrfs_find_tree_block(root, blocknr, blocksize);</span>
<span class="lineNum">    2467 </span><span class="lineCov">    2208699 :         if (tmp) {</span>
<span class="lineNum">    2468 </span>            :                 /* first we do an atomic uptodate check */
<span class="lineNum">    2469 </span><span class="lineCov">    2208304 :                 if (btrfs_buffer_uptodate(tmp, gen, 1) &gt; 0) {</span>
<span class="lineNum">    2470 </span><span class="lineCov">    2208130 :                         *eb_ret = tmp;</span>
<span class="lineNum">    2471 </span>            :                         return 0;
<span class="lineNum">    2472 </span>            :                 }
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span>            :                 /* the pages were up to date, but we failed
<span class="lineNum">    2475 </span>            :                  * the generation number check.  Do a full
<span class="lineNum">    2476 </span>            :                  * read for the generation number that is correct.
<span class="lineNum">    2477 </span>            :                  * We must do this without dropping locks so
<span class="lineNum">    2478 </span>            :                  * we can trust our generation number
<span class="lineNum">    2479 </span>            :                  */
<span class="lineNum">    2480 </span><span class="lineCov">          3 :                 btrfs_set_path_blocking(p);</span>
<span class="lineNum">    2481 </span>            : 
<span class="lineNum">    2482 </span>            :                 /* now we're allowed to do a blocking uptodate check */
<span class="lineNum">    2483 </span><span class="lineCov">          3 :                 ret = btrfs_read_buffer(tmp, gen);</span>
<span class="lineNum">    2484 </span><span class="lineCov">          3 :                 if (!ret) {</span>
<span class="lineNum">    2485 </span><span class="lineCov">          3 :                         *eb_ret = tmp;</span>
<span class="lineNum">    2486 </span>            :                         return 0;
<span class="lineNum">    2487 </span>            :                 }
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :                 free_extent_buffer(tmp);</span>
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :                 btrfs_release_path(p);</span>
<span class="lineNum">    2490 </span>            :                 return -EIO;
<span class="lineNum">    2491 </span>            :         }
<span class="lineNum">    2492 </span>            : 
<span class="lineNum">    2493 </span>            :         /*
<span class="lineNum">    2494 </span>            :          * reduce lock contention at high levels
<span class="lineNum">    2495 </span>            :          * of the btree by dropping locks before
<span class="lineNum">    2496 </span>            :          * we read.  Don't release the lock on the current
<span class="lineNum">    2497 </span>            :          * level because we need to walk this node to figure
<span class="lineNum">    2498 </span>            :          * out which blocks to read.
<span class="lineNum">    2499 </span>            :          */
<span class="lineNum">    2500 </span><span class="lineCov">        395 :         btrfs_unlock_up_safe(p, level + 1);</span>
<span class="lineNum">    2501 </span><span class="lineCov">        395 :         btrfs_set_path_blocking(p);</span>
<span class="lineNum">    2502 </span>            : 
<span class="lineNum">    2503 </span><span class="lineCov">        395 :         free_extent_buffer(tmp);</span>
<span class="lineNum">    2504 </span><span class="lineCov">        395 :         if (p-&gt;reada)</span>
<span class="lineNum">    2505 </span><span class="lineCov">        116 :                 reada_for_search(root, p, level, slot, key-&gt;objectid);</span>
<span class="lineNum">    2506 </span>            : 
<span class="lineNum">    2507 </span><span class="lineCov">        395 :         btrfs_release_path(p);</span>
<span class="lineNum">    2508 </span>            : 
<span class="lineNum">    2509 </span>            :         ret = -EAGAIN;
<span class="lineNum">    2510 </span><span class="lineCov">        395 :         tmp = read_tree_block(root, blocknr, blocksize, 0);</span>
<span class="lineNum">    2511 </span><span class="lineCov">        395 :         if (tmp) {</span>
<span class="lineNum">    2512 </span>            :                 /*
<span class="lineNum">    2513 </span>            :                  * If the read above didn't mark this buffer up to date,
<span class="lineNum">    2514 </span>            :                  * it will never end up being up to date.  Set ret to EIO now
<span class="lineNum">    2515 </span>            :                  * and give up so that our caller doesn't loop forever
<span class="lineNum">    2516 </span>            :                  * on our EAGAINs.
<span class="lineNum">    2517 </span>            :                  */
<span class="lineNum">    2518 </span><span class="lineCov">        395 :                 if (!btrfs_buffer_uptodate(tmp, 0, 0))</span>
<span class="lineNum">    2519 </span>            :                         ret = -EIO;
<span class="lineNum">    2520 </span><span class="lineCov">        395 :                 free_extent_buffer(tmp);</span>
<span class="lineNum">    2521 </span>            :         }
<span class="lineNum">    2522 </span>            :         return ret;
<span class="lineNum">    2523 </span>            : }
<span class="lineNum">    2524 </span>            : 
<span class="lineNum">    2525 </span>            : /*
<span class="lineNum">    2526 </span>            :  * helper function for btrfs_search_slot.  This does all of the checks
<span class="lineNum">    2527 </span>            :  * for node-level blocks and does any balancing required based on
<span class="lineNum">    2528 </span>            :  * the ins_len.
<span class="lineNum">    2529 </span>            :  *
<span class="lineNum">    2530 </span>            :  * If no extra work was required, zero is returned.  If we had to
<span class="lineNum">    2531 </span>            :  * drop the path, -EAGAIN is returned and btrfs_search_slot must
<span class="lineNum">    2532 </span>            :  * start over
<a name="2533"><span class="lineNum">    2533 </span>            :  */</a>
<span class="lineNum">    2534 </span>            : static int
<span class="lineNum">    2535 </span><span class="lineCov">    2844551 : setup_nodes_for_search(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    2536 </span>            :                        struct btrfs_root *root, struct btrfs_path *p,
<span class="lineNum">    2537 </span><span class="lineCov">     833904 :                        struct extent_buffer *b, int level, int ins_len,</span>
<span class="lineNum">    2538 </span>            :                        int *write_lock_level)
<span class="lineNum">    2539 </span>            : {
<span class="lineNum">    2540 </span>            :         int ret;
<span class="lineNum">    2541 </span><span class="lineCov">    3528429 :         if ((p-&gt;search_for_split || ins_len &gt; 0) &amp;&amp; btrfs_header_nritems(b) &gt;=</span>
<span class="lineNum">    2542 </span><span class="lineCov">     341939 :             BTRFS_NODEPTRS_PER_BLOCK(root) - 3) {</span>
<span class="lineNum">    2543 </span>            :                 int sret;
<span class="lineNum">    2544 </span>            : 
<span class="lineNum">    2545 </span><span class="lineCov">        299 :                 if (*write_lock_level &lt; level + 1) {</span>
<span class="lineNum">    2546 </span><span class="lineCov">        119 :                         *write_lock_level = level + 1;</span>
<span class="lineNum">    2547 </span><span class="lineCov">        119 :                         btrfs_release_path(p);</span>
<span class="lineNum">    2548 </span><span class="lineCov">        119 :                         goto again;</span>
<span class="lineNum">    2549 </span>            :                 }
<span class="lineNum">    2550 </span>            : 
<span class="lineNum">    2551 </span><span class="lineCov">        180 :                 btrfs_set_path_blocking(p);</span>
<span class="lineNum">    2552 </span><span class="lineCov">        180 :                 reada_for_balance(root, p, level);</span>
<span class="lineNum">    2553 </span><span class="lineCov">        180 :                 sret = split_node(trans, root, p, level);</span>
<span class="lineNum">    2554 </span><span class="lineCov">        180 :                 btrfs_clear_path_blocking(p, NULL, 0);</span>
<span class="lineNum">    2555 </span>            : 
<span class="lineNum">    2556 </span><span class="lineCov">        180 :                 BUG_ON(sret &gt; 0);</span>
<span class="lineNum">    2557 </span><span class="lineCov">        180 :                 if (sret) {</span>
<span class="lineNum">    2558 </span>            :                         ret = sret;
<span class="lineNum">    2559 </span>            :                         goto done;
<span class="lineNum">    2560 </span>            :                 }
<span class="lineNum">    2561 </span>            :                 b = p-&gt;nodes[level];
<span class="lineNum">    2562 </span><span class="lineCov">    3447782 :         } else if (ins_len &lt; 0 &amp;&amp; btrfs_header_nritems(b) &lt;</span>
<span class="lineNum">    2563 </span><span class="lineCov">     301765 :                    BTRFS_NODEPTRS_PER_BLOCK(root) / 2) {</span>
<span class="lineNum">    2564 </span>            :                 int sret;
<span class="lineNum">    2565 </span>            : 
<span class="lineNum">    2566 </span><span class="lineCov">     250402 :                 if (*write_lock_level &lt; level + 1) {</span>
<span class="lineNum">    2567 </span><span class="lineCov">      60182 :                         *write_lock_level = level + 1;</span>
<span class="lineNum">    2568 </span><span class="lineCov">      60182 :                         btrfs_release_path(p);</span>
<span class="lineNum">    2569 </span><span class="lineCov">      60182 :                         goto again;</span>
<span class="lineNum">    2570 </span>            :                 }
<span class="lineNum">    2571 </span>            : 
<span class="lineNum">    2572 </span><span class="lineCov">     190220 :                 btrfs_set_path_blocking(p);</span>
<span class="lineNum">    2573 </span><span class="lineCov">     190230 :                 reada_for_balance(root, p, level);</span>
<span class="lineNum">    2574 </span><span class="lineCov">     190233 :                 sret = balance_level(trans, root, p, level);</span>
<span class="lineNum">    2575 </span><span class="lineCov">     190232 :                 btrfs_clear_path_blocking(p, NULL, 0);</span>
<span class="lineNum">    2576 </span>            : 
<span class="lineNum">    2577 </span><span class="lineCov">     190231 :                 if (sret) {</span>
<span class="lineNum">    2578 </span>            :                         ret = sret;
<span class="lineNum">    2579 </span>            :                         goto done;
<span class="lineNum">    2580 </span>            :                 }
<span class="lineNum">    2581 </span><span class="lineCov">     190232 :                 b = p-&gt;nodes[level];</span>
<span class="lineNum">    2582 </span><span class="lineCov">     190232 :                 if (!b) {</span>
<span class="lineNum">    2583 </span><span class="lineCov">         32 :                         btrfs_release_path(p);</span>
<span class="lineNum">    2584 </span><span class="lineCov">         32 :                         goto again;</span>
<span class="lineNum">    2585 </span>            :                 }
<span class="lineNum">    2586 </span><span class="lineCov">     190200 :                 BUG_ON(btrfs_header_nritems(b) == 1);</span>
<span class="lineNum">    2587 </span>            :         }
<span class="lineNum">    2588 </span>            :         return 0;
<span class="lineNum">    2589 </span>            : 
<span class="lineNum">    2590 </span>            : again:
<span class="lineNum">    2591 </span>            :         ret = -EAGAIN;
<span class="lineNum">    2592 </span>            : done:
<span class="lineNum">    2593 </span><span class="lineCov">      60333 :         return ret;</span>
<span class="lineNum">    2594 </span>            : }
<span class="lineNum">    2595 </span>            : 
<span class="lineNum">    2596 </span>            : static void key_search_validate(struct extent_buffer *b,
<span class="lineNum">    2597 </span>            :                                 struct btrfs_key *key,
<span class="lineNum">    2598 </span>            :                                 int level)
<span class="lineNum">    2599 </span>            : {
<span class="lineNum">    2600 </span>            : #ifdef CONFIG_BTRFS_ASSERT
<span class="lineNum">    2601 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    2602 </span>            : 
<span class="lineNum">    2603 </span>            :         btrfs_cpu_key_to_disk(&amp;disk_key, key);
<span class="lineNum">    2604 </span>            : 
<span class="lineNum">    2605 </span>            :         if (level == 0)
<span class="lineNum">    2606 </span>            :                 ASSERT(!memcmp_extent_buffer(b, &amp;disk_key,
<span class="lineNum">    2607 </span>            :                     offsetof(struct btrfs_leaf, items[0].key),
<span class="lineNum">    2608 </span>            :                     sizeof(disk_key)));
<span class="lineNum">    2609 </span>            :         else
<span class="lineNum">    2610 </span>            :                 ASSERT(!memcmp_extent_buffer(b, &amp;disk_key,
<span class="lineNum">    2611 </span>            :                     offsetof(struct btrfs_node, ptrs[0].key),
<span class="lineNum">    2612 </span>            :                     sizeof(disk_key)));
<span class="lineNum">    2613 </span>            : #endif
<span class="lineNum">    2614 </span>            : }
<span class="lineNum">    2615 </span>            : 
<span class="lineNum">    2616 </span>            : static int key_search(struct extent_buffer *b, struct btrfs_key *key,
<a name="2617"><span class="lineNum">    2617 </span>            :                       int level, int *prev_cmp, int *slot)</a>
<a name="2618"><span class="lineNum">    2618 </span>            : {</a>
<span class="lineNum">    2619 </span><span class="lineCov">    4980558 :         if (*prev_cmp != 0) {</span>
<span class="lineNum">    2620 </span><span class="lineCov">    4980672 :                 *prev_cmp = bin_search(b, key, level, slot);</span>
<span class="lineNum">    2621 </span>            :                 return *prev_cmp;
<span class="lineNum">    2622 </span>            :         }
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span>            :         key_search_validate(b, key, level);
<span class="lineNum">    2625 </span><span class="lineCov">      11021 :         *slot = 0;</span>
<span class="lineNum">    2626 </span>            : 
<span class="lineNum">    2627 </span>            :         return 0;
<span class="lineNum">    2628 </span>            : }
<span class="lineNum">    2629 </span>            : 
<span class="lineNum">    2630 </span><span class="lineCov">       6052 : int btrfs_find_item(struct btrfs_root *fs_root, struct btrfs_path *found_path,</span>
<span class="lineNum">    2631 </span>            :                 u64 iobjectid, u64 ioff, u8 key_type,
<span class="lineNum">    2632 </span>            :                 struct btrfs_key *found_key)
<span class="lineNum">    2633 </span>            : {
<span class="lineNum">    2634 </span>            :         int ret;
<span class="lineNum">    2635 </span>            :         struct btrfs_key key;
<span class="lineNum">    2636 </span><span class="lineCov">       5227 :         struct extent_buffer *eb;</span>
<span class="lineNum">    2637 </span>            :         struct btrfs_path *path;
<span class="lineNum">    2638 </span>            : 
<span class="lineNum">    2639 </span><span class="lineCov">       6052 :         key.type = key_type;</span>
<span class="lineNum">    2640 </span><span class="lineCov">       6052 :         key.objectid = iobjectid;</span>
<span class="lineNum">    2641 </span><span class="lineCov">       6052 :         key.offset = ioff;</span>
<span class="lineNum">    2642 </span>            : 
<span class="lineNum">    2643 </span><span class="lineCov">       6052 :         if (found_path == NULL) {</span>
<span class="lineNum">    2644 </span>            :                 path = btrfs_alloc_path();
<span class="lineNum">    2645 </span><span class="lineCov">        616 :                 if (!path)</span>
<span class="lineNum">    2646 </span>            :                         return -ENOMEM;
<span class="lineNum">    2647 </span>            :         } else
<span class="lineNum">    2648 </span>            :                 path = found_path;
<span class="lineNum">    2649 </span>            : 
<span class="lineNum">    2650 </span><span class="lineCov">       6052 :         ret = btrfs_search_slot(NULL, fs_root, &amp;key, path, 0, 0);</span>
<span class="lineNum">    2651 </span><span class="lineCov">       6052 :         if ((ret &lt; 0) || (found_key == NULL)) {</span>
<span class="lineNum">    2652 </span><span class="lineCov">        821 :                 if (path != found_path)</span>
<span class="lineNum">    2653 </span><span class="lineCov">        616 :                         btrfs_free_path(path);</span>
<span class="lineNum">    2654 </span><span class="lineCov">        821 :                 return ret;</span>
<span class="lineNum">    2655 </span>            :         }
<span class="lineNum">    2656 </span>            : 
<span class="lineNum">    2657 </span><span class="lineCov">       5231 :         eb = path-&gt;nodes[0];</span>
<span class="lineNum">    2658 </span><span class="lineCov">      10458 :         if (ret &amp;&amp; path-&gt;slots[0] &gt;= btrfs_header_nritems(eb)) {</span>
<span class="lineNum">    2659 </span>            :                 ret = btrfs_next_leaf(fs_root, path);
<span class="lineNum">    2660 </span><span class="lineCov">         26 :                 if (ret)</span>
<span class="lineNum">    2661 </span>            :                         return ret;
<span class="lineNum">    2662 </span><span class="lineCov">         26 :                 eb = path-&gt;nodes[0];</span>
<span class="lineNum">    2663 </span>            :         }
<span class="lineNum">    2664 </span>            : 
<span class="lineNum">    2665 </span><span class="lineCov">       5231 :         btrfs_item_key_to_cpu(eb, found_key, path-&gt;slots[0]);</span>
<span class="lineNum">    2666 </span><span class="lineCov">       9999 :         if (found_key-&gt;type != key.type ||</span>
<span class="lineNum">    2667 </span><span class="lineCov">       4768 :                         found_key-&gt;objectid != key.objectid)</span>
<span class="lineNum">    2668 </span>            :                 return 1;
<span class="lineNum">    2669 </span>            : 
<span class="lineNum">    2670 </span><span class="lineCov">       4768 :         return 0;</span>
<span class="lineNum">    2671 </span>            : }
<span class="lineNum">    2672 </span>            : 
<span class="lineNum">    2673 </span>            : /*
<span class="lineNum">    2674 </span>            :  * look for key in the tree.  path is filled in with nodes along the way
<span class="lineNum">    2675 </span>            :  * if key is found, we return zero and you can find the item in the leaf
<span class="lineNum">    2676 </span>            :  * level of the path (level 0)
<span class="lineNum">    2677 </span>            :  *
<span class="lineNum">    2678 </span>            :  * If the key isn't found, the path points to the slot where it should
<span class="lineNum">    2679 </span>            :  * be inserted, and 1 is returned.  If there are other errors during the
<span class="lineNum">    2680 </span>            :  * search a negative error number is returned.
<span class="lineNum">    2681 </span>            :  *
<span class="lineNum">    2682 </span>            :  * if ins_len &gt; 0, nodes and leaves will be split as we walk down the
<span class="lineNum">    2683 </span>            :  * tree.  if ins_len &lt; 0, nodes will be merged as we walk down the tree (if
<span class="lineNum">    2684 </span>            :  * possible)
<span class="lineNum">    2685 </span>            :  */
<span class="lineNum">    2686 </span><span class="lineCov">    2713725 : int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root</span>
<span class="lineNum">    2687 </span>            :                       *root, struct btrfs_key *key, struct btrfs_path *p, int
<span class="lineNum">    2688 </span>            :                       ins_len, int cow)
<span class="lineNum">    2689 </span>            : {
<span class="lineNum">    2690 </span>            :         struct extent_buffer *b;
<span class="lineNum">    2691 </span>            :         int slot;
<span class="lineNum">    2692 </span>            :         int ret;
<span class="lineNum">    2693 </span>            :         int err;
<span class="lineNum">    2694 </span>            :         int level;
<span class="lineNum">    2695 </span>            :         int lowest_unlock = 1;
<span class="lineNum">    2696 </span>            :         int root_lock;
<span class="lineNum">    2697 </span>            :         /* everything at write_lock_level or lower must be write locked */
<span class="lineNum">    2698 </span><span class="lineCov">    2713725 :         int write_lock_level = 0;</span>
<span class="lineNum">    2699 </span>            :         u8 lowest_level = 0;
<span class="lineNum">    2700 </span>            :         int min_write_lock_level;
<span class="lineNum">    2701 </span>            :         int prev_cmp;
<span class="lineNum">    2702 </span>            : 
<span class="lineNum">    2703 </span><span class="lineCov">    2713725 :         lowest_level = p-&gt;lowest_level;</span>
<span class="lineNum">    2704 </span><span class="lineCov">    2713725 :         WARN_ON(lowest_level &amp;&amp; ins_len &gt; 0);</span>
<span class="lineNum">    2705 </span><span class="lineCov">    2713711 :         WARN_ON(p-&gt;nodes[0] != NULL);</span>
<span class="lineNum">    2706 </span><span class="lineCov">    2713711 :         BUG_ON(!cow &amp;&amp; ins_len);</span>
<span class="lineNum">    2707 </span>            : 
<span class="lineNum">    2708 </span><span class="lineCov">    2713711 :         if (ins_len &lt; 0) {</span>
<span class="lineNum">    2709 </span>            :                 lowest_unlock = 2;
<span class="lineNum">    2710 </span>            : 
<span class="lineNum">    2711 </span>            :                 /* when we are removing items, we might have to go up to level
<span class="lineNum">    2712 </span>            :                  * two as we update tree pointers  Make sure we keep write
<span class="lineNum">    2713 </span>            :                  * for those levels as well
<span class="lineNum">    2714 </span>            :                  */
<span class="lineNum">    2715 </span><span class="lineCov">     215608 :                 write_lock_level = 2;</span>
<span class="lineNum">    2716 </span><span class="lineCov">    2498103 :         } else if (ins_len &gt; 0) {</span>
<span class="lineNum">    2717 </span>            :                 /*
<span class="lineNum">    2718 </span>            :                  * for inserting items, make sure we have a write lock on
<span class="lineNum">    2719 </span>            :                  * level 1 so we can update keys
<span class="lineNum">    2720 </span>            :                  */
<span class="lineNum">    2721 </span><span class="lineCov">     311751 :                 write_lock_level = 1;</span>
<span class="lineNum">    2722 </span>            :         }
<span class="lineNum">    2723 </span>            : 
<span class="lineNum">    2724 </span><span class="lineCov">    2713711 :         if (!cow)</span>
<span class="lineNum">    2725 </span><span class="lineCov">    1995650 :                 write_lock_level = -1;</span>
<span class="lineNum">    2726 </span>            : 
<span class="lineNum">    2727 </span><span class="lineCov">    2713711 :         if (cow &amp;&amp; (p-&gt;keep_locks || p-&gt;lowest_level))</span>
<span class="lineNum">    2728 </span><span class="lineCov">      17677 :                 write_lock_level = BTRFS_MAX_LEVEL;</span>
<span class="lineNum">    2729 </span>            : 
<span class="lineNum">    2730 </span><span class="lineCov">    2713711 :         min_write_lock_level = write_lock_level;</span>
<span class="lineNum">    2731 </span>            : 
<span class="lineNum">    2732 </span>            : again:
<span class="lineNum">    2733 </span>            :         prev_cmp = -1;
<span class="lineNum">    2734 </span>            :         /*
<span class="lineNum">    2735 </span>            :          * we try very hard to do read locks on the root
<span class="lineNum">    2736 </span>            :          */
<span class="lineNum">    2737 </span>            :         root_lock = BTRFS_READ_LOCK;
<span class="lineNum">    2738 </span>            :         level = 0;
<span class="lineNum">    2739 </span><span class="lineCov">    2811656 :         if (p-&gt;search_commit_root) {</span>
<span class="lineNum">    2740 </span>            :                 /*
<span class="lineNum">    2741 </span>            :                  * the commit roots are read only
<span class="lineNum">    2742 </span>            :                  * so we always do read locks
<span class="lineNum">    2743 </span>            :                  */
<span class="lineNum">    2744 </span><span class="lineCov">    1610652 :                 if (p-&gt;need_commit_sem)</span>
<span class="lineNum">    2745 </span><span class="lineCov">       7783 :                         down_read(&amp;root-&gt;fs_info-&gt;commit_root_sem);</span>
<span class="lineNum">    2746 </span><span class="lineCov">    1610652 :                 b = root-&gt;commit_root;</span>
<span class="lineNum">    2747 </span><span class="lineCov">    9582965 :                 extent_buffer_get(b);</span>
<span class="lineNum">    2748 </span><span class="lineCov">    3221362 :                 level = btrfs_header_level(b);</span>
<span class="lineNum">    2749 </span><span class="lineCov">    1610681 :                 if (p-&gt;need_commit_sem)</span>
<span class="lineNum">    2750 </span><span class="lineCov">       7783 :                         up_read(&amp;root-&gt;fs_info-&gt;commit_root_sem);</span>
<span class="lineNum">    2751 </span><span class="lineCov">    1610576 :                 if (!p-&gt;skip_locking)</span>
<span class="lineNum">    2752 </span><span class="lineNoCov">          0 :                         btrfs_tree_read_lock(b);</span>
<span class="lineNum">    2753 </span>            :         } else {
<span class="lineNum">    2754 </span><span class="lineCov">    1201004 :                 if (p-&gt;skip_locking) {</span>
<span class="lineNum">    2755 </span><span class="lineNoCov">          0 :                         b = btrfs_root_node(root);</span>
<span class="lineNum">    2756 </span><span class="lineNoCov">          0 :                         level = btrfs_header_level(b);</span>
<span class="lineNum">    2757 </span>            :                 } else {
<span class="lineNum">    2758 </span>            :                         /* we don't know the level of the root node
<span class="lineNum">    2759 </span>            :                          * until we actually have it read locked
<span class="lineNum">    2760 </span>            :                          */
<span class="lineNum">    2761 </span><span class="lineCov">    1201004 :                         b = btrfs_read_lock_root_node(root);</span>
<span class="lineNum">    2762 </span><span class="lineCov">    1201432 :                         level = btrfs_header_level(b);</span>
<span class="lineNum">    2763 </span><span class="lineCov">    1201432 :                         if (level &lt;= write_lock_level) {</span>
<span class="lineNum">    2764 </span>            :                                 /* whoops, must trade for write lock */
<span class="lineNum">    2765 </span><span class="lineCov">     632025 :                                 btrfs_tree_read_unlock(b);</span>
<span class="lineNum">    2766 </span><span class="lineCov">     632011 :                                 free_extent_buffer(b);</span>
<span class="lineNum">    2767 </span><span class="lineCov">     632021 :                                 b = btrfs_lock_root_node(root);</span>
<span class="lineNum">    2768 </span>            :                                 root_lock = BTRFS_WRITE_LOCK;
<span class="lineNum">    2769 </span>            : 
<span class="lineNum">    2770 </span>            :                                 /* the level might have changed, check again */
<span class="lineNum">    2771 </span><span class="lineCov">     632051 :                                 level = btrfs_header_level(b);</span>
<span class="lineNum">    2772 </span>            :                         }
<span class="lineNum">    2773 </span>            :                 }
<span class="lineNum">    2774 </span>            :         }
<span class="lineNum">    2775 </span><span class="lineCov">    2812034 :         p-&gt;nodes[level] = b;</span>
<span class="lineNum">    2776 </span><span class="lineCov">    2812034 :         if (!p-&gt;skip_locking)</span>
<span class="lineNum">    2777 </span><span class="lineCov">    1201364 :                 p-&gt;locks[level] = root_lock;</span>
<span class="lineNum">    2778 </span>            : 
<span class="lineNum">    2779 </span><span class="lineCov">    4991657 :         while (b) {</span>
<span class="lineNum">    2780 </span><span class="lineCov">    4990304 :                 level = btrfs_header_level(b);</span>
<span class="lineNum">    2781 </span>            : 
<span class="lineNum">    2782 </span>            :                 /*
<span class="lineNum">    2783 </span>            :                  * setup the path here so we can release it under lock
<span class="lineNum">    2784 </span>            :                  * contention with the cow code
<span class="lineNum">    2785 </span>            :                  */
<span class="lineNum">    2786 </span><span class="lineCov">    4990304 :                 if (cow) {</span>
<span class="lineNum">    2787 </span>            :                         /*
<span class="lineNum">    2788 </span>            :                          * if we don't really need to cow this block
<span class="lineNum">    2789 </span>            :                          * then we don't want to set the path blocking,
<span class="lineNum">    2790 </span>            :                          * so we test it here
<span class="lineNum">    2791 </span>            :                          */
<span class="lineNum">    2792 </span><span class="lineCov">    1534341 :                         if (!should_cow_block(trans, root, b))</span>
<span class="lineNum">    2793 </span>            :                                 goto cow_done;
<span class="lineNum">    2794 </span>            : 
<span class="lineNum">    2795 </span><span class="lineCov">      58705 :                         btrfs_set_path_blocking(p);</span>
<span class="lineNum">    2796 </span>            : 
<span class="lineNum">    2797 </span>            :                         /*
<span class="lineNum">    2798 </span>            :                          * must have write locks on this node and the
<span class="lineNum">    2799 </span>            :                          * parent
<span class="lineNum">    2800 </span>            :                          */
<span class="lineNum">    2801 </span><span class="lineCov">     115296 :                         if (level &gt; write_lock_level ||</span>
<span class="lineNum">    2802 </span><span class="lineCov">      68755 :                             (level + 1 &gt; write_lock_level &amp;&amp;</span>
<span class="lineNum">    2803 </span><span class="lineCov">      12164 :                             level + 1 &lt; BTRFS_MAX_LEVEL &amp;&amp;</span>
<span class="lineNum">    2804 </span><span class="lineCov">      12164 :                             p-&gt;nodes[level + 1])) {</span>
<span class="lineNum">    2805 </span><span class="lineCov">       9533 :                                 write_lock_level = level + 1;</span>
<span class="lineNum">    2806 </span><span class="lineCov">       9533 :                                 btrfs_release_path(p);</span>
<span class="lineNum">    2807 </span><span class="lineCov">       9533 :                                 goto again;</span>
<span class="lineNum">    2808 </span>            :                         }
<span class="lineNum">    2809 </span>            : 
<span class="lineNum">    2810 </span><span class="lineCov">      49172 :                         err = btrfs_cow_block(trans, root, b,</span>
<span class="lineNum">    2811 </span>            :                                               p-&gt;nodes[level + 1],
<span class="lineNum">    2812 </span>            :                                               p-&gt;slots[level + 1], &amp;b);
<span class="lineNum">    2813 </span><span class="lineCov">      49170 :                         if (err) {</span>
<span class="lineNum">    2814 </span>            :                                 ret = err;
<span class="lineNum">    2815 </span>            :                                 goto done;
<span class="lineNum">    2816 </span>            :                         }
<span class="lineNum">    2817 </span>            :                 }
<span class="lineNum">    2818 </span>            : cow_done:
<span class="lineNum">    2819 </span><span class="lineCov">    4981692 :                 p-&gt;nodes[level] = b;</span>
<span class="lineNum">    2820 </span><span class="lineCov">    4981692 :                 btrfs_clear_path_blocking(p, NULL, 0);</span>
<span class="lineNum">    2821 </span>            : 
<span class="lineNum">    2822 </span>            :                 /*
<span class="lineNum">    2823 </span>            :                  * we have a lock on b and as long as we aren't changing
<span class="lineNum">    2824 </span>            :                  * the tree, there is no way to for the items in b to change.
<span class="lineNum">    2825 </span>            :                  * It is safe to drop the lock on our parent before we
<span class="lineNum">    2826 </span>            :                  * go through the expensive btree search on b.
<span class="lineNum">    2827 </span>            :                  *
<span class="lineNum">    2828 </span>            :                  * If we're inserting or deleting (ins_len != 0), then we might
<span class="lineNum">    2829 </span>            :                  * be changing slot zero, which may require changing the parent.
<span class="lineNum">    2830 </span>            :                  * So, we can't drop the lock until after we know which slot
<span class="lineNum">    2831 </span>            :                  * we're operating on.
<span class="lineNum">    2832 </span>            :                  */
<span class="lineNum">    2833 </span><span class="lineCov">    4980504 :                 if (!ins_len &amp;&amp; !p-&gt;keep_locks) {</span>
<span class="lineNum">    2834 </span><span class="lineCov">    3722115 :                         int u = level + 1;</span>
<span class="lineNum">    2835 </span>            : 
<span class="lineNum">    2836 </span><span class="lineCov">    3722115 :                         if (u &lt; BTRFS_MAX_LEVEL &amp;&amp; p-&gt;locks[u]) {</span>
<span class="lineNum">    2837 </span><span class="lineCov">     569200 :                                 btrfs_tree_unlock_rw(p-&gt;nodes[u], p-&gt;locks[u]);</span>
<span class="lineNum">    2838 </span><span class="lineCov">     569254 :                                 p-&gt;locks[u] = 0;</span>
<span class="lineNum">    2839 </span>            :                         }
<span class="lineNum">    2840 </span>            :                 }
<span class="lineNum">    2841 </span>            : 
<span class="lineNum">    2842 </span><span class="lineCov">    4980558 :                 ret = key_search(b, key, level, &amp;prev_cmp, &amp;slot);</span>
<span class="lineNum">    2843 </span>            : 
<span class="lineNum">    2844 </span><span class="lineCov">    4980582 :                 if (level != 0) {</span>
<span class="lineNum">    2845 </span>            :                         int dec = 0;
<span class="lineNum">    2846 </span><span class="lineCov">    2844572 :                         if (ret &amp;&amp; slot &gt; 0) {</span>
<span class="lineNum">    2847 </span>            :                                 dec = 1;
<span class="lineNum">    2848 </span><span class="lineCov">    2251151 :                                 slot -= 1;</span>
<span class="lineNum">    2849 </span>            :                         }
<span class="lineNum">    2850 </span><span class="lineCov">    2844572 :                         p-&gt;slots[level] = slot;</span>
<span class="lineNum">    2851 </span><span class="lineCov">    2844572 :                         err = setup_nodes_for_search(trans, root, p, b, level,</span>
<span class="lineNum">    2852 </span>            :                                              ins_len, &amp;write_lock_level);
<span class="lineNum">    2853 </span><span class="lineCov">    2844566 :                         if (err == -EAGAIN)</span>
<span class="lineNum">    2854 </span>            :                                 goto again;
<span class="lineNum">    2855 </span><span class="lineCov">    2784346 :                         if (err) {</span>
<span class="lineNum">    2856 </span>            :                                 ret = err;
<span class="lineNum">    2857 </span>            :                                 goto done;
<span class="lineNum">    2858 </span>            :                         }
<span class="lineNum">    2859 </span><span class="lineCov">    2784348 :                         b = p-&gt;nodes[level];</span>
<span class="lineNum">    2860 </span><span class="lineCov">    2784348 :                         slot = p-&gt;slots[level];</span>
<span class="lineNum">    2861 </span>            : 
<span class="lineNum">    2862 </span>            :                         /*
<span class="lineNum">    2863 </span>            :                          * slot 0 is special, if we change the key
<span class="lineNum">    2864 </span>            :                          * we have to update the parent pointer
<span class="lineNum">    2865 </span>            :                          * which means we must have a write lock
<span class="lineNum">    2866 </span>            :                          * on the parent
<span class="lineNum">    2867 </span>            :                          */
<span class="lineNum">    2868 </span><span class="lineCov">    2896461 :                         if (slot == 0 &amp;&amp; ins_len &amp;&amp;</span>
<span class="lineNum">    2869 </span><span class="lineCov">     112113 :                             write_lock_level &lt; level + 1) {</span>
<span class="lineNum">    2870 </span><span class="lineCov">      27869 :                                 write_lock_level = level + 1;</span>
<span class="lineNum">    2871 </span><span class="lineCov">      27869 :                                 btrfs_release_path(p);</span>
<span class="lineNum">    2872 </span><span class="lineCov">      27868 :                                 goto again;</span>
<span class="lineNum">    2873 </span>            :                         }
<span class="lineNum">    2874 </span>            : 
<span class="lineNum">    2875 </span><span class="lineCov">    2756479 :                         unlock_up(p, level, lowest_unlock,</span>
<span class="lineNum">    2876 </span>            :                                   min_write_lock_level, &amp;write_lock_level);
<span class="lineNum">    2877 </span>            : 
<span class="lineNum">    2878 </span><span class="lineCov">    2756520 :                         if (level == lowest_level) {</span>
<span class="lineNum">    2879 </span><span class="lineCov">     577272 :                                 if (dec)</span>
<span class="lineNum">    2880 </span><span class="lineNoCov">          0 :                                         p-&gt;slots[level]++;</span>
<span class="lineNum">    2881 </span>            :                                 goto done;
<span class="lineNum">    2882 </span>            :                         }
<span class="lineNum">    2883 </span>            : 
<span class="lineNum">    2884 </span><span class="lineCov">    2179248 :                         err = read_block_for_search(trans, root, p,</span>
<span class="lineNum">    2885 </span>            :                                                     &amp;b, level, slot, key, 0);
<span class="lineNum">    2886 </span><span class="lineCov">    2179444 :                         if (err == -EAGAIN)</span>
<span class="lineNum">    2887 </span>            :                                 goto again;
<span class="lineNum">    2888 </span><span class="lineCov">    2179120 :                         if (err) {</span>
<span class="lineNum">    2889 </span>            :                                 ret = err;
<span class="lineNum">    2890 </span>            :                                 goto done;
<span class="lineNum">    2891 </span>            :                         }
<span class="lineNum">    2892 </span>            : 
<span class="lineNum">    2893 </span><span class="lineCov">    2179371 :                         if (!p-&gt;skip_locking) {</span>
<span class="lineNum">    2894 </span><span class="lineCov">    2296994 :                                 level = btrfs_header_level(b);</span>
<span class="lineNum">    2895 </span><span class="lineCov">    1148497 :                                 if (level &lt;= write_lock_level) {</span>
<span class="lineNum">    2896 </span><span class="lineCov">     701151 :                                         err = btrfs_try_tree_write_lock(b);</span>
<span class="lineNum">    2897 </span><span class="lineCov">     701355 :                                         if (!err) {</span>
<span class="lineNum">    2898 </span><span class="lineCov">       8794 :                                                 btrfs_set_path_blocking(p);</span>
<span class="lineNum">    2899 </span><span class="lineCov">       8797 :                                                 btrfs_tree_lock(b);</span>
<span class="lineNum">    2900 </span><span class="lineCov">       8799 :                                                 btrfs_clear_path_blocking(p, b,</span>
<span class="lineNum">    2901 </span>            :                                                                   BTRFS_WRITE_LOCK);
<span class="lineNum">    2902 </span>            :                                         }
<span class="lineNum">    2903 </span><span class="lineCov">     701300 :                                         p-&gt;locks[level] = BTRFS_WRITE_LOCK;</span>
<span class="lineNum">    2904 </span>            :                                 } else {
<span class="lineNum">    2905 </span><span class="lineCov">     447346 :                                         err = btrfs_try_tree_read_lock(b);</span>
<span class="lineNum">    2906 </span><span class="lineCov">     447453 :                                         if (!err) {</span>
<span class="lineNum">    2907 </span><span class="lineCov">       1171 :                                                 btrfs_set_path_blocking(p);</span>
<span class="lineNum">    2908 </span><span class="lineCov">       1171 :                                                 btrfs_tree_read_lock(b);</span>
<span class="lineNum">    2909 </span><span class="lineCov">       1171 :                                                 btrfs_clear_path_blocking(p, b,</span>
<span class="lineNum">    2910 </span>            :                                                                   BTRFS_READ_LOCK);
<span class="lineNum">    2911 </span>            :                                         }
<span class="lineNum">    2912 </span><span class="lineCov">     447449 :                                         p-&gt;locks[level] = BTRFS_READ_LOCK;</span>
<span class="lineNum">    2913 </span>            :                                 }
<span class="lineNum">    2914 </span><span class="lineCov">    1148749 :                                 p-&gt;nodes[level] = b;</span>
<span class="lineNum">    2915 </span>            :                         }
<span class="lineNum">    2916 </span>            :                 } else {
<span class="lineNum">    2917 </span><span class="lineCov">    2136010 :                         p-&gt;slots[level] = slot;</span>
<span class="lineNum">    2918 </span><span class="lineCov">    2447718 :                         if (ins_len &gt; 0 &amp;&amp;</span>
<span class="lineNum">    2919 </span><span class="lineCov">     311731 :                             btrfs_leaf_free_space(root, b) &lt; ins_len) {</span>
<span class="lineNum">    2920 </span><span class="lineCov">      13324 :                                 if (write_lock_level &lt; 1) {</span>
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :                                         write_lock_level = 1;</span>
<span class="lineNum">    2922 </span><span class="lineNoCov">          0 :                                         btrfs_release_path(p);</span>
<span class="lineNum">    2923 </span><span class="lineNoCov">          0 :                                         goto again;</span>
<span class="lineNum">    2924 </span>            :                                 }
<span class="lineNum">    2925 </span>            : 
<span class="lineNum">    2926 </span><span class="lineCov">      13324 :                                 btrfs_set_path_blocking(p);</span>
<span class="lineNum">    2927 </span><span class="lineCov">      13324 :                                 err = split_leaf(trans, root, key,</span>
<span class="lineNum">    2928 </span>            :                                                  p, ins_len, ret == 0);
<span class="lineNum">    2929 </span><span class="lineCov">      13324 :                                 btrfs_clear_path_blocking(p, NULL, 0);</span>
<span class="lineNum">    2930 </span>            : 
<span class="lineNum">    2931 </span><span class="lineCov">      13324 :                                 BUG_ON(err &gt; 0);</span>
<span class="lineNum">    2932 </span><span class="lineCov">      13324 :                                 if (err) {</span>
<span class="lineNum">    2933 </span>            :                                         ret = err;
<span class="lineNum">    2934 </span>            :                                         goto done;
<span class="lineNum">    2935 </span>            :                                 }
<span class="lineNum">    2936 </span>            :                         }
<span class="lineNum">    2937 </span><span class="lineCov">    2134241 :                         if (!p-&gt;search_for_split)</span>
<span class="lineNum">    2938 </span><span class="lineCov">    2134116 :                                 unlock_up(p, level, lowest_unlock,</span>
<span class="lineNum">    2939 </span>            :                                           min_write_lock_level, &amp;write_lock_level);
<span class="lineNum">    2940 </span>            :                         goto done;
<span class="lineNum">    2941 </span>            :                 }
<span class="lineNum">    2942 </span>            :         }
<span class="lineNum">    2943 </span>            :         ret = 1;
<span class="lineNum">    2944 </span>            : done:
<span class="lineNum">    2945 </span>            :         /*
<span class="lineNum">    2946 </span>            :          * we don't really know what they plan on doing with the path
<span class="lineNum">    2947 </span>            :          * from here on, so for now just mark it as blocking
<span class="lineNum">    2948 </span>            :          */
<span class="lineNum">    2949 </span><span class="lineCov">    2713474 :         if (!p-&gt;leave_spinning)</span>
<span class="lineNum">    2950 </span><span class="lineCov">    2234443 :                 btrfs_set_path_blocking(p);</span>
<span class="lineNum">    2951 </span><span class="lineCov">    2713702 :         if (ret &lt; 0)</span>
<span class="lineNum">    2952 </span><span class="lineCov">       1928 :                 btrfs_release_path(p);</span>
<span class="lineNum">    2953 </span><span class="lineCov">    2713702 :         return ret;</span>
<span class="lineNum">    2954 </span>            : }
<span class="lineNum">    2955 </span>            : 
<span class="lineNum">    2956 </span>            : /*
<span class="lineNum">    2957 </span>            :  * Like btrfs_search_slot, this looks for a key in the given tree. It uses the
<span class="lineNum">    2958 </span>            :  * current state of the tree together with the operations recorded in the tree
<span class="lineNum">    2959 </span>            :  * modification log to search for the key in a previous version of this tree, as
<span class="lineNum">    2960 </span>            :  * denoted by the time_seq parameter.
<span class="lineNum">    2961 </span>            :  *
<span class="lineNum">    2962 </span>            :  * Naturally, there is no support for insert, delete or cow operations.
<span class="lineNum">    2963 </span>            :  *
<span class="lineNum">    2964 </span>            :  * The resulting path and return value will be set up as if we called
<span class="lineNum">    2965 </span>            :  * btrfs_search_slot at that point in time with ins_len and cow both set to 0.
<span class="lineNum">    2966 </span>            :  */
<span class="lineNum">    2967 </span><span class="lineCov">     608193 : int btrfs_search_old_slot(struct btrfs_root *root, struct btrfs_key *key,</span>
<span class="lineNum">    2968 </span>            :                           struct btrfs_path *p, u64 time_seq)
<span class="lineNum">    2969 </span>            : {
<span class="lineNum">    2970 </span>            :         struct extent_buffer *b;
<span class="lineNum">    2971 </span>            :         int slot;
<span class="lineNum">    2972 </span>            :         int ret;
<span class="lineNum">    2973 </span>            :         int err;
<span class="lineNum">    2974 </span>            :         int level;
<span class="lineNum">    2975 </span>            :         int lowest_unlock = 1;
<span class="lineNum">    2976 </span>            :         u8 lowest_level = 0;
<span class="lineNum">    2977 </span>            :         int prev_cmp = -1;
<span class="lineNum">    2978 </span>            : 
<span class="lineNum">    2979 </span><span class="lineCov">     608193 :         lowest_level = p-&gt;lowest_level;</span>
<span class="lineNum">    2980 </span><span class="lineCov">     608193 :         WARN_ON(p-&gt;nodes[0] != NULL);</span>
<span class="lineNum">    2981 </span>            : 
<span class="lineNum">    2982 </span><span class="lineCov">     608193 :         if (p-&gt;search_commit_root) {</span>
<span class="lineNum">    2983 </span><span class="lineCov">     600267 :                 BUG_ON(time_seq);</span>
<span class="lineNum">    2984 </span><span class="lineCov">     600267 :                 return btrfs_search_slot(NULL, root, key, p, 0, 0);</span>
<span class="lineNum">    2985 </span>            :         }
<span class="lineNum">    2986 </span>            : 
<span class="lineNum">    2987 </span>            : again:
<span class="lineNum">    2988 </span><span class="lineCov">       7947 :         b = get_old_root(root, time_seq);</span>
<span class="lineNum">    2989 </span><span class="lineCov">      30217 :         level = btrfs_header_level(b);</span>
<span class="lineNum">    2990 </span><span class="lineCov">       7947 :         p-&gt;locks[level] = BTRFS_READ_LOCK;</span>
<span class="lineNum">    2991 </span>            : 
<span class="lineNum">    2992 </span><span class="lineCov">      19082 :         while (b) {</span>
<span class="lineNum">    2993 </span><span class="lineCov">      11135 :                 level = btrfs_header_level(b);</span>
<span class="lineNum">    2994 </span><span class="lineCov">      11135 :                 p-&gt;nodes[level] = b;</span>
<span class="lineNum">    2995 </span><span class="lineCov">      11135 :                 btrfs_clear_path_blocking(p, NULL, 0);</span>
<span class="lineNum">    2996 </span>            : 
<span class="lineNum">    2997 </span>            :                 /*
<span class="lineNum">    2998 </span>            :                  * we have a lock on b and as long as we aren't changing
<span class="lineNum">    2999 </span>            :                  * the tree, there is no way to for the items in b to change.
<span class="lineNum">    3000 </span>            :                  * It is safe to drop the lock on our parent before we
<span class="lineNum">    3001 </span>            :                  * go through the expensive btree search on b.
<span class="lineNum">    3002 </span>            :                  */
<span class="lineNum">    3003 </span><span class="lineCov">      11135 :                 btrfs_unlock_up_safe(p, level + 1);</span>
<span class="lineNum">    3004 </span>            : 
<span class="lineNum">    3005 </span>            :                 /*
<span class="lineNum">    3006 </span>            :                  * Since we can unwind eb's we want to do a real search every
<span class="lineNum">    3007 </span>            :                  * time.
<span class="lineNum">    3008 </span>            :                  */
<span class="lineNum">    3009 </span>            :                 prev_cmp = -1;
<span class="lineNum">    3010 </span><span class="lineCov">      11135 :                 ret = key_search(b, key, level, &amp;prev_cmp, &amp;slot);</span>
<span class="lineNum">    3011 </span>            : 
<span class="lineNum">    3012 </span><span class="lineCov">      11135 :                 if (level != 0) {</span>
<span class="lineNum">    3013 </span>            :                         int dec = 0;
<span class="lineNum">    3014 </span><span class="lineCov">       8093 :                         if (ret &amp;&amp; slot &gt; 0) {</span>
<span class="lineNum">    3015 </span>            :                                 dec = 1;
<span class="lineNum">    3016 </span><span class="lineCov">       3267 :                                 slot -= 1;</span>
<span class="lineNum">    3017 </span>            :                         }
<span class="lineNum">    3018 </span><span class="lineCov">       8093 :                         p-&gt;slots[level] = slot;</span>
<span class="lineNum">    3019 </span><span class="lineCov">       8093 :                         unlock_up(p, level, lowest_unlock, 0, NULL);</span>
<span class="lineNum">    3020 </span>            : 
<span class="lineNum">    3021 </span><span class="lineCov">       8093 :                         if (level == lowest_level) {</span>
<span class="lineNum">    3022 </span><span class="lineCov">       4884 :                                 if (dec)</span>
<span class="lineNum">    3023 </span><span class="lineCov">         90 :                                         p-&gt;slots[level]++;</span>
<span class="lineNum">    3024 </span>            :                                 goto done;
<span class="lineNum">    3025 </span>            :                         }
<span class="lineNum">    3026 </span>            : 
<span class="lineNum">    3027 </span><span class="lineCov">       3209 :                         err = read_block_for_search(NULL, root, p, &amp;b, level,</span>
<span class="lineNum">    3028 </span>            :                                                     slot, key, time_seq);
<span class="lineNum">    3029 </span><span class="lineCov">       3209 :                         if (err == -EAGAIN)</span>
<span class="lineNum">    3030 </span>            :                                 goto again;
<span class="lineNum">    3031 </span><span class="lineCov">       3188 :                         if (err) {</span>
<span class="lineNum">    3032 </span>            :                                 ret = err;
<span class="lineNum">    3033 </span>            :                                 goto done;
<span class="lineNum">    3034 </span>            :                         }
<span class="lineNum">    3035 </span>            : 
<span class="lineNum">    3036 </span><span class="lineCov">       6376 :                         level = btrfs_header_level(b);</span>
<span class="lineNum">    3037 </span><span class="lineCov">       3188 :                         err = btrfs_try_tree_read_lock(b);</span>
<span class="lineNum">    3038 </span><span class="lineCov">       3188 :                         if (!err) {</span>
<span class="lineNum">    3039 </span><span class="lineNoCov">          0 :                                 btrfs_set_path_blocking(p);</span>
<span class="lineNum">    3040 </span><span class="lineNoCov">          0 :                                 btrfs_tree_read_lock(b);</span>
<span class="lineNum">    3041 </span><span class="lineNoCov">          0 :                                 btrfs_clear_path_blocking(p, b,</span>
<span class="lineNum">    3042 </span>            :                                                           BTRFS_READ_LOCK);
<span class="lineNum">    3043 </span>            :                         }
<span class="lineNum">    3044 </span><span class="lineCov">       3188 :                         b = tree_mod_log_rewind(root-&gt;fs_info, p, b, time_seq);</span>
<span class="lineNum">    3045 </span><span class="lineCov">       3188 :                         if (!b) {</span>
<span class="lineNum">    3046 </span>            :                                 ret = -ENOMEM;
<span class="lineNum">    3047 </span>            :                                 goto done;
<span class="lineNum">    3048 </span>            :                         }
<span class="lineNum">    3049 </span><span class="lineCov">       3188 :                         p-&gt;locks[level] = BTRFS_READ_LOCK;</span>
<span class="lineNum">    3050 </span><span class="lineCov">       3188 :                         p-&gt;nodes[level] = b;</span>
<span class="lineNum">    3051 </span>            :                 } else {
<span class="lineNum">    3052 </span><span class="lineCov">       3042 :                         p-&gt;slots[level] = slot;</span>
<span class="lineNum">    3053 </span><span class="lineCov">       3042 :                         unlock_up(p, level, lowest_unlock, 0, NULL);</span>
<span class="lineNum">    3054 </span><span class="lineCov">       3042 :                         goto done;</span>
<span class="lineNum">    3055 </span>            :                 }
<span class="lineNum">    3056 </span>            :         }
<span class="lineNum">    3057 </span>            :         ret = 1;
<span class="lineNum">    3058 </span>            : done:
<span class="lineNum">    3059 </span><span class="lineCov">       7926 :         if (!p-&gt;leave_spinning)</span>
<span class="lineNum">    3060 </span><span class="lineCov">       7855 :                 btrfs_set_path_blocking(p);</span>
<span class="lineNum">    3061 </span><span class="lineCov">       7926 :         if (ret &lt; 0)</span>
<span class="lineNum">    3062 </span><span class="lineNoCov">          0 :                 btrfs_release_path(p);</span>
<span class="lineNum">    3063 </span>            : 
<span class="lineNum">    3064 </span><span class="lineCov">       7926 :         return ret;</span>
<span class="lineNum">    3065 </span>            : }
<span class="lineNum">    3066 </span>            : 
<span class="lineNum">    3067 </span>            : /*
<span class="lineNum">    3068 </span>            :  * helper to use instead of search slot if no exact match is needed but
<span class="lineNum">    3069 </span>            :  * instead the next or previous item should be returned.
<span class="lineNum">    3070 </span>            :  * When find_higher is true, the next higher item is returned, the next lower
<span class="lineNum">    3071 </span>            :  * otherwise.
<span class="lineNum">    3072 </span>            :  * When return_any and find_higher are both true, and no higher item is found,
<span class="lineNum">    3073 </span>            :  * return the next lower instead.
<span class="lineNum">    3074 </span>            :  * When return_any is true and find_higher is false, and no lower item is found,
<span class="lineNum">    3075 </span>            :  * return the next higher instead.
<span class="lineNum">    3076 </span>            :  * It returns 0 if any item is found, 1 if none is found (tree empty), and
<a name="3077"><span class="lineNum">    3077 </span>            :  * &lt; 0 on error</a>
<span class="lineNum">    3078 </span>            :  */
<span class="lineNum">    3079 </span><span class="lineCov">       1085 : int btrfs_search_slot_for_read(struct btrfs_root *root,</span>
<span class="lineNum">    3080 </span>            :                                struct btrfs_key *key, struct btrfs_path *p,
<span class="lineNum">    3081 </span>            :                                int find_higher, int return_any)
<span class="lineNum">    3082 </span>            : {
<span class="lineNum">    3083 </span>            :         int ret;
<span class="lineNum">    3084 </span><span class="lineCov">       1007 :         struct extent_buffer *leaf;</span>
<span class="lineNum">    3085 </span>            : 
<span class="lineNum">    3086 </span>            : again:
<span class="lineNum">    3087 </span><span class="lineCov">       1085 :         ret = btrfs_search_slot(NULL, root, key, p, 0, 0);</span>
<span class="lineNum">    3088 </span><span class="lineCov">       1085 :         if (ret &lt;= 0)</span>
<span class="lineNum">    3089 </span>            :                 return ret;
<span class="lineNum">    3090 </span>            :         /*
<span class="lineNum">    3091 </span>            :          * a return value of 1 means the path is at the position where the
<span class="lineNum">    3092 </span>            :          * item should be inserted. Normally this is the next bigger item,
<span class="lineNum">    3093 </span>            :          * but in case the previous item is the last in a leaf, path points
<span class="lineNum">    3094 </span>            :          * to the first free slot in the previous leaf, i.e. at an invalid
<span class="lineNum">    3095 </span>            :          * item.
<span class="lineNum">    3096 </span>            :          */
<span class="lineNum">    3097 </span><span class="lineCov">       1056 :         leaf = p-&gt;nodes[0];</span>
<span class="lineNum">    3098 </span>            : 
<span class="lineNum">    3099 </span><span class="lineCov">       1056 :         if (find_higher) {</span>
<span class="lineNum">    3100 </span><span class="lineCov">       2014 :                 if (p-&gt;slots[0] &gt;= btrfs_header_nritems(leaf)) {</span>
<span class="lineNum">    3101 </span>            :                         ret = btrfs_next_leaf(root, p);
<span class="lineNum">    3102 </span><span class="lineCov">         73 :                         if (ret &lt;= 0)</span>
<span class="lineNum">    3103 </span>            :                                 return ret;
<span class="lineNum">    3104 </span><span class="lineCov">         16 :                         if (!return_any)</span>
<span class="lineNum">    3105 </span>            :                                 return 1;
<span class="lineNum">    3106 </span>            :                         /*
<span class="lineNum">    3107 </span>            :                          * no higher item found, return the next
<span class="lineNum">    3108 </span>            :                          * lower instead
<span class="lineNum">    3109 </span>            :                          */
<span class="lineNum">    3110 </span>            :                         return_any = 0;
<span class="lineNum">    3111 </span>            :                         find_higher = 0;
<span class="lineNum">    3112 </span><span class="lineNoCov">          0 :                         btrfs_release_path(p);</span>
<span class="lineNum">    3113 </span><span class="lineNoCov">          0 :                         goto again;</span>
<span class="lineNum">    3114 </span>            :                 }
<span class="lineNum">    3115 </span>            :         } else {
<span class="lineNum">    3116 </span><span class="lineCov">         49 :                 if (p-&gt;slots[0] == 0) {</span>
<span class="lineNum">    3117 </span><span class="lineNoCov">          0 :                         ret = btrfs_prev_leaf(root, p);</span>
<span class="lineNum">    3118 </span><span class="lineNoCov">          0 :                         if (ret &lt; 0)</span>
<span class="lineNum">    3119 </span>            :                                 return ret;
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :                         if (!ret) {</span>
<span class="lineNum">    3121 </span><span class="lineNoCov">          0 :                                 leaf = p-&gt;nodes[0];</span>
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :                                 if (p-&gt;slots[0] == btrfs_header_nritems(leaf))</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :                                         p-&gt;slots[0]--;</span>
<span class="lineNum">    3124 </span>            :                                 return 0;
<span class="lineNum">    3125 </span>            :                         }
<span class="lineNum">    3126 </span><span class="lineNoCov">          0 :                         if (!return_any)</span>
<span class="lineNum">    3127 </span>            :                                 return 1;
<span class="lineNum">    3128 </span>            :                         /*
<span class="lineNum">    3129 </span>            :                          * no lower item found, return the next
<span class="lineNum">    3130 </span>            :                          * higher instead
<span class="lineNum">    3131 </span>            :                          */
<span class="lineNum">    3132 </span>            :                         return_any = 0;
<span class="lineNum">    3133 </span>            :                         find_higher = 1;
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 :                         btrfs_release_path(p);</span>
<span class="lineNum">    3135 </span><span class="lineNoCov">          0 :                         goto again;</span>
<span class="lineNum">    3136 </span>            :                 } else {
<span class="lineNum">    3137 </span><span class="lineCov">         49 :                         --p-&gt;slots[0];</span>
<span class="lineNum">    3138 </span>            :                 }
<span class="lineNum">    3139 </span>            :         }
<span class="lineNum">    3140 </span>            :         return 0;
<span class="lineNum">    3141 </span>            : }
<span class="lineNum">    3142 </span>            : 
<span class="lineNum">    3143 </span>            : /*
<span class="lineNum">    3144 </span>            :  * adjust the pointers going up the tree, starting at level
<span class="lineNum">    3145 </span>            :  * making sure the right key of each node is points to 'key'.
<span class="lineNum">    3146 </span>            :  * This is used after shifting pointers to the left, so it stops
<span class="lineNum">    3147 </span>            :  * fixing up pointers when a given leaf/node is not in slot 0 of the
<span class="lineNum">    3148 </span>            :  * higher levels
<a name="3149"><span class="lineNum">    3149 </span>            :  *</a>
<span class="lineNum">    3150 </span>            :  */
<span class="lineNum">    3151 </span><span class="lineCov">      15232 : static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,</span>
<span class="lineNum">    3152 </span>            :                            struct btrfs_disk_key *key, int level)
<span class="lineNum">    3153 </span>            : {
<span class="lineNum">    3154 </span>            :         int i;
<span class="lineNum">    3155 </span>            :         struct extent_buffer *t;
<span class="lineNum">    3156 </span>            : 
<span class="lineNum">    3157 </span><span class="lineCov">       2593 :         for (i = level; i &lt; BTRFS_MAX_LEVEL; i++) {</span>
<span class="lineNum">    3158 </span><span class="lineCov">      17825 :                 int tslot = path-&gt;slots[i];</span>
<span class="lineNum">    3159 </span><span class="lineCov">      17825 :                 if (!path-&gt;nodes[i])</span>
<span class="lineNum">    3160 </span>            :                         break;
<span class="lineNum">    3161 </span>            :                 t = path-&gt;nodes[i];
<span class="lineNum">    3162 </span><span class="lineCov">      13604 :                 tree_mod_log_set_node_key(root-&gt;fs_info, t, tslot, 1);</span>
<span class="lineNum">    3163 </span>            :                 btrfs_set_node_key(t, key, tslot);
<span class="lineNum">    3164 </span><span class="lineCov">      13604 :                 btrfs_mark_buffer_dirty(path-&gt;nodes[i]);</span>
<span class="lineNum">    3165 </span><span class="lineCov">      13604 :                 if (tslot != 0)</span>
<span class="lineNum">    3166 </span>            :                         break;
<span class="lineNum">    3167 </span>            :         }
<span class="lineNum">    3168 </span><span class="lineCov">      15232 : }</span>
<span class="lineNum">    3169 </span>            : 
<span class="lineNum">    3170 </span>            : /*
<span class="lineNum">    3171 </span>            :  * update item key.
<span class="lineNum">    3172 </span>            :  *
<span class="lineNum">    3173 </span>            :  * This function isn't completely safe. It's the caller's responsibility
<span class="lineNum">    3174 </span>            :  * that the new key won't break the order
<span class="lineNum">    3175 </span>            :  */
<span class="lineNum">    3176 </span><span class="lineCov">       8488 : void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,</span>
<span class="lineNum">    3177 </span>            :                              struct btrfs_key *new_key)
<span class="lineNum">    3178 </span>            : {
<span class="lineNum">    3179 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    3180 </span><span class="lineCov">       8488 :         struct extent_buffer *eb;</span>
<span class="lineNum">    3181 </span>            :         int slot;
<span class="lineNum">    3182 </span>            : 
<span class="lineNum">    3183 </span><span class="lineCov">       8488 :         eb = path-&gt;nodes[0];</span>
<span class="lineNum">    3184 </span><span class="lineCov">       8488 :         slot = path-&gt;slots[0];</span>
<span class="lineNum">    3185 </span><span class="lineCov">       8488 :         if (slot &gt; 0) {</span>
<span class="lineNum">    3186 </span><span class="lineCov">       7328 :                 btrfs_item_key(eb, &amp;disk_key, slot - 1);</span>
<span class="lineNum">    3187 </span><span class="lineCov">       7328 :                 BUG_ON(comp_keys(&amp;disk_key, new_key) &gt;= 0);</span>
<span class="lineNum">    3188 </span>            :         }
<span class="lineNum">    3189 </span><span class="lineCov">      16976 :         if (slot &lt; btrfs_header_nritems(eb) - 1) {</span>
<span class="lineNum">    3190 </span><span class="lineCov">       7257 :                 btrfs_item_key(eb, &amp;disk_key, slot + 1);</span>
<span class="lineNum">    3191 </span><span class="lineCov">       7257 :                 BUG_ON(comp_keys(&amp;disk_key, new_key) &lt;= 0);</span>
<span class="lineNum">    3192 </span>            :         }
<span class="lineNum">    3193 </span>            : 
<span class="lineNum">    3194 </span>            :         btrfs_cpu_key_to_disk(&amp;disk_key, new_key);
<span class="lineNum">    3195 </span>            :         btrfs_set_item_key(eb, &amp;disk_key, slot);
<span class="lineNum">    3196 </span><span class="lineCov">       8488 :         btrfs_mark_buffer_dirty(eb);</span>
<span class="lineNum">    3197 </span><span class="lineCov">       8488 :         if (slot == 0)</span>
<span class="lineNum">    3198 </span><span class="lineCov">       1160 :                 fixup_low_keys(root, path, &amp;disk_key, 1);</span>
<span class="lineNum">    3199 </span><span class="lineCov">       8488 : }</span>
<span class="lineNum">    3200 </span>            : 
<span class="lineNum">    3201 </span>            : /*
<span class="lineNum">    3202 </span>            :  * try to push data from one node into the next node left in the
<span class="lineNum">    3203 </span>            :  * tree.
<span class="lineNum">    3204 </span>            :  *
<span class="lineNum">    3205 </span>            :  * returns 0 if some ptrs were pushed left, &lt; 0 if there was some horrible
<a name="3206"><span class="lineNum">    3206 </span>            :  * error, and &gt; 0 if there was no room in the left hand block.</a>
<span class="lineNum">    3207 </span>            :  */
<span class="lineNum">    3208 </span><span class="lineCov">        114 : static int push_node_left(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    3209 </span><span class="lineCov">        342 :                           struct btrfs_root *root, struct extent_buffer *dst,</span>
<span class="lineNum">    3210 </span><span class="lineCov">        228 :                           struct extent_buffer *src, int empty)</span>
<span class="lineNum">    3211 </span>            : {
<span class="lineNum">    3212 </span>            :         int push_items = 0;
<span class="lineNum">    3213 </span>            :         int src_nritems;
<span class="lineNum">    3214 </span>            :         int dst_nritems;
<span class="lineNum">    3215 </span>            :         int ret = 0;
<span class="lineNum">    3216 </span>            : 
<span class="lineNum">    3217 </span><span class="lineCov">        114 :         src_nritems = btrfs_header_nritems(src);</span>
<span class="lineNum">    3218 </span><span class="lineCov">        114 :         dst_nritems = btrfs_header_nritems(dst);</span>
<span class="lineNum">    3219 </span><span class="lineCov">        114 :         push_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;</span>
<span class="lineNum">    3220 </span><span class="lineCov">        114 :         WARN_ON(btrfs_header_generation(src) != trans-&gt;transid);</span>
<span class="lineNum">    3221 </span><span class="lineCov">        114 :         WARN_ON(btrfs_header_generation(dst) != trans-&gt;transid);</span>
<span class="lineNum">    3222 </span>            : 
<span class="lineNum">    3223 </span><span class="lineCov">        114 :         if (!empty &amp;&amp; src_nritems &lt;= 8)</span>
<span class="lineNum">    3224 </span>            :                 return 1;
<span class="lineNum">    3225 </span>            : 
<span class="lineNum">    3226 </span><span class="lineCov">        114 :         if (push_items &lt;= 0)</span>
<span class="lineNum">    3227 </span>            :                 return 1;
<span class="lineNum">    3228 </span>            : 
<span class="lineNum">    3229 </span><span class="lineCov">        114 :         if (empty) {</span>
<span class="lineNum">    3230 </span><span class="lineCov">         17 :                 push_items = min(src_nritems, push_items);</span>
<span class="lineNum">    3231 </span><span class="lineCov">         17 :                 if (push_items &lt; src_nritems) {</span>
<span class="lineNum">    3232 </span>            :                         /* leave at least 8 pointers in the node if
<span class="lineNum">    3233 </span>            :                          * we aren't going to empty it
<span class="lineNum">    3234 </span>            :                          */
<span class="lineNum">    3235 </span><span class="lineNoCov">          0 :                         if (src_nritems - push_items &lt; 8) {</span>
<span class="lineNum">    3236 </span><span class="lineNoCov">          0 :                                 if (push_items &lt;= 8)</span>
<span class="lineNum">    3237 </span>            :                                         return 1;
<span class="lineNum">    3238 </span><span class="lineNoCov">          0 :                                 push_items -= 8;</span>
<span class="lineNum">    3239 </span>            :                         }
<span class="lineNum">    3240 </span>            :                 }
<span class="lineNum">    3241 </span>            :         } else
<span class="lineNum">    3242 </span><span class="lineCov">         97 :                 push_items = min(src_nritems - 8, push_items);</span>
<span class="lineNum">    3243 </span>            : 
<span class="lineNum">    3244 </span><span class="lineCov">        114 :         ret = tree_mod_log_eb_copy(root-&gt;fs_info, dst, src, dst_nritems, 0,</span>
<span class="lineNum">    3245 </span>            :                                    push_items);
<span class="lineNum">    3246 </span><span class="lineCov">        114 :         if (ret) {</span>
<span class="lineNum">    3247 </span><span class="lineNoCov">          0 :                 btrfs_abort_transaction(trans, root, ret);</span>
<span class="lineNum">    3248 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    3249 </span>            :         }
<span class="lineNum">    3250 </span><span class="lineCov">        228 :         copy_extent_buffer(dst, src,</span>
<span class="lineNum">    3251 </span>            :                            btrfs_node_key_ptr_offset(dst_nritems),
<span class="lineNum">    3252 </span>            :                            btrfs_node_key_ptr_offset(0),
<span class="lineNum">    3253 </span>            :                            push_items * sizeof(struct btrfs_key_ptr));
<span class="lineNum">    3254 </span>            : 
<span class="lineNum">    3255 </span><span class="lineCov">        114 :         if (push_items &lt; src_nritems) {</span>
<span class="lineNum">    3256 </span>            :                 /*
<span class="lineNum">    3257 </span>            :                  * don't call tree_mod_log_eb_move here, key removal was already
<span class="lineNum">    3258 </span>            :                  * fully logged by tree_mod_log_eb_copy above.
<span class="lineNum">    3259 </span>            :                  */
<span class="lineNum">    3260 </span><span class="lineCov">        194 :                 memmove_extent_buffer(src, btrfs_node_key_ptr_offset(0),</span>
<span class="lineNum">    3261 </span>            :                                       btrfs_node_key_ptr_offset(push_items),
<span class="lineNum">    3262 </span><span class="lineCov">         97 :                                       (src_nritems - push_items) *</span>
<span class="lineNum">    3263 </span>            :                                       sizeof(struct btrfs_key_ptr));
<span class="lineNum">    3264 </span>            :         }
<span class="lineNum">    3265 </span><span class="lineCov">        114 :         btrfs_set_header_nritems(src, src_nritems - push_items);</span>
<span class="lineNum">    3266 </span><span class="lineCov">        114 :         btrfs_set_header_nritems(dst, dst_nritems + push_items);</span>
<span class="lineNum">    3267 </span><span class="lineCov">        114 :         btrfs_mark_buffer_dirty(src);</span>
<span class="lineNum">    3268 </span><span class="lineCov">        114 :         btrfs_mark_buffer_dirty(dst);</span>
<span class="lineNum">    3269 </span>            : 
<span class="lineNum">    3270 </span><span class="lineCov">        114 :         return ret;</span>
<span class="lineNum">    3271 </span>            : }
<span class="lineNum">    3272 </span>            : 
<span class="lineNum">    3273 </span>            : /*
<span class="lineNum">    3274 </span>            :  * try to push data from one node into the next node right in the
<span class="lineNum">    3275 </span>            :  * tree.
<span class="lineNum">    3276 </span>            :  *
<span class="lineNum">    3277 </span>            :  * returns 0 if some ptrs were pushed, &lt; 0 if there was some horrible
<span class="lineNum">    3278 </span>            :  * error, and &gt; 0 if there was no room in the right hand block.
<span class="lineNum">    3279 </span>            :  *
<a name="3280"><span class="lineNum">    3280 </span>            :  * this will  only push up to 1/2 the contents of the left node over</a>
<span class="lineNum">    3281 </span>            :  */
<span class="lineNum">    3282 </span><span class="lineCov">         65 : static int balance_node_right(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    3283 </span>            :                               struct btrfs_root *root,
<span class="lineNum">    3284 </span><span class="lineCov">        195 :                               struct extent_buffer *dst,</span>
<span class="lineNum">    3285 </span><span class="lineCov">        195 :                               struct extent_buffer *src)</span>
<span class="lineNum">    3286 </span>            : {
<span class="lineNum">    3287 </span>            :         int push_items = 0;
<span class="lineNum">    3288 </span>            :         int max_push;
<span class="lineNum">    3289 </span>            :         int src_nritems;
<span class="lineNum">    3290 </span>            :         int dst_nritems;
<span class="lineNum">    3291 </span>            :         int ret = 0;
<span class="lineNum">    3292 </span>            : 
<span class="lineNum">    3293 </span><span class="lineCov">         65 :         WARN_ON(btrfs_header_generation(src) != trans-&gt;transid);</span>
<span class="lineNum">    3294 </span><span class="lineCov">         65 :         WARN_ON(btrfs_header_generation(dst) != trans-&gt;transid);</span>
<span class="lineNum">    3295 </span>            : 
<span class="lineNum">    3296 </span><span class="lineCov">         65 :         src_nritems = btrfs_header_nritems(src);</span>
<span class="lineNum">    3297 </span><span class="lineCov">         65 :         dst_nritems = btrfs_header_nritems(dst);</span>
<span class="lineNum">    3298 </span><span class="lineCov">         65 :         push_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;</span>
<span class="lineNum">    3299 </span><span class="lineCov">         65 :         if (push_items &lt;= 0)</span>
<span class="lineNum">    3300 </span>            :                 return 1;
<span class="lineNum">    3301 </span>            : 
<span class="lineNum">    3302 </span><span class="lineCov">         65 :         if (src_nritems &lt; 4)</span>
<span class="lineNum">    3303 </span>            :                 return 1;
<span class="lineNum">    3304 </span>            : 
<span class="lineNum">    3305 </span><span class="lineCov">         65 :         max_push = src_nritems / 2 + 1;</span>
<span class="lineNum">    3306 </span>            :         /* don't try to empty the node */
<span class="lineNum">    3307 </span><span class="lineCov">         65 :         if (max_push &gt;= src_nritems)</span>
<span class="lineNum">    3308 </span>            :                 return 1;
<span class="lineNum">    3309 </span>            : 
<span class="lineNum">    3310 </span><span class="lineCov">         65 :         if (max_push &lt; push_items)</span>
<span class="lineNum">    3311 </span>            :                 push_items = max_push;
<span class="lineNum">    3312 </span>            : 
<span class="lineNum">    3313 </span><span class="lineCov">         65 :         tree_mod_log_eb_move(root-&gt;fs_info, dst, push_items, 0, dst_nritems);</span>
<span class="lineNum">    3314 </span><span class="lineCov">        130 :         memmove_extent_buffer(dst, btrfs_node_key_ptr_offset(push_items),</span>
<span class="lineNum">    3315 </span>            :                                       btrfs_node_key_ptr_offset(0),
<span class="lineNum">    3316 </span>            :                                       (dst_nritems) *
<span class="lineNum">    3317 </span>            :                                       sizeof(struct btrfs_key_ptr));
<span class="lineNum">    3318 </span>            : 
<span class="lineNum">    3319 </span><span class="lineCov">         65 :         ret = tree_mod_log_eb_copy(root-&gt;fs_info, dst, src, 0,</span>
<span class="lineNum">    3320 </span><span class="lineCov">         65 :                                    src_nritems - push_items, push_items);</span>
<span class="lineNum">    3321 </span><span class="lineCov">         65 :         if (ret) {</span>
<span class="lineNum">    3322 </span><span class="lineNoCov">          0 :                 btrfs_abort_transaction(trans, root, ret);</span>
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    3324 </span>            :         }
<span class="lineNum">    3325 </span><span class="lineCov">         65 :         copy_extent_buffer(dst, src,</span>
<span class="lineNum">    3326 </span>            :                            btrfs_node_key_ptr_offset(0),
<span class="lineNum">    3327 </span>            :                            btrfs_node_key_ptr_offset(src_nritems - push_items),
<span class="lineNum">    3328 </span>            :                            push_items * sizeof(struct btrfs_key_ptr));
<span class="lineNum">    3329 </span>            : 
<span class="lineNum">    3330 </span><span class="lineCov">         65 :         btrfs_set_header_nritems(src, src_nritems - push_items);</span>
<span class="lineNum">    3331 </span><span class="lineCov">         65 :         btrfs_set_header_nritems(dst, dst_nritems + push_items);</span>
<span class="lineNum">    3332 </span>            : 
<span class="lineNum">    3333 </span><span class="lineCov">         65 :         btrfs_mark_buffer_dirty(src);</span>
<span class="lineNum">    3334 </span><span class="lineCov">         65 :         btrfs_mark_buffer_dirty(dst);</span>
<span class="lineNum">    3335 </span>            : 
<span class="lineNum">    3336 </span><span class="lineCov">         65 :         return ret;</span>
<span class="lineNum">    3337 </span>            : }
<span class="lineNum">    3338 </span>            : 
<span class="lineNum">    3339 </span>            : /*
<span class="lineNum">    3340 </span>            :  * helper function to insert a new root level in the tree.
<span class="lineNum">    3341 </span>            :  * A new node is allocated, and a single item is inserted to
<span class="lineNum">    3342 </span>            :  * point to the existing root
<span class="lineNum">    3343 </span>            :  *
<span class="lineNum">    3344 </span>            :  * returns zero on success or &lt; 0 on failure.
<span class="lineNum">    3345 </span>            :  */
<span class="lineNum">    3346 </span><span class="lineCov">         99 : static noinline int insert_new_root(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    3347 </span><span class="lineCov">         99 :                            struct btrfs_root *root,</span>
<span class="lineNum">    3348 </span>            :                            struct btrfs_path *path, int level)
<span class="lineNum">    3349 </span>            : {
<span class="lineNum">    3350 </span>            :         u64 lower_gen;
<span class="lineNum">    3351 </span><span class="lineCov">         99 :         struct extent_buffer *lower;</span>
<span class="lineNum">    3352 </span><span class="lineCov">        495 :         struct extent_buffer *c;</span>
<span class="lineNum">    3353 </span>            :         struct extent_buffer *old;
<span class="lineNum">    3354 </span>            :         struct btrfs_disk_key lower_key;
<span class="lineNum">    3355 </span>            : 
<span class="lineNum">    3356 </span><span class="lineCov">         99 :         BUG_ON(path-&gt;nodes[level]);</span>
<span class="lineNum">    3357 </span><span class="lineCov">         99 :         BUG_ON(path-&gt;nodes[level-1] != root-&gt;node);</span>
<span class="lineNum">    3358 </span>            : 
<span class="lineNum">    3359 </span>            :         lower = path-&gt;nodes[level-1];
<span class="lineNum">    3360 </span><span class="lineCov">         99 :         if (level == 1)</span>
<span class="lineNum">    3361 </span>            :                 btrfs_item_key(lower, &amp;lower_key, 0);
<span class="lineNum">    3362 </span>            :         else
<span class="lineNum">    3363 </span><span class="lineCov">          3 :                 btrfs_node_key(lower, &amp;lower_key, 0);</span>
<span class="lineNum">    3364 </span>            : 
<span class="lineNum">    3365 </span><span class="lineCov">         99 :         c = btrfs_alloc_free_block(trans, root, root-&gt;nodesize, 0,</span>
<span class="lineNum">    3366 </span>            :                                    root-&gt;root_key.objectid, &amp;lower_key,
<span class="lineNum">    3367 </span><span class="lineCov">         99 :                                    level, root-&gt;node-&gt;start, 0);</span>
<span class="lineNum">    3368 </span><span class="lineCov">         99 :         if (IS_ERR(c))</span>
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :                 return PTR_ERR(c);</span>
<span class="lineNum">    3370 </span>            : 
<span class="lineNum">    3371 </span><span class="lineCov">         99 :         root_add_used(root, root-&gt;nodesize);</span>
<span class="lineNum">    3372 </span>            : 
<span class="lineNum">    3373 </span><span class="lineCov">         99 :         memset_extent_buffer(c, 0, 0, sizeof(struct btrfs_header));</span>
<span class="lineNum">    3374 </span>            :         btrfs_set_header_nritems(c, 1);
<span class="lineNum">    3375 </span><span class="lineCov">         99 :         btrfs_set_header_level(c, level);</span>
<span class="lineNum">    3376 </span><span class="lineCov">         99 :         btrfs_set_header_bytenr(c, c-&gt;start);</span>
<span class="lineNum">    3377 </span><span class="lineCov">         99 :         btrfs_set_header_generation(c, trans-&gt;transid);</span>
<span class="lineNum">    3378 </span>            :         btrfs_set_header_backref_rev(c, BTRFS_MIXED_BACKREF_REV);
<span class="lineNum">    3379 </span><span class="lineCov">         99 :         btrfs_set_header_owner(c, root-&gt;root_key.objectid);</span>
<span class="lineNum">    3380 </span>            : 
<span class="lineNum">    3381 </span><span class="lineCov">         99 :         write_extent_buffer(c, root-&gt;fs_info-&gt;fsid, btrfs_header_fsid(),</span>
<span class="lineNum">    3382 </span>            :                             BTRFS_FSID_SIZE);
<span class="lineNum">    3383 </span>            : 
<span class="lineNum">    3384 </span><span class="lineCov">         99 :         write_extent_buffer(c, root-&gt;fs_info-&gt;chunk_tree_uuid,</span>
<span class="lineNum">    3385 </span>            :                             btrfs_header_chunk_tree_uuid(c), BTRFS_UUID_SIZE);
<span class="lineNum">    3386 </span>            : 
<span class="lineNum">    3387 </span>            :         btrfs_set_node_key(c, &amp;lower_key, 0);
<span class="lineNum">    3388 </span><span class="lineCov">         99 :         btrfs_set_node_blockptr(c, 0, lower-&gt;start);</span>
<span class="lineNum">    3389 </span>            :         lower_gen = btrfs_header_generation(lower);
<span class="lineNum">    3390 </span><span class="lineCov">         99 :         WARN_ON(lower_gen != trans-&gt;transid);</span>
<span class="lineNum">    3391 </span>            : 
<span class="lineNum">    3392 </span>            :         btrfs_set_node_ptr_generation(c, 0, lower_gen);
<span class="lineNum">    3393 </span>            : 
<span class="lineNum">    3394 </span><span class="lineCov">         99 :         btrfs_mark_buffer_dirty(c);</span>
<span class="lineNum">    3395 </span>            : 
<span class="lineNum">    3396 </span><span class="lineCov">         99 :         old = root-&gt;node;</span>
<span class="lineNum">    3397 </span><span class="lineCov">         99 :         tree_mod_log_set_root_pointer(root, c, 0);</span>
<span class="lineNum">    3398 </span><span class="lineCov">         99 :         rcu_assign_pointer(root-&gt;node, c);</span>
<span class="lineNum">    3399 </span>            : 
<span class="lineNum">    3400 </span>            :         /* the super has an extra ref to root-&gt;node */
<span class="lineNum">    3401 </span><span class="lineCov">         99 :         free_extent_buffer(old);</span>
<span class="lineNum">    3402 </span>            : 
<span class="lineNum">    3403 </span><span class="lineCov">         99 :         add_root_to_dirty_list(root);</span>
<span class="lineNum">    3404 </span>            :         extent_buffer_get(c);
<span class="lineNum">    3405 </span><span class="lineCov">         99 :         path-&gt;nodes[level] = c;</span>
<span class="lineNum">    3406 </span><span class="lineCov">         99 :         path-&gt;locks[level] = BTRFS_WRITE_LOCK;</span>
<span class="lineNum">    3407 </span><span class="lineCov">         99 :         path-&gt;slots[level] = 0;</span>
<span class="lineNum">    3408 </span><span class="lineCov">         99 :         return 0;</span>
<span class="lineNum">    3409 </span>            : }
<span class="lineNum">    3410 </span>            : 
<span class="lineNum">    3411 </span>            : /*
<span class="lineNum">    3412 </span>            :  * worker function to insert a single pointer in a node.
<span class="lineNum">    3413 </span>            :  * the node should have enough room for the pointer already
<span class="lineNum">    3414 </span>            :  *
<span class="lineNum">    3415 </span>            :  * slot and level indicate where you want the key to go, and
<a name="3416"><span class="lineNum">    3416 </span>            :  * blocknr is the block the key points to.</a>
<span class="lineNum">    3417 </span>            :  */
<span class="lineNum">    3418 </span><span class="lineCov">       5312 : static void insert_ptr(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    3419 </span>            :                        struct btrfs_root *root, struct btrfs_path *path,
<span class="lineNum">    3420 </span>            :                        struct btrfs_disk_key *key, u64 bytenr,
<span class="lineNum">    3421 </span>            :                        int slot, int level)
<span class="lineNum">    3422 </span>            : {
<span class="lineNum">    3423 </span><span class="lineCov">      10624 :         struct extent_buffer *lower;</span>
<span class="lineNum">    3424 </span>            :         int nritems;
<span class="lineNum">    3425 </span>            :         int ret;
<span class="lineNum">    3426 </span>            : 
<span class="lineNum">    3427 </span><span class="lineCov">       5312 :         BUG_ON(!path-&gt;nodes[level]);</span>
<span class="lineNum">    3428 </span><span class="lineCov">       5312 :         btrfs_assert_tree_locked(path-&gt;nodes[level]);</span>
<span class="lineNum">    3429 </span><span class="lineCov">       5312 :         lower = path-&gt;nodes[level];</span>
<span class="lineNum">    3430 </span><span class="lineCov">       5312 :         nritems = btrfs_header_nritems(lower);</span>
<span class="lineNum">    3431 </span><span class="lineCov">       5312 :         BUG_ON(slot &gt; nritems);</span>
<span class="lineNum">    3432 </span><span class="lineCov">       5312 :         BUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(root));</span>
<span class="lineNum">    3433 </span><span class="lineCov">       5312 :         if (slot != nritems) {</span>
<span class="lineNum">    3434 </span><span class="lineCov">       3242 :                 if (level)</span>
<span class="lineNum">    3435 </span><span class="lineCov">       3242 :                         tree_mod_log_eb_move(root-&gt;fs_info, lower, slot + 1,</span>
<span class="lineNum">    3436 </span>            :                                              slot, nritems - slot);
<span class="lineNum">    3437 </span><span class="lineCov">       9726 :                 memmove_extent_buffer(lower,</span>
<span class="lineNum">    3438 </span>            :                               btrfs_node_key_ptr_offset(slot + 1),
<span class="lineNum">    3439 </span>            :                               btrfs_node_key_ptr_offset(slot),
<span class="lineNum">    3440 </span><span class="lineCov">       3242 :                               (nritems - slot) * sizeof(struct btrfs_key_ptr));</span>
<span class="lineNum">    3441 </span>            :         }
<span class="lineNum">    3442 </span><span class="lineCov">       5312 :         if (level) {</span>
<span class="lineNum">    3443 </span><span class="lineCov">       5312 :                 ret = tree_mod_log_insert_key(root-&gt;fs_info, lower, slot,</span>
<span class="lineNum">    3444 </span>            :                                               MOD_LOG_KEY_ADD, GFP_NOFS);
<span class="lineNum">    3445 </span><span class="lineCov">       5312 :                 BUG_ON(ret &lt; 0);</span>
<span class="lineNum">    3446 </span>            :         }
<span class="lineNum">    3447 </span>            :         btrfs_set_node_key(lower, key, slot);
<span class="lineNum">    3448 </span>            :         btrfs_set_node_blockptr(lower, slot, bytenr);
<span class="lineNum">    3449 </span><span class="lineCov">       5312 :         WARN_ON(trans-&gt;transid == 0);</span>
<span class="lineNum">    3450 </span><span class="lineCov">       5312 :         btrfs_set_node_ptr_generation(lower, slot, trans-&gt;transid);</span>
<span class="lineNum">    3451 </span><span class="lineCov">       5312 :         btrfs_set_header_nritems(lower, nritems + 1);</span>
<span class="lineNum">    3452 </span><span class="lineCov">       5312 :         btrfs_mark_buffer_dirty(lower);</span>
<span class="lineNum">    3453 </span><span class="lineCov">       5312 : }</span>
<span class="lineNum">    3454 </span>            : 
<span class="lineNum">    3455 </span>            : /*
<span class="lineNum">    3456 </span>            :  * split the node at the specified level in path in two.
<span class="lineNum">    3457 </span>            :  * The path is corrected to point to the appropriate node after the split
<span class="lineNum">    3458 </span>            :  *
<span class="lineNum">    3459 </span>            :  * Before splitting this tries to make some room in the node by pushing
<span class="lineNum">    3460 </span>            :  * left and right, if either one works, it returns right away.
<span class="lineNum">    3461 </span>            :  *
<span class="lineNum">    3462 </span>            :  * returns 0 on success and &lt; 0 on failure
<span class="lineNum">    3463 </span>            :  */
<span class="lineNum">    3464 </span><span class="lineCov">        180 : static noinline int split_node(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    3465 </span>            :                                struct btrfs_root *root,
<span class="lineNum">    3466 </span>            :                                struct btrfs_path *path, int level)
<span class="lineNum">    3467 </span>            : {
<span class="lineNum">    3468 </span><span class="lineCov">        438 :         struct extent_buffer *c;</span>
<span class="lineNum">    3469 </span><span class="lineCov">        160 :         struct extent_buffer *split;</span>
<span class="lineNum">    3470 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    3471 </span>            :         int mid;
<span class="lineNum">    3472 </span>            :         int ret;
<span class="lineNum">    3473 </span>            :         u32 c_nritems;
<span class="lineNum">    3474 </span>            : 
<span class="lineNum">    3475 </span><span class="lineCov">        180 :         c = path-&gt;nodes[level];</span>
<span class="lineNum">    3476 </span><span class="lineCov">        180 :         WARN_ON(btrfs_header_generation(c) != trans-&gt;transid);</span>
<span class="lineNum">    3477 </span><span class="lineCov">        180 :         if (c == root-&gt;node) {</span>
<span class="lineNum">    3478 </span>            :                 /*
<span class="lineNum">    3479 </span>            :                  * trying to split the root, lets make a new one
<span class="lineNum">    3480 </span>            :                  *
<span class="lineNum">    3481 </span>            :                  * tree mod log: We don't log_removal old root in
<span class="lineNum">    3482 </span>            :                  * insert_new_root, because that root buffer will be kept as a
<span class="lineNum">    3483 </span>            :                  * normal node. We are going to log removal of half of the
<span class="lineNum">    3484 </span>            :                  * elements below with tree_mod_log_eb_copy. We're holding a
<span class="lineNum">    3485 </span>            :                  * tree lock on the buffer, which is why we cannot race with
<span class="lineNum">    3486 </span>            :                  * other tree_mod_log users.
<span class="lineNum">    3487 </span>            :                  */
<span class="lineNum">    3488 </span><span class="lineCov">          3 :                 ret = insert_new_root(trans, root, path, level + 1);</span>
<span class="lineNum">    3489 </span><span class="lineCov">          3 :                 if (ret)</span>
<span class="lineNum">    3490 </span>            :                         return ret;
<span class="lineNum">    3491 </span>            :         } else {
<span class="lineNum">    3492 </span><span class="lineCov">        177 :                 ret = push_nodes_for_insert(trans, root, path, level);</span>
<span class="lineNum">    3493 </span><span class="lineCov">        177 :                 c = path-&gt;nodes[level];</span>
<span class="lineNum">    3494 </span><span class="lineCov">        501 :                 if (!ret &amp;&amp; btrfs_header_nritems(c) &lt;</span>
<span class="lineNum">    3495 </span><span class="lineCov">        162 :                     BTRFS_NODEPTRS_PER_BLOCK(root) - 3)</span>
<span class="lineNum">    3496 </span>            :                         return 0;
<span class="lineNum">    3497 </span><span class="lineCov">         29 :                 if (ret &lt; 0)</span>
<span class="lineNum">    3498 </span>            :                         return ret;
<span class="lineNum">    3499 </span>            :         }
<span class="lineNum">    3500 </span>            : 
<span class="lineNum">    3501 </span>            :         c_nritems = btrfs_header_nritems(c);
<span class="lineNum">    3502 </span><span class="lineCov">         32 :         mid = (c_nritems + 1) / 2;</span>
<span class="lineNum">    3503 </span><span class="lineCov">         32 :         btrfs_node_key(c, &amp;disk_key, mid);</span>
<span class="lineNum">    3504 </span>            : 
<span class="lineNum">    3505 </span><span class="lineCov">         32 :         split = btrfs_alloc_free_block(trans, root, root-&gt;nodesize, 0,</span>
<span class="lineNum">    3506 </span>            :                                         root-&gt;root_key.objectid,
<span class="lineNum">    3507 </span>            :                                         &amp;disk_key, level, c-&gt;start, 0);
<span class="lineNum">    3508 </span><span class="lineCov">         32 :         if (IS_ERR(split))</span>
<span class="lineNum">    3509 </span><span class="lineNoCov">          0 :                 return PTR_ERR(split);</span>
<span class="lineNum">    3510 </span>            : 
<span class="lineNum">    3511 </span><span class="lineCov">         32 :         root_add_used(root, root-&gt;nodesize);</span>
<span class="lineNum">    3512 </span>            : 
<span class="lineNum">    3513 </span><span class="lineCov">         32 :         memset_extent_buffer(split, 0, 0, sizeof(struct btrfs_header));</span>
<span class="lineNum">    3514 </span>            :         btrfs_set_header_level(split, btrfs_header_level(c));
<span class="lineNum">    3515 </span><span class="lineCov">         32 :         btrfs_set_header_bytenr(split, split-&gt;start);</span>
<span class="lineNum">    3516 </span><span class="lineCov">         32 :         btrfs_set_header_generation(split, trans-&gt;transid);</span>
<span class="lineNum">    3517 </span>            :         btrfs_set_header_backref_rev(split, BTRFS_MIXED_BACKREF_REV);
<span class="lineNum">    3518 </span><span class="lineCov">         32 :         btrfs_set_header_owner(split, root-&gt;root_key.objectid);</span>
<span class="lineNum">    3519 </span><span class="lineCov">         32 :         write_extent_buffer(split, root-&gt;fs_info-&gt;fsid,</span>
<span class="lineNum">    3520 </span>            :                             btrfs_header_fsid(), BTRFS_FSID_SIZE);
<span class="lineNum">    3521 </span><span class="lineCov">         32 :         write_extent_buffer(split, root-&gt;fs_info-&gt;chunk_tree_uuid,</span>
<span class="lineNum">    3522 </span>            :                             btrfs_header_chunk_tree_uuid(split),
<span class="lineNum">    3523 </span>            :                             BTRFS_UUID_SIZE);
<span class="lineNum">    3524 </span>            : 
<span class="lineNum">    3525 </span><span class="lineCov">         32 :         ret = tree_mod_log_eb_copy(root-&gt;fs_info, split, c, 0,</span>
<span class="lineNum">    3526 </span><span class="lineCov">         32 :                                    mid, c_nritems - mid);</span>
<span class="lineNum">    3527 </span><span class="lineCov">         32 :         if (ret) {</span>
<span class="lineNum">    3528 </span><span class="lineNoCov">          0 :                 btrfs_abort_transaction(trans, root, ret);</span>
<span class="lineNum">    3529 </span><span class="lineNoCov">          0 :                 return ret;</span>
<span class="lineNum">    3530 </span>            :         }
<span class="lineNum">    3531 </span><span class="lineCov">         64 :         copy_extent_buffer(split, c,</span>
<span class="lineNum">    3532 </span>            :                            btrfs_node_key_ptr_offset(0),
<span class="lineNum">    3533 </span>            :                            btrfs_node_key_ptr_offset(mid),
<span class="lineNum">    3534 </span>            :                            (c_nritems - mid) * sizeof(struct btrfs_key_ptr));
<span class="lineNum">    3535 </span>            :         btrfs_set_header_nritems(split, c_nritems - mid);
<span class="lineNum">    3536 </span>            :         btrfs_set_header_nritems(c, mid);
<span class="lineNum">    3537 </span>            :         ret = 0;
<span class="lineNum">    3538 </span>            : 
<span class="lineNum">    3539 </span><span class="lineCov">         32 :         btrfs_mark_buffer_dirty(c);</span>
<span class="lineNum">    3540 </span><span class="lineCov">         32 :         btrfs_mark_buffer_dirty(split);</span>
<span class="lineNum">    3541 </span>            : 
<span class="lineNum">    3542 </span><span class="lineCov">         32 :         insert_ptr(trans, root, path, &amp;disk_key, split-&gt;start,</span>
<span class="lineNum">    3543 </span><span class="lineCov">         32 :                    path-&gt;slots[level + 1] + 1, level + 1);</span>
<span class="lineNum">    3544 </span>            : 
<span class="lineNum">    3545 </span><span class="lineCov">         32 :         if (path-&gt;slots[level] &gt;= mid) {</span>
<span class="lineNum">    3546 </span><span class="lineCov">         26 :                 path-&gt;slots[level] -= mid;</span>
<span class="lineNum">    3547 </span><span class="lineCov">         26 :                 btrfs_tree_unlock(c);</span>
<span class="lineNum">    3548 </span><span class="lineCov">         26 :                 free_extent_buffer(c);</span>
<span class="lineNum">    3549 </span><span class="lineCov">         26 :                 path-&gt;nodes[level] = split;</span>
<span class="lineNum">    3550 </span><span class="lineCov">         26 :                 path-&gt;slots[level + 1] += 1;</span>
<span class="lineNum">    3551 </span>            :         } else {
<span class="lineNum">    3552 </span><span class="lineCov">          6 :                 btrfs_tree_unlock(split);</span>
<span class="lineNum">    3553 </span><span class="lineCov">          6 :                 free_extent_buffer(split);</span>
<span class="lineNum">    3554 </span>            :         }
<span class="lineNum">    3555 </span>            :         return ret;
<span class="lineNum">    3556 </span>            : }
<span class="lineNum">    3557 </span>            : 
<span class="lineNum">    3558 </span>            : /*
<span class="lineNum">    3559 </span>            :  * how many bytes are required to store the items in a leaf.  start
<span class="lineNum">    3560 </span>            :  * and nr indicate which items in the leaf to check.  This totals up the
<a name="3561"><span class="lineNum">    3561 </span>            :  * space used both by the item structs and the item data</a>
<span class="lineNum">    3562 </span>            :  */
<span class="lineNum">    3563 </span><span class="lineCov">    1472520 : static int leaf_space_used(struct extent_buffer *l, int start, int nr)</span>
<span class="lineNum">    3564 </span>            : {
<span class="lineNum">    3565 </span>            :         struct btrfs_item *start_item;
<span class="lineNum">    3566 </span>            :         struct btrfs_item *end_item;
<span class="lineNum">    3567 </span>            :         struct btrfs_map_token token;
<span class="lineNum">    3568 </span>            :         int data_len;
<span class="lineNum">    3569 </span><span class="lineCov">    1472520 :         int nritems = btrfs_header_nritems(l);</span>
<span class="lineNum">    3570 </span><span class="lineCov">    1472520 :         int end = min(nritems, start + nr) - 1;</span>
<span class="lineNum">    3571 </span>            : 
<span class="lineNum">    3572 </span><span class="lineCov">    1472520 :         if (!nr)</span>
<span class="lineNum">    3573 </span>            :                 return 0;
<span class="lineNum">    3574 </span>            :         btrfs_init_map_token(&amp;token);
<span class="lineNum">    3575 </span>            :         start_item = btrfs_item_nr(start);
<span class="lineNum">    3576 </span>            :         end_item = btrfs_item_nr(end);
<span class="lineNum">    3577 </span><span class="lineCov">    1469729 :         data_len = btrfs_token_item_offset(l, start_item, &amp;token) +</span>
<span class="lineNum">    3578 </span>            :                 btrfs_token_item_size(l, start_item, &amp;token);
<span class="lineNum">    3579 </span><span class="lineCov">    1469192 :         data_len = data_len - btrfs_token_item_offset(l, end_item, &amp;token);</span>
<span class="lineNum">    3580 </span><span class="lineCov">    1469192 :         data_len += sizeof(struct btrfs_item) * nr;</span>
<span class="lineNum">    3581 </span><span class="lineCov">    1469192 :         WARN_ON(data_len &lt; 0);</span>
<span class="lineNum">    3582 </span><span class="lineCov">    1469233 :         return data_len;</span>
<span class="lineNum">    3583 </span>            : }
<span class="lineNum">    3584 </span>            : 
<span class="lineNum">    3585 </span>            : /*
<span class="lineNum">    3586 </span>            :  * The space between the end of the leaf items and
<span class="lineNum">    3587 </span>            :  * the start of the leaf data.  IOW, how much room
<a name="3588"><span class="lineNum">    3588 </span>            :  * the leaf has left for both items and data</a>
<span class="lineNum">    3589 </span>            :  */
<span class="lineNum">    3590 </span><span class="lineCov">    1340412 : noinline int btrfs_leaf_free_space(struct btrfs_root *root,</span>
<span class="lineNum">    3591 </span><span class="lineCov">    1340412 :                                    struct extent_buffer *leaf)</span>
<span class="lineNum">    3592 </span>            : {
<span class="lineNum">    3593 </span><span class="lineCov">    1340412 :         int nritems = btrfs_header_nritems(leaf);</span>
<span class="lineNum">    3594 </span>            :         int ret;
<span class="lineNum">    3595 </span><span class="lineCov">    1340412 :         ret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);</span>
<span class="lineNum">    3596 </span><span class="lineCov">    1339636 :         if (ret &lt; 0) {</span>
<span class="lineNum">    3597 </span><span class="lineNoCov">          0 :                 btrfs_crit(root-&gt;fs_info,</span>
<span class="lineNum">    3598 </span>            :                         &quot;leaf free space ret %d, leaf data size %lu, used %d nritems %d&quot;,
<span class="lineNum">    3599 </span>            :                        ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),
<span class="lineNum">    3600 </span>            :                        leaf_space_used(leaf, 0, nritems), nritems);
<span class="lineNum">    3601 </span>            :         }
<span class="lineNum">    3602 </span><span class="lineCov">    1339636 :         return ret;</span>
<span class="lineNum">    3603 </span>            : }
<span class="lineNum">    3604 </span>            : 
<span class="lineNum">    3605 </span>            : /*
<span class="lineNum">    3606 </span>            :  * min slot controls the lowest index we're willing to push to the
<a name="3607"><span class="lineNum">    3607 </span>            :  * right.  We'll push up to and including min_slot, but no lower</a>
<span class="lineNum">    3608 </span>            :  */
<span class="lineNum">    3609 </span><span class="lineCov">       5925 : static noinline int __push_leaf_right(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    3610 </span>            :                                       struct btrfs_root *root,
<span class="lineNum">    3611 </span>            :                                       struct btrfs_path *path,
<span class="lineNum">    3612 </span>            :                                       int data_size, int empty,
<span class="lineNum">    3613 </span><span class="lineCov">       8795 :                                       struct extent_buffer *right,</span>
<span class="lineNum">    3614 </span>            :                                       int free_space, u32 left_nritems,
<span class="lineNum">    3615 </span>            :                                       u32 min_slot)
<span class="lineNum">    3616 </span>            : {
<span class="lineNum">    3617 </span><span class="lineCov">      10322 :         struct extent_buffer *left = path-&gt;nodes[0];</span>
<span class="lineNum">    3618 </span><span class="lineCov">       5925 :         struct extent_buffer *upper = path-&gt;nodes[1];</span>
<span class="lineNum">    3619 </span>            :         struct btrfs_map_token token;
<span class="lineNum">    3620 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    3621 </span>            :         int slot;
<span class="lineNum">    3622 </span>            :         u32 i;
<span class="lineNum">    3623 </span>            :         int push_space = 0;
<span class="lineNum">    3624 </span>            :         int push_items = 0;
<span class="lineNum">    3625 </span>            :         struct btrfs_item *item;
<span class="lineNum">    3626 </span>            :         u32 nr;
<span class="lineNum">    3627 </span>            :         u32 right_nritems;
<span class="lineNum">    3628 </span>            :         u32 data_end;
<span class="lineNum">    3629 </span>            :         u32 this_item_size;
<span class="lineNum">    3630 </span>            : 
<span class="lineNum">    3631 </span>            :         btrfs_init_map_token(&amp;token);
<span class="lineNum">    3632 </span>            : 
<span class="lineNum">    3633 </span><span class="lineCov">       5925 :         if (empty)</span>
<span class="lineNum">    3634 </span>            :                 nr = 0;
<span class="lineNum">    3635 </span>            :         else
<span class="lineNum">    3636 </span><span class="lineCov">       4988 :                 nr = max_t(u32, 1, min_slot);</span>
<span class="lineNum">    3637 </span>            : 
<span class="lineNum">    3638 </span><span class="lineCov">       5925 :         if (path-&gt;slots[0] &gt;= left_nritems)</span>
<span class="lineNum">    3639 </span>            :                 push_space += data_size;
<span class="lineNum">    3640 </span>            : 
<span class="lineNum">    3641 </span><span class="lineCov">       5925 :         slot = path-&gt;slots[1];</span>
<span class="lineNum">    3642 </span><span class="lineCov">       5925 :         i = left_nritems - 1;</span>
<span class="lineNum">    3643 </span><span class="lineCov">     120382 :         while (i &gt;= nr) {</span>
<span class="lineNum">    3644 </span><span class="lineCov">     114453 :                 item = btrfs_item_nr(i);</span>
<span class="lineNum">    3645 </span>            : 
<span class="lineNum">    3646 </span><span class="lineCov">     114453 :                 if (!empty &amp;&amp; push_items &gt; 0) {</span>
<span class="lineNum">    3647 </span><span class="lineCov">     101420 :                         if (path-&gt;slots[0] &gt; i)</span>
<span class="lineNum">    3648 </span>            :                                 break;
<span class="lineNum">    3649 </span><span class="lineCov">     100659 :                         if (path-&gt;slots[0] == i) {</span>
<span class="lineNum">    3650 </span><span class="lineCov">       1249 :                                 int space = btrfs_leaf_free_space(root, left);</span>
<span class="lineNum">    3651 </span><span class="lineCov">       1249 :                                 if (space + push_space * 2 &gt; free_space)</span>
<span class="lineNum">    3652 </span>            :                                         break;
<span class="lineNum">    3653 </span>            :                         }
<span class="lineNum">    3654 </span>            :                 }
<span class="lineNum">    3655 </span>            : 
<span class="lineNum">    3656 </span><span class="lineCov">     113137 :                 if (path-&gt;slots[0] == i)</span>
<span class="lineNum">    3657 </span><span class="lineCov">       1158 :                         push_space += data_size;</span>
<span class="lineNum">    3658 </span>            : 
<span class="lineNum">    3659 </span>            :                 this_item_size = btrfs_item_size(left, item);
<span class="lineNum">    3660 </span><span class="lineCov">     113137 :                 if (this_item_size + sizeof(*item) + push_space &gt; free_space)</span>
<span class="lineNum">    3661 </span>            :                         break;
<span class="lineNum">    3662 </span>            : 
<span class="lineNum">    3663 </span><span class="lineCov">     108846 :                 push_items++;</span>
<span class="lineNum">    3664 </span><span class="lineCov">     108846 :                 push_space += this_item_size + sizeof(*item);</span>
<span class="lineNum">    3665 </span><span class="lineCov">     108846 :                 if (i == 0)</span>
<span class="lineNum">    3666 </span>            :                         break;
<span class="lineNum">    3667 </span><span class="lineCov">     108532 :                 i--;</span>
<span class="lineNum">    3668 </span>            :         }
<span class="lineNum">    3669 </span>            : 
<span class="lineNum">    3670 </span><span class="lineCov">       5925 :         if (push_items == 0)</span>
<span class="lineNum">    3671 </span>            :                 goto out_unlock;
<span class="lineNum">    3672 </span>            : 
<span class="lineNum">    3673 </span><span class="lineCov">       4398 :         WARN_ON(!empty &amp;&amp; push_items == left_nritems);</span>
<span class="lineNum">    3674 </span>            : 
<span class="lineNum">    3675 </span>            :         /* push left to right */
<span class="lineNum">    3676 </span>            :         right_nritems = btrfs_header_nritems(right);
<span class="lineNum">    3677 </span>            : 
<span class="lineNum">    3678 </span><span class="lineCov">       4398 :         push_space = btrfs_item_end_nr(left, left_nritems - push_items);</span>
<span class="lineNum">    3679 </span><span class="lineCov">       4398 :         push_space -= leaf_data_end(root, left);</span>
<span class="lineNum">    3680 </span>            : 
<span class="lineNum">    3681 </span>            :         /* make room in the right data area */
<span class="lineNum">    3682 </span><span class="lineCov">       4398 :         data_end = leaf_data_end(root, right);</span>
<span class="lineNum">    3683 </span><span class="lineCov">       4398 :         memmove_extent_buffer(right,</span>
<span class="lineNum">    3684 </span>            :                               btrfs_leaf_data(right) + data_end - push_space,
<span class="lineNum">    3685 </span>            :                               btrfs_leaf_data(right) + data_end,
<span class="lineNum">    3686 </span><span class="lineCov">       4398 :                               BTRFS_LEAF_DATA_SIZE(root) - data_end);</span>
<span class="lineNum">    3687 </span>            : 
<span class="lineNum">    3688 </span>            :         /* copy from the left data area */
<span class="lineNum">    3689 </span><span class="lineCov">      13194 :         copy_extent_buffer(right, left, btrfs_leaf_data(right) +</span>
<span class="lineNum">    3690 </span><span class="lineCov">       8796 :                      BTRFS_LEAF_DATA_SIZE(root) - push_space,</span>
<span class="lineNum">    3691 </span><span class="lineCov">       4398 :                      btrfs_leaf_data(left) + leaf_data_end(root, left),</span>
<span class="lineNum">    3692 </span>            :                      push_space);
<span class="lineNum">    3693 </span>            : 
<span class="lineNum">    3694 </span><span class="lineCov">       8796 :         memmove_extent_buffer(right, btrfs_item_nr_offset(push_items),</span>
<span class="lineNum">    3695 </span>            :                               btrfs_item_nr_offset(0),
<span class="lineNum">    3696 </span>            :                               right_nritems * sizeof(struct btrfs_item));
<span class="lineNum">    3697 </span>            : 
<span class="lineNum">    3698 </span>            :         /* copy the items from left to right */
<span class="lineNum">    3699 </span><span class="lineCov">       4398 :         copy_extent_buffer(right, left, btrfs_item_nr_offset(0),</span>
<span class="lineNum">    3700 </span>            :                    btrfs_item_nr_offset(left_nritems - push_items),
<span class="lineNum">    3701 </span>            :                    push_items * sizeof(struct btrfs_item));
<span class="lineNum">    3702 </span>            : 
<span class="lineNum">    3703 </span>            :         /* update the item pointers */
<span class="lineNum">    3704 </span><span class="lineCov">       4397 :         right_nritems += push_items;</span>
<span class="lineNum">    3705 </span>            :         btrfs_set_header_nritems(right, right_nritems);
<span class="lineNum">    3706 </span><span class="lineCov">       4397 :         push_space = BTRFS_LEAF_DATA_SIZE(root);</span>
<span class="lineNum">    3707 </span><span class="lineCov">     442960 :         for (i = 0; i &lt; right_nritems; i++) {</span>
<span class="lineNum">    3708 </span><span class="lineCov">     438563 :                 item = btrfs_item_nr(i);</span>
<span class="lineNum">    3709 </span><span class="lineCov">     877126 :                 push_space -= btrfs_token_item_size(right, item, &amp;token);</span>
<span class="lineNum">    3710 </span>            :                 btrfs_set_token_item_offset(right, item, push_space, &amp;token);
<span class="lineNum">    3711 </span>            :         }
<span class="lineNum">    3712 </span>            : 
<span class="lineNum">    3713 </span>            :         left_nritems -= push_items;
<span class="lineNum">    3714 </span>            :         btrfs_set_header_nritems(left, left_nritems);
<span class="lineNum">    3715 </span>            : 
<span class="lineNum">    3716 </span><span class="lineCov">       4397 :         if (left_nritems)</span>
<span class="lineNum">    3717 </span><span class="lineCov">       4083 :                 btrfs_mark_buffer_dirty(left);</span>
<span class="lineNum">    3718 </span>            :         else
<span class="lineNum">    3719 </span><span class="lineCov">        314 :                 clean_tree_block(trans, root, left);</span>
<span class="lineNum">    3720 </span>            : 
<span class="lineNum">    3721 </span><span class="lineCov">       4398 :         btrfs_mark_buffer_dirty(right);</span>
<span class="lineNum">    3722 </span>            : 
<span class="lineNum">    3723 </span>            :         btrfs_item_key(right, &amp;disk_key, 0);
<span class="lineNum">    3724 </span><span class="lineCov">       4398 :         btrfs_set_node_key(upper, &amp;disk_key, slot + 1);</span>
<span class="lineNum">    3725 </span><span class="lineCov">       4397 :         btrfs_mark_buffer_dirty(upper);</span>
<span class="lineNum">    3726 </span>            : 
<span class="lineNum">    3727 </span>            :         /* then fixup the leaf pointer in the path */
<span class="lineNum">    3728 </span><span class="lineCov">       4398 :         if (path-&gt;slots[0] &gt;= left_nritems) {</span>
<span class="lineNum">    3729 </span><span class="lineCov">       1164 :                 path-&gt;slots[0] -= left_nritems;</span>
<span class="lineNum">    3730 </span><span class="lineCov">       2328 :                 if (btrfs_header_nritems(path-&gt;nodes[0]) == 0)</span>
<span class="lineNum">    3731 </span><span class="lineCov">        314 :                         clean_tree_block(trans, root, path-&gt;nodes[0]);</span>
<span class="lineNum">    3732 </span><span class="lineCov">       1164 :                 btrfs_tree_unlock(path-&gt;nodes[0]);</span>
<span class="lineNum">    3733 </span><span class="lineCov">       1164 :                 free_extent_buffer(path-&gt;nodes[0]);</span>
<span class="lineNum">    3734 </span><span class="lineCov">       1164 :                 path-&gt;nodes[0] = right;</span>
<span class="lineNum">    3735 </span><span class="lineCov">       1164 :                 path-&gt;slots[1] += 1;</span>
<span class="lineNum">    3736 </span>            :         } else {
<span class="lineNum">    3737 </span><span class="lineCov">       3234 :                 btrfs_tree_unlock(right);</span>
<span class="lineNum">    3738 </span><span class="lineCov">       3234 :                 free_extent_buffer(right);</span>
<span class="lineNum">    3739 </span>            :         }
<span class="lineNum">    3740 </span>            :         return 0;
<span class="lineNum">    3741 </span>            : 
<span class="lineNum">    3742 </span>            : out_unlock:
<span class="lineNum">    3743 </span><span class="lineCov">       1527 :         btrfs_tree_unlock(right);</span>
<span class="lineNum">    3744 </span><span class="lineCov">       1527 :         free_extent_buffer(right);</span>
<span class="lineNum">    3745 </span><span class="lineCov">       1527 :         return 1;</span>
<span class="lineNum">    3746 </span>            : }
<span class="lineNum">    3747 </span>            : 
<span class="lineNum">    3748 </span>            : /*
<span class="lineNum">    3749 </span>            :  * push some data in the path leaf to the right, trying to free up at
<span class="lineNum">    3750 </span>            :  * least data_size bytes.  returns zero if the push worked, nonzero otherwise
<span class="lineNum">    3751 </span>            :  *
<span class="lineNum">    3752 </span>            :  * returns 1 if the push failed because the other node didn't have enough
<span class="lineNum">    3753 </span>            :  * room, 0 if everything worked out and &lt; 0 if there were major errors.
<span class="lineNum">    3754 </span>            :  *
<span class="lineNum">    3755 </span>            :  * this will push starting from min_slot to the end of the leaf.  It won't
<a name="3756"><span class="lineNum">    3756 </span>            :  * push any slot lower than min_slot</a>
<span class="lineNum">    3757 </span>            :  */
<span class="lineNum">    3758 </span><span class="lineCov">      25319 : static int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root</span>
<span class="lineNum">    3759 </span>            :                            *root, struct btrfs_path *path,
<span class="lineNum">    3760 </span>            :                            int min_data_size, int data_size,
<span class="lineNum">    3761 </span>            :                            int empty, u32 min_slot)
<span class="lineNum">    3762 </span>            : {
<span class="lineNum">    3763 </span><span class="lineCov">      31370 :         struct extent_buffer *left = path-&gt;nodes[0];</span>
<span class="lineNum">    3764 </span>            :         struct extent_buffer *right;
<span class="lineNum">    3765 </span><span class="lineCov">      14758 :         struct extent_buffer *upper;</span>
<span class="lineNum">    3766 </span>            :         int slot;
<span class="lineNum">    3767 </span>            :         int free_space;
<span class="lineNum">    3768 </span>            :         u32 left_nritems;
<span class="lineNum">    3769 </span>            :         int ret;
<span class="lineNum">    3770 </span>            : 
<span class="lineNum">    3771 </span><span class="lineCov">      25319 :         if (!path-&gt;nodes[1])</span>
<span class="lineNum">    3772 </span>            :                 return 1;
<span class="lineNum">    3773 </span>            : 
<span class="lineNum">    3774 </span><span class="lineCov">      14758 :         slot = path-&gt;slots[1];</span>
<span class="lineNum">    3775 </span>            :         upper = path-&gt;nodes[1];
<span class="lineNum">    3776 </span><span class="lineCov">      29516 :         if (slot &gt;= btrfs_header_nritems(upper) - 1)</span>
<span class="lineNum">    3777 </span>            :                 return 1;
<span class="lineNum">    3778 </span>            : 
<span class="lineNum">    3779 </span><span class="lineCov">       9422 :         btrfs_assert_tree_locked(path-&gt;nodes[1]);</span>
<span class="lineNum">    3780 </span>            : 
<span class="lineNum">    3781 </span><span class="lineCov">       9422 :         right = read_node_slot(root, upper, slot + 1);</span>
<span class="lineNum">    3782 </span><span class="lineCov">       9422 :         if (right == NULL)</span>
<span class="lineNum">    3783 </span>            :                 return 1;
<span class="lineNum">    3784 </span>            : 
<span class="lineNum">    3785 </span><span class="lineCov">       9422 :         btrfs_tree_lock(right);</span>
<span class="lineNum">    3786 </span><span class="lineCov">       9422 :         btrfs_set_lock_blocking(right);</span>
<span class="lineNum">    3787 </span>            : 
<span class="lineNum">    3788 </span><span class="lineCov">       9422 :         free_space = btrfs_leaf_free_space(root, right);</span>
<span class="lineNum">    3789 </span><span class="lineCov">       9422 :         if (free_space &lt; data_size)</span>
<span class="lineNum">    3790 </span>            :                 goto out_unlock;
<span class="lineNum">    3791 </span>            : 
<span class="lineNum">    3792 </span>            :         /* cow and double check */
<span class="lineNum">    3793 </span><span class="lineCov">       6051 :         ret = btrfs_cow_block(trans, root, right, upper,</span>
<span class="lineNum">    3794 </span>            :                               slot + 1, &amp;right);
<span class="lineNum">    3795 </span><span class="lineCov">       6051 :         if (ret)</span>
<span class="lineNum">    3796 </span>            :                 goto out_unlock;
<span class="lineNum">    3797 </span>            : 
<span class="lineNum">    3798 </span><span class="lineCov">       6051 :         free_space = btrfs_leaf_free_space(root, right);</span>
<span class="lineNum">    3799 </span><span class="lineCov">       6051 :         if (free_space &lt; data_size)</span>
<span class="lineNum">    3800 </span>            :                 goto out_unlock;
<span class="lineNum">    3801 </span>            : 
<span class="lineNum">    3802 </span>            :         left_nritems = btrfs_header_nritems(left);
<span class="lineNum">    3803 </span><span class="lineCov">       6051 :         if (left_nritems == 0)</span>
<span class="lineNum">    3804 </span>            :                 goto out_unlock;
<span class="lineNum">    3805 </span>            : 
<span class="lineNum">    3806 </span><span class="lineCov">       6051 :         if (path-&gt;slots[0] == left_nritems &amp;&amp; !empty) {</span>
<span class="lineNum">    3807 </span>            :                 /* Key greater than all keys in the leaf, right neighbor has
<span class="lineNum">    3808 </span>            :                  * enough room for it and we're not emptying our leaf to delete
<span class="lineNum">    3809 </span>            :                  * it, therefore use right neighbor to insert the new item and
<span class="lineNum">    3810 </span>            :                  * no need to touch/dirty our left leaft. */
<span class="lineNum">    3811 </span><span class="lineCov">        126 :                 btrfs_tree_unlock(left);</span>
<span class="lineNum">    3812 </span><span class="lineCov">        126 :                 free_extent_buffer(left);</span>
<span class="lineNum">    3813 </span><span class="lineCov">        126 :                 path-&gt;nodes[0] = right;</span>
<span class="lineNum">    3814 </span><span class="lineCov">        126 :                 path-&gt;slots[0] = 0;</span>
<span class="lineNum">    3815 </span><span class="lineCov">        126 :                 path-&gt;slots[1]++;</span>
<span class="lineNum">    3816 </span><span class="lineCov">        126 :                 return 0;</span>
<span class="lineNum">    3817 </span>            :         }
<span class="lineNum">    3818 </span>            : 
<span class="lineNum">    3819 </span><span class="lineCov">       5925 :         return __push_leaf_right(trans, root, path, min_data_size, empty,</span>
<span class="lineNum">    3820 </span>            :                                 right, free_space, left_nritems, min_slot);
<span class="lineNum">    3821 </span>            : out_unlock:
<span class="lineNum">    3822 </span><span class="lineCov">       3371 :         btrfs_tree_unlock(right);</span>
<span class="lineNum">    3823 </span><span class="lineCov">       3371 :         free_extent_buffer(right);</span>
<span class="lineNum">    3824 </span><span class="lineCov">       3371 :         return 1;</span>
<span class="lineNum">    3825 </span>            : }
<span class="lineNum">    3826 </span>            : 
<span class="lineNum">    3827 </span>            : /*
<span class="lineNum">    3828 </span>            :  * push some data in the path leaf to the left, trying to free up at
<span class="lineNum">    3829 </span>            :  * least data_size bytes.  returns zero if the push worked, nonzero otherwise
<span class="lineNum">    3830 </span>            :  *
<span class="lineNum">    3831 </span>            :  * max_slot can put a limit on how far into the leaf we'll push items.  The
<span class="lineNum">    3832 </span>            :  * item at 'max_slot' won't be touched.  Use (u32)-1 to make us do all the
<a name="3833"><span class="lineNum">    3833 </span>            :  * items</a>
<span class="lineNum">    3834 </span>            :  */
<span class="lineNum">    3835 </span><span class="lineCov">       7942 : static noinline int __push_leaf_left(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    3836 </span>            :                                      struct btrfs_root *root,
<span class="lineNum">    3837 </span>            :                                      struct btrfs_path *path, int data_size,
<span class="lineNum">    3838 </span><span class="lineCov">      15128 :                                      int empty, struct extent_buffer *left,</span>
<span class="lineNum">    3839 </span>            :                                      int free_space, u32 right_nritems,
<span class="lineNum">    3840 </span>            :                                      u32 max_slot)
<span class="lineNum">    3841 </span>            : {
<span class="lineNum">    3842 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    3843 </span><span class="lineCov">      20842 :         struct extent_buffer *right = path-&gt;nodes[0];</span>
<span class="lineNum">    3844 </span>            :         int i;
<span class="lineNum">    3845 </span>            :         int push_space = 0;
<span class="lineNum">    3846 </span>            :         int push_items = 0;
<span class="lineNum">    3847 </span>            :         struct btrfs_item *item;
<span class="lineNum">    3848 </span>            :         u32 old_left_nritems;
<span class="lineNum">    3849 </span>            :         u32 nr;
<span class="lineNum">    3850 </span>            :         int ret = 0;
<span class="lineNum">    3851 </span>            :         u32 this_item_size;
<span class="lineNum">    3852 </span>            :         u32 old_left_item_size;
<span class="lineNum">    3853 </span>            :         struct btrfs_map_token token;
<span class="lineNum">    3854 </span>            : 
<span class="lineNum">    3855 </span>            :         btrfs_init_map_token(&amp;token);
<span class="lineNum">    3856 </span>            : 
<span class="lineNum">    3857 </span><span class="lineCov">       7942 :         if (empty)</span>
<span class="lineNum">    3858 </span><span class="lineCov">       3080 :                 nr = min(right_nritems, max_slot);</span>
<span class="lineNum">    3859 </span>            :         else
<span class="lineNum">    3860 </span><span class="lineCov">       4862 :                 nr = min(right_nritems - 1, max_slot);</span>
<span class="lineNum">    3861 </span>            : 
<span class="lineNum">    3862 </span><span class="lineCov">     113871 :         for (i = 0; i &lt; nr; i++) {</span>
<span class="lineNum">    3863 </span>            :                 item = btrfs_item_nr(i);
<span class="lineNum">    3864 </span>            : 
<span class="lineNum">    3865 </span><span class="lineCov">     112954 :                 if (!empty &amp;&amp; push_items &gt; 0) {</span>
<span class="lineNum">    3866 </span><span class="lineCov">      88912 :                         if (path-&gt;slots[0] &lt; i)</span>
<span class="lineNum">    3867 </span>            :                                 break;
<span class="lineNum">    3868 </span><span class="lineCov">      88345 :                         if (path-&gt;slots[0] == i) {</span>
<span class="lineNum">    3869 </span><span class="lineCov">        889 :                                 int space = btrfs_leaf_free_space(root, right);</span>
<span class="lineNum">    3870 </span><span class="lineCov">        889 :                                 if (space + push_space * 2 &gt; free_space)</span>
<span class="lineNum">    3871 </span>            :                                         break;
<span class="lineNum">    3872 </span>            :                         }
<span class="lineNum">    3873 </span>            :                 }
<span class="lineNum">    3874 </span>            : 
<span class="lineNum">    3875 </span><span class="lineCov">     112132 :                 if (path-&gt;slots[0] == i)</span>
<span class="lineNum">    3876 </span><span class="lineCov">       1635 :                         push_space += data_size;</span>
<span class="lineNum">    3877 </span>            : 
<span class="lineNum">    3878 </span>            :                 this_item_size = btrfs_item_size(right, item);
<span class="lineNum">    3879 </span><span class="lineCov">     112131 :                 if (this_item_size + sizeof(*item) + push_space &gt; free_space)</span>
<span class="lineNum">    3880 </span>            :                         break;
<span class="lineNum">    3881 </span>            : 
<span class="lineNum">    3882 </span><span class="lineCov">     105929 :                 push_items++;</span>
<span class="lineNum">    3883 </span><span class="lineCov">     105929 :                 push_space += this_item_size + sizeof(*item);</span>
<span class="lineNum">    3884 </span>            :         }
<span class="lineNum">    3885 </span>            : 
<span class="lineNum">    3886 </span><span class="lineCov">       7941 :         if (push_items == 0) {</span>
<span class="lineNum">    3887 </span>            :                 ret = 1;
<span class="lineNum">    3888 </span>            :                 goto out;
<span class="lineNum">    3889 </span>            :         }
<span class="lineNum">    3890 </span><span class="lineCov">       8716 :         WARN_ON(!empty &amp;&amp; push_items == btrfs_header_nritems(right));</span>
<span class="lineNum">    3891 </span>            : 
<span class="lineNum">    3892 </span>            :         /* push data from right to left */
<span class="lineNum">    3893 </span><span class="lineCov">      15126 :         copy_extent_buffer(left, right,</span>
<span class="lineNum">    3894 </span>            :                            btrfs_item_nr_offset(btrfs_header_nritems(left)),
<span class="lineNum">    3895 </span>            :                            btrfs_item_nr_offset(0),
<span class="lineNum">    3896 </span>            :                            push_items * sizeof(struct btrfs_item));
<span class="lineNum">    3897 </span>            : 
<span class="lineNum">    3898 </span><span class="lineCov">      10086 :         push_space = BTRFS_LEAF_DATA_SIZE(root) -</span>
<span class="lineNum">    3899 </span><span class="lineCov">       5043 :                      btrfs_item_offset_nr(right, push_items - 1);</span>
<span class="lineNum">    3900 </span>            : 
<span class="lineNum">    3901 </span><span class="lineCov">      10086 :         copy_extent_buffer(left, right, btrfs_leaf_data(left) +</span>
<span class="lineNum">    3902 </span><span class="lineCov">       5043 :                      leaf_data_end(root, left) - push_space,</span>
<span class="lineNum">    3903 </span>            :                      btrfs_leaf_data(right) +
<span class="lineNum">    3904 </span>            :                      btrfs_item_offset_nr(right, push_items - 1),
<span class="lineNum">    3905 </span>            :                      push_space);
<span class="lineNum">    3906 </span>            :         old_left_nritems = btrfs_header_nritems(left);
<span class="lineNum">    3907 </span><span class="lineCov">       5043 :         BUG_ON(old_left_nritems &lt;= 0);</span>
<span class="lineNum">    3908 </span>            : 
<span class="lineNum">    3909 </span><span class="lineCov">       5043 :         old_left_item_size = btrfs_item_offset_nr(left, old_left_nritems - 1);</span>
<span class="lineNum">    3910 </span><span class="lineCov">     110984 :         for (i = old_left_nritems; i &lt; old_left_nritems + push_items; i++) {</span>
<span class="lineNum">    3911 </span>            :                 u32 ioff;
<span class="lineNum">    3912 </span>            : 
<span class="lineNum">    3913 </span>            :                 item = btrfs_item_nr(i);
<span class="lineNum">    3914 </span>            : 
<span class="lineNum">    3915 </span>            :                 ioff = btrfs_token_item_offset(left, item, &amp;token);
<span class="lineNum">    3916 </span><span class="lineCov">     105941 :                 btrfs_set_token_item_offset(left, item,</span>
<span class="lineNum">    3917 </span><span class="lineCov">     105941 :                       ioff - (BTRFS_LEAF_DATA_SIZE(root) - old_left_item_size),</span>
<span class="lineNum">    3918 </span>            :                       &amp;token);
<span class="lineNum">    3919 </span>            :         }
<span class="lineNum">    3920 </span>            :         btrfs_set_header_nritems(left, old_left_nritems + push_items);
<span class="lineNum">    3921 </span>            : 
<span class="lineNum">    3922 </span>            :         /* fixup right node */
<span class="lineNum">    3923 </span><span class="lineCov">       5043 :         if (push_items &gt; right_nritems)</span>
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 :                 WARN(1, KERN_CRIT &quot;push items %d nr %u\n&quot;, push_items,</span>
<span class="lineNum">    3925 </span>            :                        right_nritems);
<span class="lineNum">    3926 </span>            : 
<span class="lineNum">    3927 </span><span class="lineCov">       5043 :         if (push_items &lt; right_nritems) {</span>
<span class="lineNum">    3928 </span><span class="lineCov">       4183 :                 push_space = btrfs_item_offset_nr(right, push_items - 1) -</span>
<span class="lineNum">    3929 </span><span class="lineCov">       4183 :                                                   leaf_data_end(root, right);</span>
<span class="lineNum">    3930 </span><span class="lineCov">      12549 :                 memmove_extent_buffer(right, btrfs_leaf_data(right) +</span>
<span class="lineNum">    3931 </span><span class="lineCov">       8366 :                                       BTRFS_LEAF_DATA_SIZE(root) - push_space,</span>
<span class="lineNum">    3932 </span>            :                                       btrfs_leaf_data(right) +
<span class="lineNum">    3933 </span><span class="lineCov">       4183 :                                       leaf_data_end(root, right), push_space);</span>
<span class="lineNum">    3934 </span>            : 
<span class="lineNum">    3935 </span><span class="lineCov">       8366 :                 memmove_extent_buffer(right, btrfs_item_nr_offset(0),</span>
<span class="lineNum">    3936 </span>            :                               btrfs_item_nr_offset(push_items),
<span class="lineNum">    3937 </span><span class="lineCov">       4183 :                              (btrfs_header_nritems(right) - push_items) *</span>
<span class="lineNum">    3938 </span>            :                              sizeof(struct btrfs_item));
<span class="lineNum">    3939 </span>            :         }
<span class="lineNum">    3940 </span><span class="lineCov">       5043 :         right_nritems -= push_items;</span>
<span class="lineNum">    3941 </span>            :         btrfs_set_header_nritems(right, right_nritems);
<span class="lineNum">    3942 </span><span class="lineCov">       5043 :         push_space = BTRFS_LEAF_DATA_SIZE(root);</span>
<span class="lineNum">    3943 </span><span class="lineCov">     289376 :         for (i = 0; i &lt; right_nritems; i++) {</span>
<span class="lineNum">    3944 </span>            :                 item = btrfs_item_nr(i);
<span class="lineNum">    3945 </span>            : 
<span class="lineNum">    3946 </span><span class="lineCov">     568666 :                 push_space = push_space - btrfs_token_item_size(right,</span>
<span class="lineNum">    3947 </span>            :                                                                 item, &amp;token);
<span class="lineNum">    3948 </span>            :                 btrfs_set_token_item_offset(right, item, push_space, &amp;token);
<span class="lineNum">    3949 </span>            :         }
<span class="lineNum">    3950 </span>            : 
<span class="lineNum">    3951 </span><span class="lineCov">       5043 :         btrfs_mark_buffer_dirty(left);</span>
<span class="lineNum">    3952 </span><span class="lineCov">       5043 :         if (right_nritems)</span>
<span class="lineNum">    3953 </span><span class="lineCov">       4183 :                 btrfs_mark_buffer_dirty(right);</span>
<span class="lineNum">    3954 </span>            :         else
<span class="lineNum">    3955 </span><span class="lineCov">        860 :                 clean_tree_block(trans, root, right);</span>
<span class="lineNum">    3956 </span>            : 
<span class="lineNum">    3957 </span>            :         btrfs_item_key(right, &amp;disk_key, 0);
<span class="lineNum">    3958 </span><span class="lineCov">       5043 :         fixup_low_keys(root, path, &amp;disk_key, 1);</span>
<span class="lineNum">    3959 </span>            : 
<span class="lineNum">    3960 </span>            :         /* then fixup the leaf pointer in the path */
<span class="lineNum">    3961 </span><span class="lineCov">       5043 :         if (path-&gt;slots[0] &lt; push_items) {</span>
<span class="lineNum">    3962 </span><span class="lineCov">       1437 :                 path-&gt;slots[0] += old_left_nritems;</span>
<span class="lineNum">    3963 </span><span class="lineCov">       1437 :                 btrfs_tree_unlock(path-&gt;nodes[0]);</span>
<span class="lineNum">    3964 </span><span class="lineCov">       1437 :                 free_extent_buffer(path-&gt;nodes[0]);</span>
<span class="lineNum">    3965 </span><span class="lineCov">       1437 :                 path-&gt;nodes[0] = left;</span>
<span class="lineNum">    3966 </span><span class="lineCov">       1437 :                 path-&gt;slots[1] -= 1;</span>
<span class="lineNum">    3967 </span>            :         } else {
<span class="lineNum">    3968 </span><span class="lineCov">       3606 :                 btrfs_tree_unlock(left);</span>
<span class="lineNum">    3969 </span><span class="lineCov">       3606 :                 free_extent_buffer(left);</span>
<span class="lineNum">    3970 </span><span class="lineCov">       3606 :                 path-&gt;slots[0] -= push_items;</span>
<span class="lineNum">    3971 </span>            :         }
<span class="lineNum">    3972 </span><span class="lineCov">       5043 :         BUG_ON(path-&gt;slots[0] &lt; 0);</span>
<span class="lineNum">    3973 </span>            :         return ret;
<span class="lineNum">    3974 </span>            : out:
<span class="lineNum">    3975 </span><span class="lineCov">       2899 :         btrfs_tree_unlock(left);</span>
<span class="lineNum">    3976 </span><span class="lineCov">       2899 :         free_extent_buffer(left);</span>
<span class="lineNum">    3977 </span><span class="lineCov">       2899 :         return ret;</span>
<span class="lineNum">    3978 </span>            : }
<span class="lineNum">    3979 </span>            : 
<span class="lineNum">    3980 </span>            : /*
<span class="lineNum">    3981 </span>            :  * push some data in the path leaf to the left, trying to free up at
<span class="lineNum">    3982 </span>            :  * least data_size bytes.  returns zero if the push worked, nonzero otherwise
<span class="lineNum">    3983 </span>            :  *
<span class="lineNum">    3984 </span>            :  * max_slot can put a limit on how far into the leaf we'll push items.  The
<span class="lineNum">    3985 </span>            :  * item at 'max_slot' won't be touched.  Use (u32)-1 to make us push all the
<a name="3986"><span class="lineNum">    3986 </span>            :  * items</a>
<span class="lineNum">    3987 </span>            :  */
<span class="lineNum">    3988 </span><span class="lineCov">      22351 : static int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root</span>
<span class="lineNum">    3989 </span>            :                           *root, struct btrfs_path *path, int min_data_size,
<span class="lineNum">    3990 </span>            :                           int data_size, int empty, u32 max_slot)
<span class="lineNum">    3991 </span>            : {
<span class="lineNum">    3992 </span><span class="lineCov">      33615 :         struct extent_buffer *right = path-&gt;nodes[0];</span>
<span class="lineNum">    3993 </span>            :         struct extent_buffer *left;
<span class="lineNum">    3994 </span>            :         int slot;
<span class="lineNum">    3995 </span>            :         int free_space;
<span class="lineNum">    3996 </span>            :         u32 right_nritems;
<span class="lineNum">    3997 </span>            :         int ret = 0;
<span class="lineNum">    3998 </span>            : 
<span class="lineNum">    3999 </span><span class="lineCov">      22351 :         slot = path-&gt;slots[1];</span>
<span class="lineNum">    4000 </span><span class="lineCov">      22351 :         if (slot == 0)</span>
<span class="lineNum">    4001 </span>            :                 return 1;
<span class="lineNum">    4002 </span><span class="lineCov">      11264 :         if (!path-&gt;nodes[1])</span>
<span class="lineNum">    4003 </span>            :                 return 1;
<span class="lineNum">    4004 </span>            : 
<span class="lineNum">    4005 </span>            :         right_nritems = btrfs_header_nritems(right);
<span class="lineNum">    4006 </span><span class="lineCov">      11264 :         if (right_nritems == 0)</span>
<span class="lineNum">    4007 </span>            :                 return 1;
<span class="lineNum">    4008 </span>            : 
<span class="lineNum">    4009 </span><span class="lineCov">      11264 :         btrfs_assert_tree_locked(path-&gt;nodes[1]);</span>
<span class="lineNum">    4010 </span>            : 
<span class="lineNum">    4011 </span><span class="lineCov">      11264 :         left = read_node_slot(root, path-&gt;nodes[1], slot - 1);</span>
<span class="lineNum">    4012 </span><span class="lineCov">      11264 :         if (left == NULL)</span>
<span class="lineNum">    4013 </span>            :                 return 1;
<span class="lineNum">    4014 </span>            : 
<span class="lineNum">    4015 </span><span class="lineCov">      11264 :         btrfs_tree_lock(left);</span>
<span class="lineNum">    4016 </span><span class="lineCov">      11264 :         btrfs_set_lock_blocking(left);</span>
<span class="lineNum">    4017 </span>            : 
<span class="lineNum">    4018 </span><span class="lineCov">      11264 :         free_space = btrfs_leaf_free_space(root, left);</span>
<span class="lineNum">    4019 </span><span class="lineCov">      11264 :         if (free_space &lt; data_size) {</span>
<span class="lineNum">    4020 </span>            :                 ret = 1;
<span class="lineNum">    4021 </span>            :                 goto out;
<span class="lineNum">    4022 </span>            :         }
<span class="lineNum">    4023 </span>            : 
<span class="lineNum">    4024 </span>            :         /* cow and double check */
<span class="lineNum">    4025 </span><span class="lineCov">       7942 :         ret = btrfs_cow_block(trans, root, left,</span>
<span class="lineNum">    4026 </span>            :                               path-&gt;nodes[1], slot - 1, &amp;left);
<span class="lineNum">    4027 </span><span class="lineCov">       7942 :         if (ret) {</span>
<span class="lineNum">    4028 </span>            :                 /* we hit -ENOSPC, but it isn't fatal here */
<span class="lineNum">    4029 </span><span class="lineNoCov">          0 :                 if (ret == -ENOSPC)</span>
<span class="lineNum">    4030 </span>            :                         ret = 1;
<span class="lineNum">    4031 </span>            :                 goto out;
<span class="lineNum">    4032 </span>            :         }
<span class="lineNum">    4033 </span>            : 
<span class="lineNum">    4034 </span><span class="lineCov">       7942 :         free_space = btrfs_leaf_free_space(root, left);</span>
<span class="lineNum">    4035 </span><span class="lineCov">       7942 :         if (free_space &lt; data_size) {</span>
<span class="lineNum">    4036 </span>            :                 ret = 1;
<span class="lineNum">    4037 </span>            :                 goto out;
<span class="lineNum">    4038 </span>            :         }
<span class="lineNum">    4039 </span>            : 
<span class="lineNum">    4040 </span><span class="lineCov">       7942 :         return __push_leaf_left(trans, root, path, min_data_size,</span>
<span class="lineNum">    4041 </span>            :                                empty, left, free_space, right_nritems,
<span class="lineNum">    4042 </span>            :                                max_slot);
<span class="lineNum">    4043 </span>            : out:
<span class="lineNum">    4044 </span><span class="lineCov">       3322 :         btrfs_tree_unlock(left);</span>
<span class="lineNum">    4045 </span><span class="lineCov">       3322 :         free_extent_buffer(left);</span>
<span class="lineNum">    4046 </span><span class="lineCov">       3322 :         return ret;</span>
<span class="lineNum">    4047 </span>            : }
<span class="lineNum">    4048 </span>            : 
<span class="lineNum">    4049 </span>            : /*
<span class="lineNum">    4050 </span>            :  * split the path's leaf in two, making sure there is at least data_size
<a name="4051"><span class="lineNum">    4051 </span>            :  * available for the resulting leaf level of the path.</a>
<span class="lineNum">    4052 </span>            :  */
<span class="lineNum">    4053 </span><span class="lineCov">       4137 : static noinline void copy_for_split(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    4054 </span>            :                                     struct btrfs_root *root,
<span class="lineNum">    4055 </span>            :                                     struct btrfs_path *path,
<span class="lineNum">    4056 </span><span class="lineCov">       4137 :                                     struct extent_buffer *l,</span>
<span class="lineNum">    4057 </span><span class="lineCov">       4137 :                                     struct extent_buffer *right,</span>
<span class="lineNum">    4058 </span>            :                                     int slot, int mid, int nritems)
<span class="lineNum">    4059 </span>            : {
<span class="lineNum">    4060 </span>            :         int data_copy_size;
<span class="lineNum">    4061 </span>            :         int rt_data_off;
<span class="lineNum">    4062 </span>            :         int i;
<span class="lineNum">    4063 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    4064 </span>            :         struct btrfs_map_token token;
<span class="lineNum">    4065 </span>            : 
<span class="lineNum">    4066 </span>            :         btrfs_init_map_token(&amp;token);
<span class="lineNum">    4067 </span>            : 
<span class="lineNum">    4068 </span><span class="lineCov">       4137 :         nritems = nritems - mid;</span>
<span class="lineNum">    4069 </span><span class="lineCov">       4137 :         btrfs_set_header_nritems(right, nritems);</span>
<span class="lineNum">    4070 </span><span class="lineCov">       4137 :         data_copy_size = btrfs_item_end_nr(l, mid) - leaf_data_end(root, l);</span>
<span class="lineNum">    4071 </span>            : 
<span class="lineNum">    4072 </span><span class="lineCov">       4137 :         copy_extent_buffer(right, l, btrfs_item_nr_offset(0),</span>
<span class="lineNum">    4073 </span>            :                            btrfs_item_nr_offset(mid),
<span class="lineNum">    4074 </span>            :                            nritems * sizeof(struct btrfs_item));
<span class="lineNum">    4075 </span>            : 
<span class="lineNum">    4076 </span><span class="lineCov">       8274 :         copy_extent_buffer(right, l,</span>
<span class="lineNum">    4077 </span><span class="lineCov">       4137 :                      btrfs_leaf_data(right) + BTRFS_LEAF_DATA_SIZE(root) -</span>
<span class="lineNum">    4078 </span>            :                      data_copy_size, btrfs_leaf_data(l) +
<span class="lineNum">    4079 </span><span class="lineCov">       4137 :                      leaf_data_end(root, l), data_copy_size);</span>
<span class="lineNum">    4080 </span>            : 
<span class="lineNum">    4081 </span><span class="lineCov">       8275 :         rt_data_off = BTRFS_LEAF_DATA_SIZE(root) -</span>
<span class="lineNum">    4082 </span>            :                       btrfs_item_end_nr(l, mid);
<span class="lineNum">    4083 </span>            : 
<span class="lineNum">    4084 </span><span class="lineCov">     140992 :         for (i = 0; i &lt; nritems; i++) {</span>
<span class="lineNum">    4085 </span>            :                 struct btrfs_item *item = btrfs_item_nr(i);
<span class="lineNum">    4086 </span>            :                 u32 ioff;
<span class="lineNum">    4087 </span>            : 
<span class="lineNum">    4088 </span>            :                 ioff = btrfs_token_item_offset(right, item, &amp;token);
<span class="lineNum">    4089 </span><span class="lineCov">     136854 :                 btrfs_set_token_item_offset(right, item,</span>
<span class="lineNum">    4090 </span>            :                                             ioff + rt_data_off, &amp;token);
<span class="lineNum">    4091 </span>            :         }
<span class="lineNum">    4092 </span>            : 
<span class="lineNum">    4093 </span><span class="lineCov">       4137 :         btrfs_set_header_nritems(l, mid);</span>
<span class="lineNum">    4094 </span>            :         btrfs_item_key(right, &amp;disk_key, 0);
<span class="lineNum">    4095 </span><span class="lineCov">       4137 :         insert_ptr(trans, root, path, &amp;disk_key, right-&gt;start,</span>
<span class="lineNum">    4096 </span><span class="lineCov">       4137 :                    path-&gt;slots[1] + 1, 1);</span>
<span class="lineNum">    4097 </span>            : 
<span class="lineNum">    4098 </span><span class="lineCov">       4137 :         btrfs_mark_buffer_dirty(right);</span>
<span class="lineNum">    4099 </span><span class="lineCov">       4137 :         btrfs_mark_buffer_dirty(l);</span>
<span class="lineNum">    4100 </span><span class="lineCov">       4137 :         BUG_ON(path-&gt;slots[0] != slot);</span>
<span class="lineNum">    4101 </span>            : 
<span class="lineNum">    4102 </span><span class="lineCov">       4137 :         if (mid &lt;= slot) {</span>
<span class="lineNum">    4103 </span><span class="lineCov">       3295 :                 btrfs_tree_unlock(path-&gt;nodes[0]);</span>
<span class="lineNum">    4104 </span><span class="lineCov">       3295 :                 free_extent_buffer(path-&gt;nodes[0]);</span>
<span class="lineNum">    4105 </span><span class="lineCov">       3295 :                 path-&gt;nodes[0] = right;</span>
<span class="lineNum">    4106 </span><span class="lineCov">       3295 :                 path-&gt;slots[0] -= mid;</span>
<span class="lineNum">    4107 </span><span class="lineCov">       3295 :                 path-&gt;slots[1] += 1;</span>
<span class="lineNum">    4108 </span>            :         } else {
<span class="lineNum">    4109 </span><span class="lineCov">        842 :                 btrfs_tree_unlock(right);</span>
<span class="lineNum">    4110 </span><span class="lineCov">        842 :                 free_extent_buffer(right);</span>
<span class="lineNum">    4111 </span>            :         }
<span class="lineNum">    4112 </span>            : 
<span class="lineNum">    4113 </span><span class="lineCov">       4137 :         BUG_ON(path-&gt;slots[0] &lt; 0);</span>
<span class="lineNum">    4114 </span><span class="lineCov">       4137 : }</span>
<span class="lineNum">    4115 </span>            : 
<span class="lineNum">    4116 </span>            : /*
<span class="lineNum">    4117 </span>            :  * double splits happen when we need to insert a big item in the middle
<span class="lineNum">    4118 </span>            :  * of a leaf.  A double split can leave us with 3 mostly empty leaves:
<span class="lineNum">    4119 </span>            :  * leaf: [ slots 0 - N] [ our target ] [ N + 1 - total in leaf ]
<span class="lineNum">    4120 </span>            :  *          A                 B                 C
<span class="lineNum">    4121 </span>            :  *
<span class="lineNum">    4122 </span>            :  * We avoid this by trying to push the items on either side of our target
<span class="lineNum">    4123 </span>            :  * into the adjacent leaves.  If all goes well we can avoid the double split
<a name="4124"><span class="lineNum">    4124 </span>            :  * completely.</a>
<span class="lineNum">    4125 </span>            :  */
<span class="lineNum">    4126 </span><span class="lineCov">        946 : static noinline int push_for_double_split(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    4127 </span>            :                                           struct btrfs_root *root,
<span class="lineNum">    4128 </span>            :                                           struct btrfs_path *path,
<span class="lineNum">    4129 </span>            :                                           int data_size)
<span class="lineNum">    4130 </span>            : {
<span class="lineNum">    4131 </span>            :         int ret;
<span class="lineNum">    4132 </span>            :         int progress = 0;
<span class="lineNum">    4133 </span>            :         int slot;
<span class="lineNum">    4134 </span>            :         u32 nritems;
<span class="lineNum">    4135 </span>            :         int space_needed = data_size;
<span class="lineNum">    4136 </span>            : 
<span class="lineNum">    4137 </span><span class="lineCov">        946 :         slot = path-&gt;slots[0];</span>
<span class="lineNum">    4138 </span><span class="lineCov">       2838 :         if (slot &lt; btrfs_header_nritems(path-&gt;nodes[0]))</span>
<span class="lineNum">    4139 </span><span class="lineCov">        946 :                 space_needed -= btrfs_leaf_free_space(root, path-&gt;nodes[0]);</span>
<span class="lineNum">    4140 </span>            : 
<span class="lineNum">    4141 </span>            :         /*
<span class="lineNum">    4142 </span>            :          * try to push all the items after our slot into the
<span class="lineNum">    4143 </span>            :          * right leaf
<span class="lineNum">    4144 </span>            :          */
<span class="lineNum">    4145 </span><span class="lineCov">        946 :         ret = push_leaf_right(trans, root, path, 1, space_needed, 0, slot);</span>
<span class="lineNum">    4146 </span><span class="lineCov">        946 :         if (ret &lt; 0)</span>
<span class="lineNum">    4147 </span>            :                 return ret;
<span class="lineNum">    4148 </span>            : 
<span class="lineNum">    4149 </span><span class="lineCov">        946 :         if (ret == 0)</span>
<span class="lineNum">    4150 </span>            :                 progress++;
<span class="lineNum">    4151 </span>            : 
<span class="lineNum">    4152 </span><span class="lineCov">        946 :         nritems = btrfs_header_nritems(path-&gt;nodes[0]);</span>
<span class="lineNum">    4153 </span>            :         /*
<span class="lineNum">    4154 </span>            :          * our goal is to get our slot at the start or end of a leaf.  If
<span class="lineNum">    4155 </span>            :          * we've done so we're done
<span class="lineNum">    4156 </span>            :          */
<span class="lineNum">    4157 </span><span class="lineCov">        946 :         if (path-&gt;slots[0] == 0 || path-&gt;slots[0] == nritems)</span>
<span class="lineNum">    4158 </span>            :                 return 0;
<span class="lineNum">    4159 </span>            : 
<span class="lineNum">    4160 </span><span class="lineCov">        943 :         if (btrfs_leaf_free_space(root, path-&gt;nodes[0]) &gt;= data_size)</span>
<span class="lineNum">    4161 </span>            :                 return 0;
<span class="lineNum">    4162 </span>            : 
<span class="lineNum">    4163 </span>            :         /* try to push all the items before our slot into the next leaf */
<span class="lineNum">    4164 </span><span class="lineCov">        943 :         slot = path-&gt;slots[0];</span>
<span class="lineNum">    4165 </span><span class="lineCov">        943 :         ret = push_leaf_left(trans, root, path, 1, space_needed, 0, slot);</span>
<span class="lineNum">    4166 </span><span class="lineCov">        943 :         if (ret &lt; 0)</span>
<span class="lineNum">    4167 </span>            :                 return ret;
<span class="lineNum">    4168 </span>            : 
<span class="lineNum">    4169 </span><span class="lineCov">        943 :         if (ret == 0)</span>
<span class="lineNum">    4170 </span><span class="lineNoCov">          0 :                 progress++;</span>
<span class="lineNum">    4171 </span>            : 
<span class="lineNum">    4172 </span><span class="lineCov">        943 :         if (progress)</span>
<span class="lineNum">    4173 </span>            :                 return 0;
<span class="lineNum">    4174 </span><span class="lineCov">        943 :         return 1;</span>
<span class="lineNum">    4175 </span>            : }
<span class="lineNum">    4176 </span>            : 
<span class="lineNum">    4177 </span>            : /*
<span class="lineNum">    4178 </span>            :  * split the path's leaf in two, making sure there is at least data_size
<span class="lineNum">    4179 </span>            :  * available for the resulting leaf level of the path.
<span class="lineNum">    4180 </span>            :  *
<span class="lineNum">    4181 </span>            :  * returns 0 if all went well and &lt; 0 on failure.
<span class="lineNum">    4182 </span>            :  */
<span class="lineNum">    4183 </span><span class="lineCov">      13447 : static noinline int split_leaf(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    4184 </span>            :                                struct btrfs_root *root,
<span class="lineNum">    4185 </span>            :                                struct btrfs_key *ins_key,
<span class="lineNum">    4186 </span>            :                                struct btrfs_path *path, int data_size,
<span class="lineNum">    4187 </span>            :                                int extend)
<span class="lineNum">    4188 </span>            : {
<span class="lineNum">    4189 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    4190 </span><span class="lineCov">      17649 :         struct extent_buffer *l;</span>
<span class="lineNum">    4191 </span>            :         u32 nritems;
<span class="lineNum">    4192 </span>            :         int mid;
<span class="lineNum">    4193 </span>            :         int slot;
<span class="lineNum">    4194 </span><span class="lineCov">      22263 :         struct extent_buffer *right;</span>
<span class="lineNum">    4195 </span>            :         int ret = 0;
<span class="lineNum">    4196 </span>            :         int wret;
<span class="lineNum">    4197 </span>            :         int split;
<span class="lineNum">    4198 </span>            :         int num_doubles = 0;
<span class="lineNum">    4199 </span>            :         int tried_avoid_double = 0;
<span class="lineNum">    4200 </span>            : 
<span class="lineNum">    4201 </span><span class="lineCov">      13447 :         l = path-&gt;nodes[0];</span>
<span class="lineNum">    4202 </span><span class="lineCov">      13447 :         slot = path-&gt;slots[0];</span>
<span class="lineNum">    4203 </span><span class="lineCov">      17875 :         if (extend &amp;&amp; data_size + btrfs_item_size_nr(l, slot) +</span>
<span class="lineNum">    4204 </span><span class="lineCov">       2214 :             sizeof(struct btrfs_item) &gt; BTRFS_LEAF_DATA_SIZE(root))</span>
<span class="lineNum">    4205 </span>            :                 return -EOVERFLOW;
<span class="lineNum">    4206 </span>            : 
<span class="lineNum">    4207 </span>            :         /* first try to make some room by pushing left and right */
<span class="lineNum">    4208 </span><span class="lineCov">      11519 :         if (data_size &amp;&amp; path-&gt;nodes[1]) {</span>
<span class="lineNum">    4209 </span>            :                 int space_needed = data_size;
<span class="lineNum">    4210 </span>            : 
<span class="lineNum">    4211 </span><span class="lineCov">      22846 :                 if (slot &lt; btrfs_header_nritems(l))</span>
<span class="lineNum">    4212 </span><span class="lineCov">       8627 :                         space_needed -= btrfs_leaf_free_space(root, l);</span>
<span class="lineNum">    4213 </span>            : 
<span class="lineNum">    4214 </span><span class="lineCov">      11423 :                 wret = push_leaf_right(trans, root, path, space_needed,</span>
<span class="lineNum">    4215 </span>            :                                        space_needed, 0, 0);
<span class="lineNum">    4216 </span><span class="lineCov">      11423 :                 if (wret &lt; 0)</span>
<span class="lineNum">    4217 </span>            :                         return wret;
<span class="lineNum">    4218 </span><span class="lineCov">      11423 :                 if (wret) {</span>
<span class="lineNum">    4219 </span><span class="lineCov">       7384 :                         wret = push_leaf_left(trans, root, path, space_needed,</span>
<span class="lineNum">    4220 </span>            :                                               space_needed, 0, (u32)-1);
<span class="lineNum">    4221 </span><span class="lineCov">       7384 :                         if (wret &lt; 0)</span>
<span class="lineNum">    4222 </span>            :                                 return wret;
<span class="lineNum">    4223 </span>            :                 }
<span class="lineNum">    4224 </span><span class="lineCov">      11423 :                 l = path-&gt;nodes[0];</span>
<span class="lineNum">    4225 </span>            : 
<span class="lineNum">    4226 </span>            :                 /* did the pushes work? */
<span class="lineNum">    4227 </span><span class="lineCov">      11423 :                 if (btrfs_leaf_free_space(root, l) &gt;= data_size)</span>
<span class="lineNum">    4228 </span>            :                         return 0;
<span class="lineNum">    4229 </span>            :         }
<span class="lineNum">    4230 </span>            : 
<span class="lineNum">    4231 </span><span class="lineCov">       4337 :         if (!path-&gt;nodes[1]) {</span>
<span class="lineNum">    4232 </span><span class="lineCov">         96 :                 ret = insert_new_root(trans, root, path, 1);</span>
<span class="lineNum">    4233 </span><span class="lineCov">         96 :                 if (ret)</span>
<span class="lineNum">    4234 </span>            :                         return ret;
<span class="lineNum">    4235 </span>            :         }
<span class="lineNum">    4236 </span>            : again:
<span class="lineNum">    4237 </span>            :         split = 1;
<span class="lineNum">    4238 </span><span class="lineCov">       6226 :         l = path-&gt;nodes[0];</span>
<span class="lineNum">    4239 </span><span class="lineCov">       6226 :         slot = path-&gt;slots[0];</span>
<span class="lineNum">    4240 </span>            :         nritems = btrfs_header_nritems(l);
<span class="lineNum">    4241 </span><span class="lineCov">       6226 :         mid = (nritems + 1) / 2;</span>
<span class="lineNum">    4242 </span>            : 
<span class="lineNum">    4243 </span><span class="lineCov">       6226 :         if (mid &lt;= slot) {</span>
<span class="lineNum">    4244 </span><span class="lineCov">       5390 :                 if (nritems == 1 ||</span>
<span class="lineNum">    4245 </span><span class="lineCov">       2678 :                     leaf_space_used(l, mid, nritems - mid) + data_size &gt;</span>
<span class="lineNum">    4246 </span><span class="lineCov">       2678 :                         BTRFS_LEAF_DATA_SIZE(root)) {</span>
<span class="lineNum">    4247 </span><span class="lineCov">        504 :                         if (slot &gt;= nritems) {</span>
<span class="lineNum">    4248 </span>            :                                 split = 0;
<span class="lineNum">    4249 </span>            :                         } else {
<span class="lineNum">    4250 </span>            :                                 mid = slot;
<span class="lineNum">    4251 </span><span class="lineCov">        652 :                                 if (mid != nritems &amp;&amp;</span>
<span class="lineNum">    4252 </span><span class="lineCov">        326 :                                     leaf_space_used(l, mid, nritems - mid) +</span>
<span class="lineNum">    4253 </span><span class="lineCov">        326 :                                     data_size &gt; BTRFS_LEAF_DATA_SIZE(root)) {</span>
<span class="lineNum">    4254 </span><span class="lineCov">        293 :                                         if (data_size &amp;&amp; !tried_avoid_double)</span>
<span class="lineNum">    4255 </span>            :                                                 goto push_for_double;
<span class="lineNum">    4256 </span>            :                                         split = 2;
<span class="lineNum">    4257 </span>            :                                 }
<span class="lineNum">    4258 </span>            :                         }
<span class="lineNum">    4259 </span>            :                 }
<span class="lineNum">    4260 </span>            :         } else {
<span class="lineNum">    4261 </span><span class="lineCov">       7028 :                 if (leaf_space_used(l, 0, mid) + data_size &gt;</span>
<span class="lineNum">    4262 </span><span class="lineCov">       3514 :                         BTRFS_LEAF_DATA_SIZE(root)) {</span>
<span class="lineNum">    4263 </span><span class="lineCov">       2672 :                         if (!extend &amp;&amp; data_size &amp;&amp; slot == 0) {</span>
<span class="lineNum">    4264 </span>            :                                 split = 0;
<span class="lineNum">    4265 </span><span class="lineCov">       1707 :                         } else if ((extend || !data_size) &amp;&amp; slot == 0) {</span>
<span class="lineNum">    4266 </span>            :                                 mid = 1;
<span class="lineNum">    4267 </span>            :                         } else {
<span class="lineNum">    4268 </span>            :                                 mid = slot;
<span class="lineNum">    4269 </span><span class="lineCov">       3414 :                                 if (mid != nritems &amp;&amp;</span>
<span class="lineNum">    4270 </span><span class="lineCov">       1707 :                                     leaf_space_used(l, mid, nritems - mid) +</span>
<span class="lineNum">    4271 </span><span class="lineCov">       1707 :                                     data_size &gt; BTRFS_LEAF_DATA_SIZE(root)) {</span>
<span class="lineNum">    4272 </span><span class="lineCov">       1596 :                                         if (data_size &amp;&amp; !tried_avoid_double)</span>
<span class="lineNum">    4273 </span>            :                                                 goto push_for_double;
<span class="lineNum">    4274 </span>            :                                         split = 2;
<span class="lineNum">    4275 </span>            :                                 }
<span class="lineNum">    4276 </span>            :                         }
<span class="lineNum">    4277 </span>            :                 }
<span class="lineNum">    4278 </span>            :         }
<span class="lineNum">    4279 </span>            : 
<span class="lineNum">    4280 </span><span class="lineCov">       5280 :         if (split == 0)</span>
<span class="lineNum">    4281 </span>            :                 btrfs_cpu_key_to_disk(&amp;disk_key, ins_key);
<span class="lineNum">    4282 </span>            :         else
<span class="lineNum">    4283 </span>            :                 btrfs_item_key(l, &amp;disk_key, mid);
<span class="lineNum">    4284 </span>            : 
<span class="lineNum">    4285 </span><span class="lineCov">       5280 :         right = btrfs_alloc_free_block(trans, root, root-&gt;leafsize, 0,</span>
<span class="lineNum">    4286 </span>            :                                         root-&gt;root_key.objectid,
<span class="lineNum">    4287 </span>            :                                         &amp;disk_key, 0, l-&gt;start, 0);
<span class="lineNum">    4288 </span><span class="lineCov">       5280 :         if (IS_ERR(right))</span>
<span class="lineNum">    4289 </span><span class="lineNoCov">          0 :                 return PTR_ERR(right);</span>
<span class="lineNum">    4290 </span>            : 
<span class="lineNum">    4291 </span><span class="lineCov">       5280 :         root_add_used(root, root-&gt;leafsize);</span>
<span class="lineNum">    4292 </span>            : 
<span class="lineNum">    4293 </span><span class="lineCov">       5280 :         memset_extent_buffer(right, 0, 0, sizeof(struct btrfs_header));</span>
<span class="lineNum">    4294 </span><span class="lineCov">       5280 :         btrfs_set_header_bytenr(right, right-&gt;start);</span>
<span class="lineNum">    4295 </span><span class="lineCov">       5280 :         btrfs_set_header_generation(right, trans-&gt;transid);</span>
<span class="lineNum">    4296 </span>            :         btrfs_set_header_backref_rev(right, BTRFS_MIXED_BACKREF_REV);
<span class="lineNum">    4297 </span><span class="lineCov">       5280 :         btrfs_set_header_owner(right, root-&gt;root_key.objectid);</span>
<span class="lineNum">    4298 </span>            :         btrfs_set_header_level(right, 0);
<span class="lineNum">    4299 </span><span class="lineCov">       5280 :         write_extent_buffer(right, root-&gt;fs_info-&gt;fsid,</span>
<span class="lineNum">    4300 </span>            :                             btrfs_header_fsid(), BTRFS_FSID_SIZE);
<span class="lineNum">    4301 </span>            : 
<span class="lineNum">    4302 </span><span class="lineCov">       5280 :         write_extent_buffer(right, root-&gt;fs_info-&gt;chunk_tree_uuid,</span>
<span class="lineNum">    4303 </span>            :                             btrfs_header_chunk_tree_uuid(right),
<span class="lineNum">    4304 </span>            :                             BTRFS_UUID_SIZE);
<span class="lineNum">    4305 </span>            : 
<span class="lineNum">    4306 </span><span class="lineCov">       5280 :         if (split == 0) {</span>
<span class="lineNum">    4307 </span><span class="lineCov">       1143 :                 if (mid &lt;= slot) {</span>
<span class="lineNum">    4308 </span>            :                         btrfs_set_header_nritems(right, 0);
<span class="lineNum">    4309 </span><span class="lineCov">        178 :                         insert_ptr(trans, root, path, &amp;disk_key, right-&gt;start,</span>
<span class="lineNum">    4310 </span><span class="lineCov">        178 :                                    path-&gt;slots[1] + 1, 1);</span>
<span class="lineNum">    4311 </span><span class="lineCov">        178 :                         btrfs_tree_unlock(path-&gt;nodes[0]);</span>
<span class="lineNum">    4312 </span><span class="lineCov">        178 :                         free_extent_buffer(path-&gt;nodes[0]);</span>
<span class="lineNum">    4313 </span><span class="lineCov">        178 :                         path-&gt;nodes[0] = right;</span>
<span class="lineNum">    4314 </span><span class="lineCov">        178 :                         path-&gt;slots[0] = 0;</span>
<span class="lineNum">    4315 </span><span class="lineCov">        178 :                         path-&gt;slots[1] += 1;</span>
<span class="lineNum">    4316 </span>            :                 } else {
<span class="lineNum">    4317 </span>            :                         btrfs_set_header_nritems(right, 0);
<span class="lineNum">    4318 </span><span class="lineCov">        965 :                         insert_ptr(trans, root, path, &amp;disk_key, right-&gt;start,</span>
<span class="lineNum">    4319 </span>            :                                           path-&gt;slots[1], 1);
<span class="lineNum">    4320 </span><span class="lineCov">        965 :                         btrfs_tree_unlock(path-&gt;nodes[0]);</span>
<span class="lineNum">    4321 </span><span class="lineCov">        965 :                         free_extent_buffer(path-&gt;nodes[0]);</span>
<span class="lineNum">    4322 </span><span class="lineCov">        965 :                         path-&gt;nodes[0] = right;</span>
<span class="lineNum">    4323 </span><span class="lineCov">        965 :                         path-&gt;slots[0] = 0;</span>
<span class="lineNum">    4324 </span><span class="lineCov">        965 :                         if (path-&gt;slots[1] == 0)</span>
<span class="lineNum">    4325 </span><span class="lineNoCov">          0 :                                 fixup_low_keys(root, path, &amp;disk_key, 1);</span>
<span class="lineNum">    4326 </span>            :                 }
<span class="lineNum">    4327 </span><span class="lineCov">       1143 :                 btrfs_mark_buffer_dirty(right);</span>
<span class="lineNum">    4328 </span><span class="lineCov">       1143 :                 return ret;</span>
<span class="lineNum">    4329 </span>            :         }
<span class="lineNum">    4330 </span>            : 
<span class="lineNum">    4331 </span><span class="lineCov">       4137 :         copy_for_split(trans, root, path, l, right, slot, mid, nritems);</span>
<span class="lineNum">    4332 </span>            : 
<span class="lineNum">    4333 </span><span class="lineCov">       4137 :         if (split == 2) {</span>
<span class="lineNum">    4334 </span><span class="lineCov">        943 :                 BUG_ON(num_doubles != 0);</span>
<span class="lineNum">    4335 </span><span class="lineCov">        943 :                 num_doubles++;</span>
<span class="lineNum">    4336 </span><span class="lineCov">        943 :                 goto again;</span>
<span class="lineNum">    4337 </span>            :         }
<span class="lineNum">    4338 </span>            : 
<span class="lineNum">    4339 </span>            :         return 0;
<span class="lineNum">    4340 </span>            : 
<span class="lineNum">    4341 </span>            : push_for_double:
<span class="lineNum">    4342 </span><span class="lineCov">        946 :         push_for_double_split(trans, root, path, data_size);</span>
<span class="lineNum">    4343 </span>            :         tried_avoid_double = 1;
<span class="lineNum">    4344 </span><span class="lineCov">        946 :         if (btrfs_leaf_free_space(root, path-&gt;nodes[0]) &gt;= data_size)</span>
<span class="lineNum">    4345 </span>            :                 return 0;
<span class="lineNum">    4346 </span>            :         goto again;
<a name="4347"><span class="lineNum">    4347 </span>            : }</a>
<span class="lineNum">    4348 </span>            : 
<span class="lineNum">    4349 </span><span class="lineCov">       3246 : static noinline int setup_leaf_for_split(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    4350 </span>            :                                          struct btrfs_root *root,
<span class="lineNum">    4351 </span>            :                                          struct btrfs_path *path, int ins_len)
<span class="lineNum">    4352 </span>            : {
<span class="lineNum">    4353 </span>            :         struct btrfs_key key;
<span class="lineNum">    4354 </span>            :         struct extent_buffer *leaf;
<span class="lineNum">    4355 </span>            :         struct btrfs_file_extent_item *fi;
<span class="lineNum">    4356 </span>            :         u64 extent_len = 0;
<span class="lineNum">    4357 </span>            :         u32 item_size;
<span class="lineNum">    4358 </span>            :         int ret;
<span class="lineNum">    4359 </span>            : 
<span class="lineNum">    4360 </span><span class="lineCov">       3246 :         leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4361 </span><span class="lineCov">       3246 :         btrfs_item_key_to_cpu(leaf, &amp;key, path-&gt;slots[0]);</span>
<span class="lineNum">    4362 </span>            : 
<span class="lineNum">    4363 </span><span class="lineCov">       3246 :         BUG_ON(key.type != BTRFS_EXTENT_DATA_KEY &amp;&amp;</span>
<span class="lineNum">    4364 </span>            :                key.type != BTRFS_EXTENT_CSUM_KEY);
<span class="lineNum">    4365 </span>            : 
<span class="lineNum">    4366 </span><span class="lineCov">       3246 :         if (btrfs_leaf_free_space(root, leaf) &gt;= ins_len)</span>
<span class="lineNum">    4367 </span>            :                 return 0;
<span class="lineNum">    4368 </span>            : 
<span class="lineNum">    4369 </span><span class="lineCov">        125 :         item_size = btrfs_item_size_nr(leaf, path-&gt;slots[0]);</span>
<span class="lineNum">    4370 </span><span class="lineCov">        125 :         if (key.type == BTRFS_EXTENT_DATA_KEY) {</span>
<span class="lineNum">    4371 </span><span class="lineCov">        244 :                 fi = btrfs_item_ptr(leaf, path-&gt;slots[0],</span>
<span class="lineNum">    4372 </span>            :                                     struct btrfs_file_extent_item);
<span class="lineNum">    4373 </span>            :                 extent_len = btrfs_file_extent_num_bytes(leaf, fi);
<span class="lineNum">    4374 </span>            :         }
<span class="lineNum">    4375 </span><span class="lineCov">        125 :         btrfs_release_path(path);</span>
<span class="lineNum">    4376 </span>            : 
<span class="lineNum">    4377 </span><span class="lineCov">        125 :         path-&gt;keep_locks = 1;</span>
<span class="lineNum">    4378 </span><span class="lineCov">        125 :         path-&gt;search_for_split = 1;</span>
<span class="lineNum">    4379 </span><span class="lineCov">        125 :         ret = btrfs_search_slot(trans, root, &amp;key, path, 0, 1);</span>
<span class="lineNum">    4380 </span><span class="lineCov">        125 :         path-&gt;search_for_split = 0;</span>
<span class="lineNum">    4381 </span><span class="lineCov">        125 :         if (ret &lt; 0)</span>
<span class="lineNum">    4382 </span>            :                 goto err;
<span class="lineNum">    4383 </span>            : 
<span class="lineNum">    4384 </span>            :         ret = -EAGAIN;
<span class="lineNum">    4385 </span><span class="lineCov">        125 :         leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4386 </span>            :         /* if our item isn't there or got smaller, return now */
<span class="lineNum">    4387 </span><span class="lineCov">        250 :         if (ret &gt; 0 || item_size != btrfs_item_size_nr(leaf, path-&gt;slots[0]))</span>
<span class="lineNum">    4388 </span>            :                 goto err;
<span class="lineNum">    4389 </span>            : 
<span class="lineNum">    4390 </span>            :         /* the leaf has  changed, it now has room.  return now */
<span class="lineNum">    4391 </span><span class="lineCov">        125 :         if (btrfs_leaf_free_space(root, path-&gt;nodes[0]) &gt;= ins_len)</span>
<span class="lineNum">    4392 </span>            :                 goto err;
<span class="lineNum">    4393 </span>            : 
<span class="lineNum">    4394 </span><span class="lineCov">        123 :         if (key.type == BTRFS_EXTENT_DATA_KEY) {</span>
<span class="lineNum">    4395 </span><span class="lineCov">        240 :                 fi = btrfs_item_ptr(leaf, path-&gt;slots[0],</span>
<span class="lineNum">    4396 </span>            :                                     struct btrfs_file_extent_item);
<span class="lineNum">    4397 </span><span class="lineCov">        120 :                 if (extent_len != btrfs_file_extent_num_bytes(leaf, fi))</span>
<span class="lineNum">    4398 </span>            :                         goto err;
<span class="lineNum">    4399 </span>            :         }
<span class="lineNum">    4400 </span>            : 
<span class="lineNum">    4401 </span><span class="lineCov">        123 :         btrfs_set_path_blocking(path);</span>
<span class="lineNum">    4402 </span><span class="lineCov">        123 :         ret = split_leaf(trans, root, &amp;key, path, ins_len, 1);</span>
<span class="lineNum">    4403 </span><span class="lineCov">        123 :         if (ret)</span>
<span class="lineNum">    4404 </span>            :                 goto err;
<span class="lineNum">    4405 </span>            : 
<span class="lineNum">    4406 </span><span class="lineCov">        123 :         path-&gt;keep_locks = 0;</span>
<span class="lineNum">    4407 </span><span class="lineCov">        123 :         btrfs_unlock_up_safe(path, 1);</span>
<span class="lineNum">    4408 </span><span class="lineCov">        123 :         return 0;</span>
<span class="lineNum">    4409 </span>            : err:
<span class="lineNum">    4410 </span><span class="lineCov">          2 :         path-&gt;keep_locks = 0;</span>
<span class="lineNum">    4411 </span><span class="lineCov">          2 :         return ret;</span>
<a name="4412"><span class="lineNum">    4412 </span>            : }</a>
<span class="lineNum">    4413 </span>            : 
<span class="lineNum">    4414 </span><span class="lineCov">       1183 : static noinline int split_item(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    4415 </span>            :                                struct btrfs_root *root,
<span class="lineNum">    4416 </span>            :                                struct btrfs_path *path,
<span class="lineNum">    4417 </span>            :                                struct btrfs_key *new_key,
<span class="lineNum">    4418 </span>            :                                unsigned long split_offset)
<span class="lineNum">    4419 </span>            : {
<span class="lineNum">    4420 </span><span class="lineCov">       2366 :         struct extent_buffer *leaf;</span>
<span class="lineNum">    4421 </span>            :         struct btrfs_item *item;
<span class="lineNum">    4422 </span>            :         struct btrfs_item *new_item;
<span class="lineNum">    4423 </span>            :         int slot;
<span class="lineNum">    4424 </span>            :         char *buf;
<span class="lineNum">    4425 </span>            :         u32 nritems;
<span class="lineNum">    4426 </span>            :         u32 item_size;
<span class="lineNum">    4427 </span>            :         u32 orig_offset;
<span class="lineNum">    4428 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    4429 </span>            : 
<span class="lineNum">    4430 </span><span class="lineCov">       1183 :         leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4431 </span><span class="lineCov">       1183 :         BUG_ON(btrfs_leaf_free_space(root, leaf) &lt; sizeof(struct btrfs_item));</span>
<span class="lineNum">    4432 </span>            : 
<span class="lineNum">    4433 </span><span class="lineCov">       1183 :         btrfs_set_path_blocking(path);</span>
<span class="lineNum">    4434 </span>            : 
<span class="lineNum">    4435 </span><span class="lineCov">       1183 :         item = btrfs_item_nr(path-&gt;slots[0]);</span>
<span class="lineNum">    4436 </span>            :         orig_offset = btrfs_item_offset(leaf, item);
<span class="lineNum">    4437 </span>            :         item_size = btrfs_item_size(leaf, item);
<span class="lineNum">    4438 </span>            : 
<span class="lineNum">    4439 </span><span class="lineCov">       1183 :         buf = kmalloc(item_size, GFP_NOFS);</span>
<span class="lineNum">    4440 </span><span class="lineCov">       1183 :         if (!buf)</span>
<span class="lineNum">    4441 </span>            :                 return -ENOMEM;
<span class="lineNum">    4442 </span>            : 
<span class="lineNum">    4443 </span><span class="lineCov">       2366 :         read_extent_buffer(leaf, buf, btrfs_item_ptr_offset(leaf,</span>
<span class="lineNum">    4444 </span>            :                             path-&gt;slots[0]), item_size);
<span class="lineNum">    4445 </span>            : 
<span class="lineNum">    4446 </span><span class="lineCov">       1183 :         slot = path-&gt;slots[0] + 1;</span>
<span class="lineNum">    4447 </span>            :         nritems = btrfs_header_nritems(leaf);
<span class="lineNum">    4448 </span><span class="lineCov">       1183 :         if (slot != nritems) {</span>
<span class="lineNum">    4449 </span>            :                 /* shift the items */
<span class="lineNum">    4450 </span><span class="lineCov">       3498 :                 memmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + 1),</span>
<span class="lineNum">    4451 </span>            :                                 btrfs_item_nr_offset(slot),
<span class="lineNum">    4452 </span><span class="lineCov">       1166 :                                 (nritems - slot) * sizeof(struct btrfs_item));</span>
<span class="lineNum">    4453 </span>            :         }
<span class="lineNum">    4454 </span>            : 
<span class="lineNum">    4455 </span>            :         btrfs_cpu_key_to_disk(&amp;disk_key, new_key);
<span class="lineNum">    4456 </span>            :         btrfs_set_item_key(leaf, &amp;disk_key, slot);
<span class="lineNum">    4457 </span>            : 
<span class="lineNum">    4458 </span>            :         new_item = btrfs_item_nr(slot);
<span class="lineNum">    4459 </span>            : 
<span class="lineNum">    4460 </span>            :         btrfs_set_item_offset(leaf, new_item, orig_offset);
<span class="lineNum">    4461 </span><span class="lineCov">       1183 :         btrfs_set_item_size(leaf, new_item, item_size - split_offset);</span>
<span class="lineNum">    4462 </span>            : 
<span class="lineNum">    4463 </span><span class="lineCov">       1183 :         btrfs_set_item_offset(leaf, item,</span>
<span class="lineNum">    4464 </span><span class="lineCov">       1183 :                               orig_offset + item_size - split_offset);</span>
<span class="lineNum">    4465 </span>            :         btrfs_set_item_size(leaf, item, split_offset);
<span class="lineNum">    4466 </span>            : 
<span class="lineNum">    4467 </span><span class="lineCov">       1183 :         btrfs_set_header_nritems(leaf, nritems + 1);</span>
<span class="lineNum">    4468 </span>            : 
<span class="lineNum">    4469 </span>            :         /* write the data for the start of the original item */
<span class="lineNum">    4470 </span><span class="lineCov">       1183 :         write_extent_buffer(leaf, buf,</span>
<span class="lineNum">    4471 </span><span class="lineCov">       1183 :                             btrfs_item_ptr_offset(leaf, path-&gt;slots[0]),</span>
<span class="lineNum">    4472 </span>            :                             split_offset);
<span class="lineNum">    4473 </span>            : 
<span class="lineNum">    4474 </span>            :         /* write the data for the new item */
<span class="lineNum">    4475 </span><span class="lineCov">       2366 :         write_extent_buffer(leaf, buf + split_offset,</span>
<span class="lineNum">    4476 </span>            :                             btrfs_item_ptr_offset(leaf, slot),
<span class="lineNum">    4477 </span>            :                             item_size - split_offset);
<span class="lineNum">    4478 </span><span class="lineCov">       1183 :         btrfs_mark_buffer_dirty(leaf);</span>
<span class="lineNum">    4479 </span>            : 
<span class="lineNum">    4480 </span><span class="lineCov">       1183 :         BUG_ON(btrfs_leaf_free_space(root, leaf) &lt; 0);</span>
<span class="lineNum">    4481 </span><span class="lineCov">       1183 :         kfree(buf);</span>
<span class="lineNum">    4482 </span>            :         return 0;
<span class="lineNum">    4483 </span>            : }
<span class="lineNum">    4484 </span>            : 
<span class="lineNum">    4485 </span>            : /*
<span class="lineNum">    4486 </span>            :  * This function splits a single item into two items,
<span class="lineNum">    4487 </span>            :  * giving 'new_key' to the new item and splitting the
<span class="lineNum">    4488 </span>            :  * old one at split_offset (from the start of the item).
<span class="lineNum">    4489 </span>            :  *
<span class="lineNum">    4490 </span>            :  * The path may be released by this operation.  After
<span class="lineNum">    4491 </span>            :  * the split, the path is pointing to the old item.  The
<span class="lineNum">    4492 </span>            :  * new item is going to be in the same node as the old one.
<span class="lineNum">    4493 </span>            :  *
<span class="lineNum">    4494 </span>            :  * Note, the item being split must be smaller enough to live alone on
<span class="lineNum">    4495 </span>            :  * a tree block with room for one extra struct btrfs_item
<span class="lineNum">    4496 </span>            :  *
<span class="lineNum">    4497 </span>            :  * This allows us to split the item in place, keeping a lock on the
<a name="4498"><span class="lineNum">    4498 </span>            :  * leaf the entire time.</a>
<span class="lineNum">    4499 </span>            :  */
<span class="lineNum">    4500 </span><span class="lineCov">       1183 : int btrfs_split_item(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    4501 </span>            :                      struct btrfs_root *root,
<span class="lineNum">    4502 </span>            :                      struct btrfs_path *path,
<span class="lineNum">    4503 </span>            :                      struct btrfs_key *new_key,
<span class="lineNum">    4504 </span>            :                      unsigned long split_offset)
<span class="lineNum">    4505 </span>            : {
<span class="lineNum">    4506 </span>            :         int ret;
<span class="lineNum">    4507 </span><span class="lineCov">       1183 :         ret = setup_leaf_for_split(trans, root, path,</span>
<span class="lineNum">    4508 </span>            :                                    sizeof(struct btrfs_item));
<span class="lineNum">    4509 </span><span class="lineCov">       1183 :         if (ret)</span>
<span class="lineNum">    4510 </span>            :                 return ret;
<span class="lineNum">    4511 </span>            : 
<span class="lineNum">    4512 </span><span class="lineCov">       1183 :         ret = split_item(trans, root, path, new_key, split_offset);</span>
<span class="lineNum">    4513 </span><span class="lineCov">       1183 :         return ret;</span>
<span class="lineNum">    4514 </span>            : }
<span class="lineNum">    4515 </span>            : 
<span class="lineNum">    4516 </span>            : /*
<span class="lineNum">    4517 </span>            :  * This function duplicate a item, giving 'new_key' to the new item.
<span class="lineNum">    4518 </span>            :  * It guarantees both items live in the same tree leaf and the new item
<span class="lineNum">    4519 </span>            :  * is contiguous with the original item.
<span class="lineNum">    4520 </span>            :  *
<span class="lineNum">    4521 </span>            :  * This allows us to split file extent in place, keeping a lock on the
<a name="4522"><span class="lineNum">    4522 </span>            :  * leaf the entire time.</a>
<span class="lineNum">    4523 </span>            :  */
<span class="lineNum">    4524 </span><span class="lineCov">       2063 : int btrfs_duplicate_item(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    4525 </span>            :                          struct btrfs_root *root,
<span class="lineNum">    4526 </span>            :                          struct btrfs_path *path,
<span class="lineNum">    4527 </span>            :                          struct btrfs_key *new_key)
<span class="lineNum">    4528 </span>            : {
<span class="lineNum">    4529 </span>            :         struct extent_buffer *leaf;
<span class="lineNum">    4530 </span>            :         int ret;
<span class="lineNum">    4531 </span>            :         u32 item_size;
<span class="lineNum">    4532 </span>            : 
<span class="lineNum">    4533 </span><span class="lineCov">       2063 :         leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4534 </span><span class="lineCov">       4126 :         item_size = btrfs_item_size_nr(leaf, path-&gt;slots[0]);</span>
<span class="lineNum">    4535 </span><span class="lineCov">       2063 :         ret = setup_leaf_for_split(trans, root, path,</span>
<span class="lineNum">    4536 </span>            :                                    item_size + sizeof(struct btrfs_item));
<span class="lineNum">    4537 </span><span class="lineCov">       2063 :         if (ret)</span>
<span class="lineNum">    4538 </span>            :                 return ret;
<span class="lineNum">    4539 </span>            : 
<span class="lineNum">    4540 </span><span class="lineCov">       2061 :         path-&gt;slots[0]++;</span>
<span class="lineNum">    4541 </span><span class="lineCov">       2061 :         setup_items_for_insert(root, path, new_key, &amp;item_size,</span>
<span class="lineNum">    4542 </span>            :                                item_size, item_size +
<span class="lineNum">    4543 </span>            :                                sizeof(struct btrfs_item), 1);
<span class="lineNum">    4544 </span><span class="lineCov">       2061 :         leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4545 </span><span class="lineCov">       6183 :         memcpy_extent_buffer(leaf,</span>
<span class="lineNum">    4546 </span><span class="lineCov">       2061 :                              btrfs_item_ptr_offset(leaf, path-&gt;slots[0]),</span>
<span class="lineNum">    4547 </span><span class="lineCov">       2061 :                              btrfs_item_ptr_offset(leaf, path-&gt;slots[0] - 1),</span>
<span class="lineNum">    4548 </span>            :                              item_size);
<span class="lineNum">    4549 </span><span class="lineCov">       2061 :         return 0;</span>
<span class="lineNum">    4550 </span>            : }
<span class="lineNum">    4551 </span>            : 
<span class="lineNum">    4552 </span>            : /*
<span class="lineNum">    4553 </span>            :  * make the item pointed to by the path smaller.  new_size indicates
<span class="lineNum">    4554 </span>            :  * how small to make it, and from_end tells us if we just chop bytes
<span class="lineNum">    4555 </span>            :  * off the end of the item or if we shift the item to chop bytes off
<a name="4556"><span class="lineNum">    4556 </span>            :  * the front.</a>
<span class="lineNum">    4557 </span>            :  */
<span class="lineNum">    4558 </span><span class="lineCov">      16006 : void btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,</span>
<span class="lineNum">    4559 </span>            :                          u32 new_size, int from_end)
<span class="lineNum">    4560 </span>            : {
<span class="lineNum">    4561 </span>            :         int slot;
<span class="lineNum">    4562 </span><span class="lineCov">      16006 :         struct extent_buffer *leaf;</span>
<span class="lineNum">    4563 </span>            :         struct btrfs_item *item;
<span class="lineNum">    4564 </span>            :         u32 nritems;
<span class="lineNum">    4565 </span>            :         unsigned int data_end;
<span class="lineNum">    4566 </span>            :         unsigned int old_data_start;
<span class="lineNum">    4567 </span>            :         unsigned int old_size;
<span class="lineNum">    4568 </span>            :         unsigned int size_diff;
<span class="lineNum">    4569 </span>            :         int i;
<span class="lineNum">    4570 </span>            :         struct btrfs_map_token token;
<span class="lineNum">    4571 </span>            : 
<span class="lineNum">    4572 </span>            :         btrfs_init_map_token(&amp;token);
<span class="lineNum">    4573 </span>            : 
<span class="lineNum">    4574 </span><span class="lineCov">      16006 :         leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4575 </span><span class="lineCov">      16006 :         slot = path-&gt;slots[0];</span>
<span class="lineNum">    4576 </span>            : 
<span class="lineNum">    4577 </span>            :         old_size = btrfs_item_size_nr(leaf, slot);
<span class="lineNum">    4578 </span><span class="lineCov">      16006 :         if (old_size == new_size)</span>
<span class="lineNum">    4579 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    4580 </span>            : 
<span class="lineNum">    4581 </span>            :         nritems = btrfs_header_nritems(leaf);
<span class="lineNum">    4582 </span><span class="lineCov">      16006 :         data_end = leaf_data_end(root, leaf);</span>
<span class="lineNum">    4583 </span>            : 
<span class="lineNum">    4584 </span>            :         old_data_start = btrfs_item_offset_nr(leaf, slot);
<span class="lineNum">    4585 </span>            : 
<span class="lineNum">    4586 </span><span class="lineCov">      16006 :         size_diff = old_size - new_size;</span>
<span class="lineNum">    4587 </span>            : 
<span class="lineNum">    4588 </span><span class="lineCov">      16006 :         BUG_ON(slot &lt; 0);</span>
<span class="lineNum">    4589 </span><span class="lineCov">      16006 :         BUG_ON(slot &gt;= nritems);</span>
<span class="lineNum">    4590 </span>            : 
<span class="lineNum">    4591 </span>            :         /*
<span class="lineNum">    4592 </span>            :          * item0..itemN ... dataN.offset..dataN.size .. data0.size
<span class="lineNum">    4593 </span>            :          */
<span class="lineNum">    4594 </span>            :         /* first correct the data pointers */
<span class="lineNum">    4595 </span><span class="lineCov">    1293333 :         for (i = slot; i &lt; nritems; i++) {</span>
<span class="lineNum">    4596 </span>            :                 u32 ioff;
<span class="lineNum">    4597 </span>            :                 item = btrfs_item_nr(i);
<span class="lineNum">    4598 </span>            : 
<span class="lineNum">    4599 </span>            :                 ioff = btrfs_token_item_offset(leaf, item, &amp;token);
<span class="lineNum">    4600 </span><span class="lineCov">    1293333 :                 btrfs_set_token_item_offset(leaf, item,</span>
<span class="lineNum">    4601 </span>            :                                             ioff + size_diff, &amp;token);
<span class="lineNum">    4602 </span>            :         }
<span class="lineNum">    4603 </span>            : 
<span class="lineNum">    4604 </span>            :         /* shift the data */
<span class="lineNum">    4605 </span><span class="lineCov">      16006 :         if (from_end) {</span>
<span class="lineNum">    4606 </span><span class="lineCov">      10801 :                 memmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +</span>
<span class="lineNum">    4607 </span>            :                               data_end + size_diff, btrfs_leaf_data(leaf) +
<span class="lineNum">    4608 </span><span class="lineCov">      10801 :                               data_end, old_data_start + new_size - data_end);</span>
<span class="lineNum">    4609 </span>            :         } else {
<span class="lineNum">    4610 </span>            :                 struct btrfs_disk_key disk_key;
<span class="lineNum">    4611 </span>            :                 u64 offset;
<span class="lineNum">    4612 </span>            : 
<span class="lineNum">    4613 </span>            :                 btrfs_item_key(leaf, &amp;disk_key, slot);
<span class="lineNum">    4614 </span>            : 
<span class="lineNum">    4615 </span><span class="lineCov">       5205 :                 if (btrfs_disk_key_type(&amp;disk_key) == BTRFS_EXTENT_DATA_KEY) {</span>
<span class="lineNum">    4616 </span>            :                         unsigned long ptr;
<span class="lineNum">    4617 </span>            :                         struct btrfs_file_extent_item *fi;
<span class="lineNum">    4618 </span>            : 
<span class="lineNum">    4619 </span><span class="lineNoCov">          0 :                         fi = btrfs_item_ptr(leaf, slot,</span>
<span class="lineNum">    4620 </span>            :                                             struct btrfs_file_extent_item);
<span class="lineNum">    4621 </span><span class="lineNoCov">          0 :                         fi = (struct btrfs_file_extent_item *)(</span>
<span class="lineNum">    4622 </span><span class="lineNoCov">          0 :                              (unsigned long)fi - size_diff);</span>
<span class="lineNum">    4623 </span>            : 
<span class="lineNum">    4624 </span><span class="lineNoCov">          0 :                         if (btrfs_file_extent_type(leaf, fi) ==</span>
<span class="lineNum">    4625 </span>            :                             BTRFS_FILE_EXTENT_INLINE) {
<span class="lineNum">    4626 </span><span class="lineNoCov">          0 :                                 ptr = btrfs_item_ptr_offset(leaf, slot);</span>
<span class="lineNum">    4627 </span><span class="lineNoCov">          0 :                                 memmove_extent_buffer(leaf, ptr,</span>
<span class="lineNum">    4628 </span>            :                                       (unsigned long)fi,
<span class="lineNum">    4629 </span>            :                                       offsetof(struct btrfs_file_extent_item,
<span class="lineNum">    4630 </span>            :                                                  disk_bytenr));
<span class="lineNum">    4631 </span>            :                         }
<span class="lineNum">    4632 </span>            :                 }
<span class="lineNum">    4633 </span>            : 
<span class="lineNum">    4634 </span><span class="lineCov">       5205 :                 memmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +</span>
<span class="lineNum">    4635 </span>            :                               data_end + size_diff, btrfs_leaf_data(leaf) +
<span class="lineNum">    4636 </span><span class="lineCov">       5205 :                               data_end, old_data_start - data_end);</span>
<span class="lineNum">    4637 </span>            : 
<span class="lineNum">    4638 </span>            :                 offset = btrfs_disk_key_offset(&amp;disk_key);
<span class="lineNum">    4639 </span><span class="lineCov">       5205 :                 btrfs_set_disk_key_offset(&amp;disk_key, offset + size_diff);</span>
<span class="lineNum">    4640 </span>            :                 btrfs_set_item_key(leaf, &amp;disk_key, slot);
<span class="lineNum">    4641 </span><span class="lineCov">       5205 :                 if (slot == 0)</span>
<span class="lineNum">    4642 </span><span class="lineCov">       1133 :                         fixup_low_keys(root, path, &amp;disk_key, 1);</span>
<span class="lineNum">    4643 </span>            :         }
<span class="lineNum">    4644 </span>            : 
<span class="lineNum">    4645 </span>            :         item = btrfs_item_nr(slot);
<span class="lineNum">    4646 </span>            :         btrfs_set_item_size(leaf, item, new_size);
<span class="lineNum">    4647 </span><span class="lineCov">      16006 :         btrfs_mark_buffer_dirty(leaf);</span>
<span class="lineNum">    4648 </span>            : 
<span class="lineNum">    4649 </span><span class="lineCov">      16006 :         if (btrfs_leaf_free_space(root, leaf) &lt; 0) {</span>
<span class="lineNum">    4650 </span><span class="lineNoCov">          0 :                 btrfs_print_leaf(root, leaf);</span>
<span class="lineNum">    4651 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">    4652 </span>            :         }
<span class="lineNum">    4653 </span>            : }
<span class="lineNum">    4654 </span>            : 
<span class="lineNum">    4655 </span>            : /*
<a name="4656"><span class="lineNum">    4656 </span>            :  * make the item pointed to by the path bigger, data_size is the added size.</a>
<span class="lineNum">    4657 </span>            :  */
<span class="lineNum">    4658 </span><span class="lineCov">      98804 : void btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,</span>
<span class="lineNum">    4659 </span>            :                        u32 data_size)
<span class="lineNum">    4660 </span>            : {
<span class="lineNum">    4661 </span>            :         int slot;
<span class="lineNum">    4662 </span><span class="lineCov">      98804 :         struct extent_buffer *leaf;</span>
<span class="lineNum">    4663 </span>            :         struct btrfs_item *item;
<span class="lineNum">    4664 </span>            :         u32 nritems;
<span class="lineNum">    4665 </span>            :         unsigned int data_end;
<span class="lineNum">    4666 </span>            :         unsigned int old_data;
<span class="lineNum">    4667 </span>            :         unsigned int old_size;
<span class="lineNum">    4668 </span>            :         int i;
<span class="lineNum">    4669 </span>            :         struct btrfs_map_token token;
<span class="lineNum">    4670 </span>            : 
<span class="lineNum">    4671 </span>            :         btrfs_init_map_token(&amp;token);
<span class="lineNum">    4672 </span>            : 
<span class="lineNum">    4673 </span><span class="lineCov">      98804 :         leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4674 </span>            : 
<span class="lineNum">    4675 </span>            :         nritems = btrfs_header_nritems(leaf);
<span class="lineNum">    4676 </span><span class="lineCov">      98804 :         data_end = leaf_data_end(root, leaf);</span>
<span class="lineNum">    4677 </span>            : 
<span class="lineNum">    4678 </span><span class="lineCov">      98804 :         if (btrfs_leaf_free_space(root, leaf) &lt; data_size) {</span>
<span class="lineNum">    4679 </span><span class="lineNoCov">          0 :                 btrfs_print_leaf(root, leaf);</span>
<span class="lineNum">    4680 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">    4681 </span>            :         }
<span class="lineNum">    4682 </span><span class="lineCov">      98804 :         slot = path-&gt;slots[0];</span>
<span class="lineNum">    4683 </span>            :         old_data = btrfs_item_end_nr(leaf, slot);
<span class="lineNum">    4684 </span>            : 
<span class="lineNum">    4685 </span><span class="lineCov">      98823 :         BUG_ON(slot &lt; 0);</span>
<span class="lineNum">    4686 </span><span class="lineCov">      98823 :         if (slot &gt;= nritems) {</span>
<span class="lineNum">    4687 </span><span class="lineNoCov">          0 :                 btrfs_print_leaf(root, leaf);</span>
<span class="lineNum">    4688 </span><span class="lineNoCov">          0 :                 btrfs_crit(root-&gt;fs_info, &quot;slot %d too large, nritems %d&quot;,</span>
<span class="lineNum">    4689 </span>            :                        slot, nritems);
<span class="lineNum">    4690 </span><span class="lineNoCov">          0 :                 BUG_ON(1);</span>
<span class="lineNum">    4691 </span>            :         }
<span class="lineNum">    4692 </span>            : 
<span class="lineNum">    4693 </span>            :         /*
<span class="lineNum">    4694 </span>            :          * item0..itemN ... dataN.offset..dataN.size .. data0.size
<span class="lineNum">    4695 </span>            :          */
<span class="lineNum">    4696 </span>            :         /* first correct the data pointers */
<span class="lineNum">    4697 </span><span class="lineCov">    1700248 :         for (i = slot; i &lt; nritems; i++) {</span>
<span class="lineNum">    4698 </span>            :                 u32 ioff;
<span class="lineNum">    4699 </span>            :                 item = btrfs_item_nr(i);
<span class="lineNum">    4700 </span>            : 
<span class="lineNum">    4701 </span>            :                 ioff = btrfs_token_item_offset(leaf, item, &amp;token);
<span class="lineNum">    4702 </span><span class="lineCov">    1700249 :                 btrfs_set_token_item_offset(leaf, item,</span>
<span class="lineNum">    4703 </span>            :                                             ioff - data_size, &amp;token);
<span class="lineNum">    4704 </span>            :         }
<span class="lineNum">    4705 </span>            : 
<span class="lineNum">    4706 </span>            :         /* shift the data */
<span class="lineNum">    4707 </span><span class="lineCov">      98804 :         memmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +</span>
<span class="lineNum">    4708 </span>            :                       data_end - data_size, btrfs_leaf_data(leaf) +
<span class="lineNum">    4709 </span><span class="lineCov">      98804 :                       data_end, old_data - data_end);</span>
<span class="lineNum">    4710 </span>            : 
<span class="lineNum">    4711 </span>            :         data_end = old_data;
<span class="lineNum">    4712 </span>            :         old_size = btrfs_item_size_nr(leaf, slot);
<span class="lineNum">    4713 </span>            :         item = btrfs_item_nr(slot);
<span class="lineNum">    4714 </span><span class="lineCov">      98803 :         btrfs_set_item_size(leaf, item, old_size + data_size);</span>
<span class="lineNum">    4715 </span><span class="lineCov">      98803 :         btrfs_mark_buffer_dirty(leaf);</span>
<span class="lineNum">    4716 </span>            : 
<span class="lineNum">    4717 </span><span class="lineCov">      98803 :         if (btrfs_leaf_free_space(root, leaf) &lt; 0) {</span>
<span class="lineNum">    4718 </span><span class="lineNoCov">          0 :                 btrfs_print_leaf(root, leaf);</span>
<span class="lineNum">    4719 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">    4720 </span>            :         }
<span class="lineNum">    4721 </span><span class="lineCov">      98802 : }</span>
<span class="lineNum">    4722 </span>            : 
<span class="lineNum">    4723 </span>            : /*
<span class="lineNum">    4724 </span>            :  * this is a helper for btrfs_insert_empty_items, the main goal here is
<span class="lineNum">    4725 </span>            :  * to save stack depth by doing the bulk of the work in a function
<a name="4726"><span class="lineNum">    4726 </span>            :  * that doesn't call btrfs_search_slot</a>
<span class="lineNum">    4727 </span>            :  */
<span class="lineNum">    4728 </span><span class="lineCov">     264568 : void setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,</span>
<span class="lineNum">    4729 </span>            :                             struct btrfs_key *cpu_key, u32 *data_size,
<span class="lineNum">    4730 </span>            :                             u32 total_data, u32 total_size, int nr)
<span class="lineNum">    4731 </span>            : {
<span class="lineNum">    4732 </span>            :         struct btrfs_item *item;
<span class="lineNum">    4733 </span>            :         int i;
<span class="lineNum">    4734 </span>            :         u32 nritems;
<span class="lineNum">    4735 </span>            :         unsigned int data_end;
<span class="lineNum">    4736 </span>            :         struct btrfs_disk_key disk_key;
<span class="lineNum">    4737 </span><span class="lineCov">     529126 :         struct extent_buffer *leaf;</span>
<span class="lineNum">    4738 </span>            :         int slot;
<span class="lineNum">    4739 </span>            :         struct btrfs_map_token token;
<span class="lineNum">    4740 </span>            : 
<span class="lineNum">    4741 </span>            :         btrfs_init_map_token(&amp;token);
<span class="lineNum">    4742 </span>            : 
<span class="lineNum">    4743 </span><span class="lineCov">     264568 :         leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4744 </span><span class="lineCov">     264568 :         slot = path-&gt;slots[0];</span>
<span class="lineNum">    4745 </span>            : 
<span class="lineNum">    4746 </span>            :         nritems = btrfs_header_nritems(leaf);
<span class="lineNum">    4747 </span><span class="lineCov">     264568 :         data_end = leaf_data_end(root, leaf);</span>
<span class="lineNum">    4748 </span>            : 
<span class="lineNum">    4749 </span><span class="lineCov">     264561 :         if (btrfs_leaf_free_space(root, leaf) &lt; total_size) {</span>
<span class="lineNum">    4750 </span><span class="lineNoCov">          0 :                 btrfs_print_leaf(root, leaf);</span>
<span class="lineNum">    4751 </span><span class="lineNoCov">          0 :                 btrfs_crit(root-&gt;fs_info, &quot;not enough freespace need %u have %d&quot;,</span>
<span class="lineNum">    4752 </span>            :                        total_size, btrfs_leaf_free_space(root, leaf));
<span class="lineNum">    4753 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">    4754 </span>            :         }
<span class="lineNum">    4755 </span>            : 
<span class="lineNum">    4756 </span><span class="lineCov">     264543 :         if (slot != nritems) {</span>
<span class="lineNum">    4757 </span>            :                 unsigned int old_data = btrfs_item_end_nr(leaf, slot);
<span class="lineNum">    4758 </span>            : 
<span class="lineNum">    4759 </span><span class="lineCov">     183630 :                 if (old_data &lt; data_end) {</span>
<span class="lineNum">    4760 </span><span class="lineNoCov">          0 :                         btrfs_print_leaf(root, leaf);</span>
<span class="lineNum">    4761 </span><span class="lineNoCov">          0 :                         btrfs_crit(root-&gt;fs_info, &quot;slot %d old_data %d data_end %d&quot;,</span>
<span class="lineNum">    4762 </span>            :                                slot, old_data, data_end);
<span class="lineNum">    4763 </span><span class="lineNoCov">          0 :                         BUG_ON(1);</span>
<span class="lineNum">    4764 </span>            :                 }
<span class="lineNum">    4765 </span>            :                 /*
<span class="lineNum">    4766 </span>            :                  * item0..itemN ... dataN.offset..dataN.size .. data0.size
<span class="lineNum">    4767 </span>            :                  */
<span class="lineNum">    4768 </span>            :                 /* first correct the data pointers */
<span class="lineNum">    4769 </span><span class="lineCov">   10554215 :                 for (i = slot; i &lt; nritems; i++) {</span>
<span class="lineNum">    4770 </span>            :                         u32 ioff;
<span class="lineNum">    4771 </span>            : 
<span class="lineNum">    4772 </span>            :                         item = btrfs_item_nr( i);
<span class="lineNum">    4773 </span>            :                         ioff = btrfs_token_item_offset(leaf, item, &amp;token);
<span class="lineNum">    4774 </span><span class="lineCov">   10554227 :                         btrfs_set_token_item_offset(leaf, item,</span>
<span class="lineNum">    4775 </span>            :                                                     ioff - total_data, &amp;token);
<span class="lineNum">    4776 </span>            :                 }
<span class="lineNum">    4777 </span>            :                 /* shift the items */
<span class="lineNum">    4778 </span><span class="lineCov">     367242 :                 memmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),</span>
<span class="lineNum">    4779 </span>            :                               btrfs_item_nr_offset(slot),
<span class="lineNum">    4780 </span><span class="lineCov">     183621 :                               (nritems - slot) * sizeof(struct btrfs_item));</span>
<span class="lineNum">    4781 </span>            : 
<span class="lineNum">    4782 </span>            :                 /* shift the data */
<span class="lineNum">    4783 </span><span class="lineCov">     183622 :                 memmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +</span>
<span class="lineNum">    4784 </span>            :                               data_end - total_data, btrfs_leaf_data(leaf) +
<span class="lineNum">    4785 </span><span class="lineCov">     183622 :                               data_end, old_data - data_end);</span>
<span class="lineNum">    4786 </span>            :                 data_end = old_data;
<span class="lineNum">    4787 </span>            :         }
<span class="lineNum">    4788 </span>            : 
<span class="lineNum">    4789 </span>            :         /* setup the item for the new data */
<span class="lineNum">    4790 </span><span class="lineCov">     310631 :         for (i = 0; i &lt; nr; i++) {</span>
<span class="lineNum">    4791 </span><span class="lineCov">     310640 :                 btrfs_cpu_key_to_disk(&amp;disk_key, cpu_key + i);</span>
<span class="lineNum">    4792 </span><span class="lineCov">     310640 :                 btrfs_set_item_key(leaf, &amp;disk_key, slot + i);</span>
<span class="lineNum">    4793 </span>            :                 item = btrfs_item_nr(slot + i);
<span class="lineNum">    4794 </span><span class="lineCov">     310655 :                 btrfs_set_token_item_offset(leaf, item,</span>
<span class="lineNum">    4795 </span><span class="lineCov">     310655 :                                             data_end - data_size[i], &amp;token);</span>
<span class="lineNum">    4796 </span><span class="lineCov">     310644 :                 data_end -= data_size[i];</span>
<span class="lineNum">    4797 </span>            :                 btrfs_set_token_item_size(leaf, item, data_size[i], &amp;token);
<span class="lineNum">    4798 </span>            :         }
<span class="lineNum">    4799 </span>            : 
<span class="lineNum">    4800 </span><span class="lineCov">     264558 :         btrfs_set_header_nritems(leaf, nritems + nr);</span>
<span class="lineNum">    4801 </span>            : 
<span class="lineNum">    4802 </span><span class="lineCov">     264558 :         if (slot == 0) {</span>
<span class="lineNum">    4803 </span>            :                 btrfs_cpu_key_to_disk(&amp;disk_key, cpu_key);
<span class="lineNum">    4804 </span><span class="lineCov">       3663 :                 fixup_low_keys(root, path, &amp;disk_key, 1);</span>
<span class="lineNum">    4805 </span>            :         }
<span class="lineNum">    4806 </span><span class="lineCov">     264558 :         btrfs_unlock_up_safe(path, 1);</span>
<span class="lineNum">    4807 </span><span class="lineCov">     264576 :         btrfs_mark_buffer_dirty(leaf);</span>
<span class="lineNum">    4808 </span>            : 
<span class="lineNum">    4809 </span><span class="lineCov">     264596 :         if (btrfs_leaf_free_space(root, leaf) &lt; 0) {</span>
<span class="lineNum">    4810 </span><span class="lineNoCov">          0 :                 btrfs_print_leaf(root, leaf);</span>
<span class="lineNum">    4811 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">    4812 </span>            :         }
<span class="lineNum">    4813 </span><span class="lineCov">     264544 : }</span>
<span class="lineNum">    4814 </span>            : 
<span class="lineNum">    4815 </span>            : /*
<span class="lineNum">    4816 </span>            :  * Given a key and some data, insert items into the tree.
<a name="4817"><span class="lineNum">    4817 </span>            :  * This does all the path init required, making room in the tree if needed.</a>
<span class="lineNum">    4818 </span>            :  */
<span class="lineNum">    4819 </span><span class="lineCov">     212207 : int btrfs_insert_empty_items(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    4820 </span>            :                             struct btrfs_root *root,
<span class="lineNum">    4821 </span>            :                             struct btrfs_path *path,
<span class="lineNum">    4822 </span>            :                             struct btrfs_key *cpu_key, u32 *data_size,
<span class="lineNum">    4823 </span>            :                             int nr)
<span class="lineNum">    4824 </span>            : {
<span class="lineNum">    4825 </span>            :         int ret = 0;
<span class="lineNum">    4826 </span>            :         int slot;
<span class="lineNum">    4827 </span>            :         int i;
<span class="lineNum">    4828 </span>            :         u32 total_size = 0;
<span class="lineNum">    4829 </span>            :         u32 total_data = 0;
<span class="lineNum">    4830 </span>            : 
<span class="lineNum">    4831 </span><span class="lineCov">     456894 :         for (i = 0; i &lt; nr; i++)</span>
<span class="lineNum">    4832 </span><span class="lineCov">     244687 :                 total_data += data_size[i];</span>
<span class="lineNum">    4833 </span>            : 
<span class="lineNum">    4834 </span><span class="lineCov">     212207 :         total_size = total_data + (nr * sizeof(struct btrfs_item));</span>
<span class="lineNum">    4835 </span><span class="lineCov">     212207 :         ret = btrfs_search_slot(trans, root, cpu_key, path, total_size, 1);</span>
<span class="lineNum">    4836 </span><span class="lineCov">     212209 :         if (ret == 0)</span>
<span class="lineNum">    4837 </span>            :                 return -EEXIST;
<span class="lineNum">    4838 </span><span class="lineCov">     210124 :         if (ret &lt; 0)</span>
<span class="lineNum">    4839 </span>            :                 return ret;
<span class="lineNum">    4840 </span>            : 
<span class="lineNum">    4841 </span><span class="lineCov">     208196 :         slot = path-&gt;slots[0];</span>
<span class="lineNum">    4842 </span><span class="lineCov">     208196 :         BUG_ON(slot &lt; 0);</span>
<span class="lineNum">    4843 </span>            : 
<span class="lineNum">    4844 </span><span class="lineCov">     208196 :         setup_items_for_insert(root, path, cpu_key, data_size,</span>
<span class="lineNum">    4845 </span>            :                                total_data, total_size, nr);
<span class="lineNum">    4846 </span><span class="lineCov">     208179 :         return 0;</span>
<span class="lineNum">    4847 </span>            : }
<span class="lineNum">    4848 </span>            : 
<span class="lineNum">    4849 </span>            : /*
<span class="lineNum">    4850 </span>            :  * Given a key and some data, insert an item into the tree.
<span class="lineNum">    4851 </span>            :  * This does all the path init required, making room in the tree if needed.
<span class="lineNum">    4852 </span>            :  */
<span class="lineNum">    4853 </span><span class="lineCov">       1136 : int btrfs_insert_item(struct btrfs_trans_handle *trans, struct btrfs_root</span>
<span class="lineNum">    4854 </span>            :                       *root, struct btrfs_key *cpu_key, void *data, u32
<span class="lineNum">    4855 </span>            :                       data_size)
<span class="lineNum">    4856 </span>            : {
<span class="lineNum">    4857 </span>            :         int ret = 0;
<span class="lineNum">    4858 </span>            :         struct btrfs_path *path;
<span class="lineNum">    4859 </span>            :         struct extent_buffer *leaf;
<span class="lineNum">    4860 </span>            :         unsigned long ptr;
<span class="lineNum">    4861 </span>            : 
<span class="lineNum">    4862 </span>            :         path = btrfs_alloc_path();
<span class="lineNum">    4863 </span><span class="lineCov">       1136 :         if (!path)</span>
<span class="lineNum">    4864 </span>            :                 return -ENOMEM;
<span class="lineNum">    4865 </span>            :         ret = btrfs_insert_empty_item(trans, root, path, cpu_key, data_size);
<span class="lineNum">    4866 </span><span class="lineCov">       1136 :         if (!ret) {</span>
<span class="lineNum">    4867 </span><span class="lineCov">       1136 :                 leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4868 </span><span class="lineCov">       2272 :                 ptr = btrfs_item_ptr_offset(leaf, path-&gt;slots[0]);</span>
<span class="lineNum">    4869 </span><span class="lineCov">       1136 :                 write_extent_buffer(leaf, data, ptr, data_size);</span>
<span class="lineNum">    4870 </span><span class="lineCov">       1136 :                 btrfs_mark_buffer_dirty(leaf);</span>
<span class="lineNum">    4871 </span>            :         }
<span class="lineNum">    4872 </span><span class="lineCov">       1136 :         btrfs_free_path(path);</span>
<span class="lineNum">    4873 </span><span class="lineCov">       1136 :         return ret;</span>
<span class="lineNum">    4874 </span>            : }
<span class="lineNum">    4875 </span>            : 
<span class="lineNum">    4876 </span>            : /*
<span class="lineNum">    4877 </span>            :  * delete the pointer from a given node.
<span class="lineNum">    4878 </span>            :  *
<span class="lineNum">    4879 </span>            :  * the tree should have been previously balanced so the deletion does not
<a name="4880"><span class="lineNum">    4880 </span>            :  * empty a node.</a>
<span class="lineNum">    4881 </span>            :  */
<span class="lineNum">    4882 </span><span class="lineCov">       1371 : static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,</span>
<span class="lineNum">    4883 </span>            :                     int level, int slot)
<span class="lineNum">    4884 </span>            : {
<span class="lineNum">    4885 </span><span class="lineCov">       2742 :         struct extent_buffer *parent = path-&gt;nodes[level];</span>
<span class="lineNum">    4886 </span>            :         u32 nritems;
<span class="lineNum">    4887 </span>            :         int ret;
<span class="lineNum">    4888 </span>            : 
<span class="lineNum">    4889 </span>            :         nritems = btrfs_header_nritems(parent);
<span class="lineNum">    4890 </span><span class="lineCov">       1371 :         if (slot != nritems - 1) {</span>
<span class="lineNum">    4891 </span><span class="lineCov">       1215 :                 if (level)</span>
<span class="lineNum">    4892 </span><span class="lineCov">       1215 :                         tree_mod_log_eb_move(root-&gt;fs_info, parent, slot,</span>
<span class="lineNum">    4893 </span><span class="lineCov">       1215 :                                              slot + 1, nritems - slot - 1);</span>
<span class="lineNum">    4894 </span><span class="lineCov">       2430 :                 memmove_extent_buffer(parent,</span>
<span class="lineNum">    4895 </span>            :                               btrfs_node_key_ptr_offset(slot),
<span class="lineNum">    4896 </span>            :                               btrfs_node_key_ptr_offset(slot + 1),
<span class="lineNum">    4897 </span>            :                               sizeof(struct btrfs_key_ptr) *
<span class="lineNum">    4898 </span><span class="lineCov">       1215 :                               (nritems - slot - 1));</span>
<span class="lineNum">    4899 </span><span class="lineCov">        156 :         } else if (level) {</span>
<span class="lineNum">    4900 </span><span class="lineCov">        156 :                 ret = tree_mod_log_insert_key(root-&gt;fs_info, parent, slot,</span>
<span class="lineNum">    4901 </span>            :                                               MOD_LOG_KEY_REMOVE, GFP_NOFS);
<span class="lineNum">    4902 </span><span class="lineCov">        156 :                 BUG_ON(ret &lt; 0);</span>
<span class="lineNum">    4903 </span>            :         }
<span class="lineNum">    4904 </span>            : 
<span class="lineNum">    4905 </span>            :         nritems--;
<span class="lineNum">    4906 </span>            :         btrfs_set_header_nritems(parent, nritems);
<span class="lineNum">    4907 </span><span class="lineCov">       1371 :         if (nritems == 0 &amp;&amp; parent == root-&gt;node) {</span>
<span class="lineNum">    4908 </span><span class="lineNoCov">          0 :                 BUG_ON(btrfs_header_level(root-&gt;node) != 1);</span>
<span class="lineNum">    4909 </span>            :                 /* just turn the root into a leaf and break */
<span class="lineNum">    4910 </span>            :                 btrfs_set_header_level(root-&gt;node, 0);
<span class="lineNum">    4911 </span><span class="lineCov">       1371 :         } else if (slot == 0) {</span>
<span class="lineNum">    4912 </span>            :                 struct btrfs_disk_key disk_key;
<span class="lineNum">    4913 </span>            : 
<span class="lineNum">    4914 </span><span class="lineCov">         80 :                 btrfs_node_key(parent, &amp;disk_key, 0);</span>
<span class="lineNum">    4915 </span><span class="lineCov">         80 :                 fixup_low_keys(root, path, &amp;disk_key, level + 1);</span>
<span class="lineNum">    4916 </span>            :         }
<span class="lineNum">    4917 </span><span class="lineCov">       1371 :         btrfs_mark_buffer_dirty(parent);</span>
<span class="lineNum">    4918 </span><span class="lineCov">       1371 : }</span>
<span class="lineNum">    4919 </span>            : 
<span class="lineNum">    4920 </span>            : /*
<span class="lineNum">    4921 </span>            :  * a helper function to delete the leaf pointed to by path-&gt;slots[1] and
<span class="lineNum">    4922 </span>            :  * path-&gt;nodes[1].
<span class="lineNum">    4923 </span>            :  *
<span class="lineNum">    4924 </span>            :  * This deletes the pointer in path-&gt;nodes[1] and frees the leaf
<span class="lineNum">    4925 </span>            :  * block extent.  zero is returned if it all worked out, &lt; 0 otherwise.
<span class="lineNum">    4926 </span>            :  *
<span class="lineNum">    4927 </span>            :  * The path must have already been setup for deleting the leaf, including
<span class="lineNum">    4928 </span>            :  * all the proper balancing.  path-&gt;nodes[1] must be locked.
<span class="lineNum">    4929 </span>            :  */
<span class="lineNum">    4930 </span><span class="lineCov">       1360 : static noinline void btrfs_del_leaf(struct btrfs_trans_handle *trans,</span>
<span class="lineNum">    4931 </span>            :                                     struct btrfs_root *root,
<span class="lineNum">    4932 </span>            :                                     struct btrfs_path *path,
<span class="lineNum">    4933 </span><span class="lineCov">       1360 :                                     struct extent_buffer *leaf)</span>
<span class="lineNum">    4934 </span>            : {
<span class="lineNum">    4935 </span><span class="lineCov">       1360 :         WARN_ON(btrfs_header_generation(leaf) != trans-&gt;transid);</span>
<span class="lineNum">    4936 </span><span class="lineCov">       1360 :         del_ptr(root, path, 1, path-&gt;slots[1]);</span>
<span class="lineNum">    4937 </span>            : 
<span class="lineNum">    4938 </span>            :         /*
<span class="lineNum">    4939 </span>            :          * btrfs_free_extent is expensive, we want to make sure we
<span class="lineNum">    4940 </span>            :          * aren't holding any locks when we call it
<span class="lineNum">    4941 </span>            :          */
<span class="lineNum">    4942 </span><span class="lineCov">       1360 :         btrfs_unlock_up_safe(path, 0);</span>
<span class="lineNum">    4943 </span>            : 
<span class="lineNum">    4944 </span><span class="lineCov">       1360 :         root_sub_used(root, leaf-&gt;len);</span>
<span class="lineNum">    4945 </span>            : 
<span class="lineNum">    4946 </span>            :         extent_buffer_get(leaf);
<span class="lineNum">    4947 </span><span class="lineCov">       1360 :         btrfs_free_tree_block(trans, root, leaf, 0, 1);</span>
<span class="lineNum">    4948 </span><span class="lineCov">       1360 :         free_extent_buffer_stale(leaf);</span>
<span class="lineNum">    4949 </span><span class="lineCov">       1360 : }</span>
<span class="lineNum">    4950 </span>            : /*
<span class="lineNum">    4951 </span>            :  * delete the item at the leaf level in path.  If that empties
<a name="4952"><span class="lineNum">    4952 </span>            :  * the leaf, remove it from the tree</a>
<span class="lineNum">    4953 </span>            :  */
<span class="lineNum">    4954 </span><span class="lineCov">     124167 : int btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,</span>
<span class="lineNum">    4955 </span>            :                     struct btrfs_path *path, int slot, int nr)
<span class="lineNum">    4956 </span>            : {
<span class="lineNum">    4957 </span><span class="lineCov">     275542 :         struct extent_buffer *leaf;</span>
<span class="lineNum">    4958 </span>            :         struct btrfs_item *item;
<span class="lineNum">    4959 </span>            :         int last_off;
<span class="lineNum">    4960 </span>            :         int dsize = 0;
<span class="lineNum">    4961 </span>            :         int ret = 0;
<span class="lineNum">    4962 </span>            :         int wret;
<span class="lineNum">    4963 </span>            :         int i;
<span class="lineNum">    4964 </span>            :         u32 nritems;
<span class="lineNum">    4965 </span>            :         struct btrfs_map_token token;
<span class="lineNum">    4966 </span>            : 
<span class="lineNum">    4967 </span>            :         btrfs_init_map_token(&amp;token);
<span class="lineNum">    4968 </span>            : 
<span class="lineNum">    4969 </span><span class="lineCov">     124167 :         leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    4970 </span><span class="lineCov">     248335 :         last_off = btrfs_item_offset_nr(leaf, slot + nr - 1);</span>
<span class="lineNum">    4971 </span>            : 
<span class="lineNum">    4972 </span><span class="lineCov">     272602 :         for (i = 0; i &lt; nr; i++)</span>
<span class="lineNum">    4973 </span><span class="lineCov">     296869 :                 dsize += btrfs_item_size_nr(leaf, slot + i);</span>
<span class="lineNum">    4974 </span>            : 
<span class="lineNum">    4975 </span>            :         nritems = btrfs_header_nritems(leaf);
<span class="lineNum">    4976 </span>            : 
<span class="lineNum">    4977 </span><span class="lineCov">     124167 :         if (slot + nr != nritems) {</span>
<span class="lineNum">    4978 </span><span class="lineCov">     110684 :                 int data_end = leaf_data_end(root, leaf);</span>
<span class="lineNum">    4979 </span>            : 
<span class="lineNum">    4980 </span><span class="lineCov">     110684 :                 memmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +</span>
<span class="lineNum">    4981 </span>            :                               data_end + dsize,
<span class="lineNum">    4982 </span>            :                               btrfs_leaf_data(leaf) + data_end,
<span class="lineNum">    4983 </span><span class="lineCov">     110684 :                               last_off - data_end);</span>
<span class="lineNum">    4984 </span>            : 
<span class="lineNum">    4985 </span><span class="lineCov">    6122663 :                 for (i = slot + nr; i &lt; nritems; i++) {</span>
<span class="lineNum">    4986 </span>            :                         u32 ioff;
<span class="lineNum">    4987 </span>            : 
<span class="lineNum">    4988 </span>            :                         item = btrfs_item_nr(i);
<span class="lineNum">    4989 </span>            :                         ioff = btrfs_token_item_offset(leaf, item, &amp;token);
<span class="lineNum">    4990 </span><span class="lineCov">    6011958 :                         btrfs_set_token_item_offset(leaf, item,</span>
<span class="lineNum">    4991 </span>            :                                                     ioff + dsize, &amp;token);
<span class="lineNum">    4992 </span>            :                 }
<span class="lineNum">    4993 </span>            : 
<span class="lineNum">    4994 </span><span class="lineCov">     221370 :                 memmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),</span>
<span class="lineNum">    4995 </span>            :                               btrfs_item_nr_offset(slot + nr),
<span class="lineNum">    4996 </span>            :                               sizeof(struct btrfs_item) *
<span class="lineNum">    4997 </span><span class="lineCov">     110685 :                               (nritems - slot - nr));</span>
<span class="lineNum">    4998 </span>            :         }
<span class="lineNum">    4999 </span><span class="lineCov">     124168 :         btrfs_set_header_nritems(leaf, nritems - nr);</span>
<span class="lineNum">    5000 </span>            :         nritems -= nr;
<span class="lineNum">    5001 </span>            : 
<span class="lineNum">    5002 </span>            :         /* delete the leaf if we've emptied it */
<span class="lineNum">    5003 </span><span class="lineCov">     124168 :         if (nritems == 0) {</span>
<span class="lineNum">    5004 </span><span class="lineCov">        214 :                 if (leaf == root-&gt;node) {</span>
<span class="lineNum">    5005 </span>            :                         btrfs_set_header_level(leaf, 0);
<span class="lineNum">    5006 </span>            :                 } else {
<span class="lineNum">    5007 </span><span class="lineCov">        186 :                         btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5008 </span><span class="lineCov">        186 :                         clean_tree_block(trans, root, leaf);</span>
<span class="lineNum">    5009 </span><span class="lineCov">        186 :                         btrfs_del_leaf(trans, root, path, leaf);</span>
<span class="lineNum">    5010 </span>            :                 }
<span class="lineNum">    5011 </span>            :         } else {
<span class="lineNum">    5012 </span><span class="lineCov">     123954 :                 int used = leaf_space_used(leaf, 0, nritems);</span>
<span class="lineNum">    5013 </span><span class="lineCov">     123951 :                 if (slot == 0) {</span>
<span class="lineNum">    5014 </span>            :                         struct btrfs_disk_key disk_key;
<span class="lineNum">    5015 </span>            : 
<span class="lineNum">    5016 </span>            :                         btrfs_item_key(leaf, &amp;disk_key, 0);
<span class="lineNum">    5017 </span><span class="lineCov">       4153 :                         fixup_low_keys(root, path, &amp;disk_key, 1);</span>
<span class="lineNum">    5018 </span>            :                 }
<span class="lineNum">    5019 </span>            : 
<span class="lineNum">    5020 </span>            :                 /* delete the leaf if it is mostly empty */
<span class="lineNum">    5021 </span><span class="lineCov">     123951 :                 if (used &lt; BTRFS_LEAF_DATA_SIZE(root) / 3) {</span>
<span class="lineNum">    5022 </span>            :                         /* push_leaf_left fixes the path.
<span class="lineNum">    5023 </span>            :                          * make sure the path still points to our leaf
<span class="lineNum">    5024 </span>            :                          * for possible call to del_ptr below
<span class="lineNum">    5025 </span>            :                          */
<span class="lineNum">    5026 </span><span class="lineCov">      14022 :                         slot = path-&gt;slots[1];</span>
<span class="lineNum">    5027 </span>            :                         extent_buffer_get(leaf);
<span class="lineNum">    5028 </span>            : 
<span class="lineNum">    5029 </span><span class="lineCov">      14024 :                         btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5030 </span><span class="lineCov">      14024 :                         wret = push_leaf_left(trans, root, path, 1, 1,</span>
<span class="lineNum">    5031 </span>            :                                               1, (u32)-1);
<span class="lineNum">    5032 </span><span class="lineCov">      14024 :                         if (wret &lt; 0 &amp;&amp; wret != -ENOSPC)</span>
<span class="lineNum">    5033 </span>            :                                 ret = wret;
<span class="lineNum">    5034 </span>            : 
<span class="lineNum">    5035 </span><span class="lineCov">      27179 :                         if (path-&gt;nodes[0] == leaf &amp;&amp;</span>
<span class="lineNum">    5036 </span>            :                             btrfs_header_nritems(leaf)) {
<span class="lineNum">    5037 </span><span class="lineCov">      12950 :                                 wret = push_leaf_right(trans, root, path, 1,</span>
<span class="lineNum">    5038 </span>            :                                                        1, 1, 0);
<span class="lineNum">    5039 </span><span class="lineCov">      12950 :                                 if (wret &lt; 0 &amp;&amp; wret != -ENOSPC)</span>
<span class="lineNum">    5040 </span>            :                                         ret = wret;
<span class="lineNum">    5041 </span>            :                         }
<span class="lineNum">    5042 </span>            : 
<span class="lineNum">    5043 </span><span class="lineCov">      14024 :                         if (btrfs_header_nritems(leaf) == 0) {</span>
<span class="lineNum">    5044 </span><span class="lineCov">       1174 :                                 path-&gt;slots[1] = slot;</span>
<span class="lineNum">    5045 </span><span class="lineCov">       1174 :                                 btrfs_del_leaf(trans, root, path, leaf);</span>
<span class="lineNum">    5046 </span><span class="lineCov">       1174 :                                 free_extent_buffer(leaf);</span>
<span class="lineNum">    5047 </span>            :                                 ret = 0;
<span class="lineNum">    5048 </span>            :                         } else {
<span class="lineNum">    5049 </span>            :                                 /* if we're still in the path, make sure
<span class="lineNum">    5050 </span>            :                                  * we're dirty.  Otherwise, one of the
<span class="lineNum">    5051 </span>            :                                  * push_leaf functions must have already
<span class="lineNum">    5052 </span>            :                                  * dirtied this buffer
<span class="lineNum">    5053 </span>            :                                  */
<span class="lineNum">    5054 </span><span class="lineCov">      12850 :                                 if (path-&gt;nodes[0] == leaf)</span>
<span class="lineNum">    5055 </span><span class="lineCov">      12551 :                                         btrfs_mark_buffer_dirty(leaf);</span>
<span class="lineNum">    5056 </span><span class="lineCov">      12850 :                                 free_extent_buffer(leaf);</span>
<span class="lineNum">    5057 </span>            :                         }
<span class="lineNum">    5058 </span>            :                 } else {
<span class="lineNum">    5059 </span><span class="lineCov">     109929 :                         btrfs_mark_buffer_dirty(leaf);</span>
<span class="lineNum">    5060 </span>            :                 }
<span class="lineNum">    5061 </span>            :         }
<span class="lineNum">    5062 </span><span class="lineCov">     124169 :         return ret;</span>
<span class="lineNum">    5063 </span>            : }
<span class="lineNum">    5064 </span>            : 
<span class="lineNum">    5065 </span>            : /*
<span class="lineNum">    5066 </span>            :  * search the tree again to find a leaf with lesser keys
<span class="lineNum">    5067 </span>            :  * returns 0 if it found something or 1 if there are no lesser leaves.
<span class="lineNum">    5068 </span>            :  * returns &lt; 0 on io errors.
<span class="lineNum">    5069 </span>            :  *
<span class="lineNum">    5070 </span>            :  * This may release the path, and so you may lose any locks held at the
<span class="lineNum">    5071 </span>            :  * time you call it.
<span class="lineNum">    5072 </span>            :  */
<span class="lineNum">    5073 </span><span class="lineCov">        164 : int btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)</span>
<span class="lineNum">    5074 </span>            : {
<span class="lineNum">    5075 </span>            :         struct btrfs_key key;
<span class="lineNum">    5076 </span>            :         struct btrfs_disk_key found_key;
<span class="lineNum">    5077 </span>            :         int ret;
<span class="lineNum">    5078 </span>            : 
<span class="lineNum">    5079 </span><span class="lineCov">        164 :         btrfs_item_key_to_cpu(path-&gt;nodes[0], &amp;key, 0);</span>
<span class="lineNum">    5080 </span>            : 
<span class="lineNum">    5081 </span><span class="lineCov">        164 :         if (key.offset &gt; 0) {</span>
<span class="lineNum">    5082 </span><span class="lineCov">        164 :                 key.offset--;</span>
<span class="lineNum">    5083 </span><span class="lineNoCov">          0 :         } else if (key.type &gt; 0) {</span>
<span class="lineNum">    5084 </span><span class="lineNoCov">          0 :                 key.type--;</span>
<span class="lineNum">    5085 </span><span class="lineNoCov">          0 :                 key.offset = (u64)-1;</span>
<span class="lineNum">    5086 </span><span class="lineNoCov">          0 :         } else if (key.objectid &gt; 0) {</span>
<span class="lineNum">    5087 </span><span class="lineNoCov">          0 :                 key.objectid--;</span>
<span class="lineNum">    5088 </span><span class="lineNoCov">          0 :                 key.type = (u8)-1;</span>
<span class="lineNum">    5089 </span><span class="lineNoCov">          0 :                 key.offset = (u64)-1;</span>
<span class="lineNum">    5090 </span>            :         } else {
<span class="lineNum">    5091 </span>            :                 return 1;
<span class="lineNum">    5092 </span>            :         }
<span class="lineNum">    5093 </span>            : 
<span class="lineNum">    5094 </span><span class="lineCov">        164 :         btrfs_release_path(path);</span>
<span class="lineNum">    5095 </span><span class="lineCov">        164 :         ret = btrfs_search_slot(NULL, root, &amp;key, path, 0, 0);</span>
<span class="lineNum">    5096 </span><span class="lineCov">        164 :         if (ret &lt; 0)</span>
<span class="lineNum">    5097 </span>            :                 return ret;
<span class="lineNum">    5098 </span><span class="lineCov">        164 :         btrfs_item_key(path-&gt;nodes[0], &amp;found_key, 0);</span>
<span class="lineNum">    5099 </span>            :         ret = comp_keys(&amp;found_key, &amp;key);
<span class="lineNum">    5100 </span>            :         /*
<span class="lineNum">    5101 </span>            :          * We might have had an item with the previous key in the tree right
<span class="lineNum">    5102 </span>            :          * before we released our path. And after we released our path, that
<span class="lineNum">    5103 </span>            :          * item might have been pushed to the first slot (0) of the leaf we
<span class="lineNum">    5104 </span>            :          * were holding due to a tree balance. Alternatively, an item with the
<span class="lineNum">    5105 </span>            :          * previous key can exist as the only element of a leaf (big fat item).
<span class="lineNum">    5106 </span>            :          * Therefore account for these 2 cases, so that our callers (like
<span class="lineNum">    5107 </span>            :          * btrfs_previous_item) don't miss an existing item with a key matching
<span class="lineNum">    5108 </span>            :          * the previous key we computed above.
<span class="lineNum">    5109 </span>            :          */
<span class="lineNum">    5110 </span><span class="lineCov">        164 :         if (ret &lt;= 0)</span>
<span class="lineNum">    5111 </span>            :                 return 0;
<span class="lineNum">    5112 </span><span class="lineCov">         80 :         return 1;</span>
<span class="lineNum">    5113 </span>            : }
<span class="lineNum">    5114 </span>            : 
<span class="lineNum">    5115 </span>            : /*
<span class="lineNum">    5116 </span>            :  * A helper function to walk down the tree starting at min_key, and looking
<span class="lineNum">    5117 </span>            :  * for nodes or leaves that are have a minimum transaction id.
<span class="lineNum">    5118 </span>            :  * This is used by the btree defrag code, and tree logging
<span class="lineNum">    5119 </span>            :  *
<span class="lineNum">    5120 </span>            :  * This does not cow, but it does stuff the starting key it finds back
<span class="lineNum">    5121 </span>            :  * into min_key, so you can call btrfs_search_slot with cow=1 on the
<span class="lineNum">    5122 </span>            :  * key and get a writable path.
<span class="lineNum">    5123 </span>            :  *
<span class="lineNum">    5124 </span>            :  * This does lock as it descends, and path-&gt;keep_locks should be set
<span class="lineNum">    5125 </span>            :  * to 1 by the caller.
<span class="lineNum">    5126 </span>            :  *
<span class="lineNum">    5127 </span>            :  * This honors path-&gt;lowest_level to prevent descent past a given level
<span class="lineNum">    5128 </span>            :  * of the tree.
<span class="lineNum">    5129 </span>            :  *
<span class="lineNum">    5130 </span>            :  * min_trans indicates the oldest transaction that you are interested
<span class="lineNum">    5131 </span>            :  * in walking through.  Any nodes or leaves older than min_trans are
<span class="lineNum">    5132 </span>            :  * skipped over (without reading them).
<span class="lineNum">    5133 </span>            :  *
<span class="lineNum">    5134 </span>            :  * returns zero if something useful was found, &lt; 0 on error and 1 if there
<a name="5135"><span class="lineNum">    5135 </span>            :  * was nothing in the tree that matched the search criteria.</a>
<span class="lineNum">    5136 </span>            :  */
<span class="lineNum">    5137 </span><span class="lineCov">       2536 : int btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,</span>
<span class="lineNum">    5138 </span>            :                          struct btrfs_path *path,
<span class="lineNum">    5139 </span>            :                          u64 min_trans)
<span class="lineNum">    5140 </span>            : {
<span class="lineNum">    5141 </span><span class="lineCov">       8832 :         struct extent_buffer *cur;</span>
<span class="lineNum">    5142 </span>            :         struct btrfs_key found_key;
<span class="lineNum">    5143 </span>            :         int slot;
<span class="lineNum">    5144 </span>            :         int sret;
<span class="lineNum">    5145 </span>            :         u32 nritems;
<span class="lineNum">    5146 </span>            :         int level;
<span class="lineNum">    5147 </span>            :         int ret = 1;
<span class="lineNum">    5148 </span>            : 
<span class="lineNum">    5149 </span><span class="lineCov">       2536 :         WARN_ON(!path-&gt;keep_locks);</span>
<span class="lineNum">    5150 </span>            : again:
<span class="lineNum">    5151 </span><span class="lineCov">       2627 :         cur = btrfs_read_lock_root_node(root);</span>
<span class="lineNum">    5152 </span><span class="lineCov">       2627 :         level = btrfs_header_level(cur);</span>
<span class="lineNum">    5153 </span><span class="lineCov">       2627 :         WARN_ON(path-&gt;nodes[level]);</span>
<span class="lineNum">    5154 </span><span class="lineCov">       2627 :         path-&gt;nodes[level] = cur;</span>
<span class="lineNum">    5155 </span><span class="lineCov">       2627 :         path-&gt;locks[level] = BTRFS_READ_LOCK;</span>
<span class="lineNum">    5156 </span>            : 
<span class="lineNum">    5157 </span><span class="lineCov">       2627 :         if (btrfs_header_generation(cur) &lt; min_trans) {</span>
<span class="lineNum">    5158 </span>            :                 ret = 1;
<span class="lineNum">    5159 </span>            :                 goto out;
<span class="lineNum">    5160 </span>            :         }
<span class="lineNum">    5161 </span>            :         while (1) {
<span class="lineNum">    5162 </span>            :                 nritems = btrfs_header_nritems(cur);
<span class="lineNum">    5163 </span><span class="lineCov">       3578 :                 level = btrfs_header_level(cur);</span>
<span class="lineNum">    5164 </span><span class="lineCov">       3578 :                 sret = bin_search(cur, min_key, level, &amp;slot);</span>
<span class="lineNum">    5165 </span>            : 
<span class="lineNum">    5166 </span>            :                 /* at the lowest level, we're done, setup the path and exit */
<span class="lineNum">    5167 </span><span class="lineCov">       3578 :                 if (level == path-&gt;lowest_level) {</span>
<span class="lineNum">    5168 </span><span class="lineCov">       2623 :                         if (slot &gt;= nritems)</span>
<span class="lineNum">    5169 </span>            :                                 goto find_next_key;
<span class="lineNum">    5170 </span>            :                         ret = 0;
<span class="lineNum">    5171 </span><span class="lineCov">       2277 :                         path-&gt;slots[level] = slot;</span>
<span class="lineNum">    5172 </span><span class="lineCov">       2277 :                         btrfs_item_key_to_cpu(cur, &amp;found_key, slot);</span>
<span class="lineNum">    5173 </span><span class="lineCov">       2277 :                         goto out;</span>
<span class="lineNum">    5174 </span>            :                 }
<span class="lineNum">    5175 </span><span class="lineCov">        955 :                 if (sret &amp;&amp; slot &gt; 0)</span>
<span class="lineNum">    5176 </span><span class="lineCov">        851 :                         slot--;</span>
<span class="lineNum">    5177 </span>            :                 /*
<span class="lineNum">    5178 </span>            :                  * check this node pointer against the min_trans parameters.
<span class="lineNum">    5179 </span>            :                  * If it is too old, old, skip to the next one.
<span class="lineNum">    5180 </span>            :                  */
<span class="lineNum">    5181 </span><span class="lineCov">        976 :                 while (slot &lt; nritems) {</span>
<span class="lineNum">    5182 </span>            :                         u64 gen;
<span class="lineNum">    5183 </span>            : 
<span class="lineNum">    5184 </span>            :                         gen = btrfs_node_ptr_generation(cur, slot);
<span class="lineNum">    5185 </span><span class="lineCov">        976 :                         if (gen &lt; min_trans) {</span>
<span class="lineNum">    5186 </span><span class="lineCov">         21 :                                 slot++;</span>
<span class="lineNum">    5187 </span><span class="lineCov">         21 :                                 continue;</span>
<span class="lineNum">    5188 </span>            :                         }
<span class="lineNum">    5189 </span>            :                         break;
<span class="lineNum">    5190 </span>            :                 }
<span class="lineNum">    5191 </span>            : find_next_key:
<span class="lineNum">    5192 </span>            :                 /*
<span class="lineNum">    5193 </span>            :                  * we didn't find a candidate key in this node, walk forward
<span class="lineNum">    5194 </span>            :                  * and find another one
<span class="lineNum">    5195 </span>            :                  */
<span class="lineNum">    5196 </span><span class="lineCov">       1301 :                 if (slot &gt;= nritems) {</span>
<span class="lineNum">    5197 </span><span class="lineCov">        346 :                         path-&gt;slots[level] = slot;</span>
<span class="lineNum">    5198 </span><span class="lineCov">        346 :                         btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5199 </span><span class="lineCov">        346 :                         sret = btrfs_find_next_key(root, path, min_key, level,</span>
<span class="lineNum">    5200 </span>            :                                                   min_trans);
<span class="lineNum">    5201 </span><span class="lineCov">        346 :                         if (sret == 0) {</span>
<span class="lineNum">    5202 </span><span class="lineCov">         91 :                                 btrfs_release_path(path);</span>
<span class="lineNum">    5203 </span><span class="lineCov">         91 :                                 goto again;</span>
<span class="lineNum">    5204 </span>            :                         } else {
<span class="lineNum">    5205 </span>            :                                 goto out;
<span class="lineNum">    5206 </span>            :                         }
<span class="lineNum">    5207 </span>            :                 }
<span class="lineNum">    5208 </span>            :                 /* save our key for returning back */
<span class="lineNum">    5209 </span>            :                 btrfs_node_key_to_cpu(cur, &amp;found_key, slot);
<span class="lineNum">    5210 </span><span class="lineCov">        955 :                 path-&gt;slots[level] = slot;</span>
<span class="lineNum">    5211 </span><span class="lineCov">        955 :                 if (level == path-&gt;lowest_level) {</span>
<span class="lineNum">    5212 </span>            :                         ret = 0;
<span class="lineNum">    5213 </span><span class="lineNoCov">          0 :                         unlock_up(path, level, 1, 0, NULL);</span>
<span class="lineNum">    5214 </span><span class="lineNoCov">          0 :                         goto out;</span>
<span class="lineNum">    5215 </span>            :                 }
<span class="lineNum">    5216 </span><span class="lineCov">        955 :                 btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5217 </span><span class="lineCov">        955 :                 cur = read_node_slot(root, cur, slot);</span>
<span class="lineNum">    5218 </span><span class="lineCov">        955 :                 BUG_ON(!cur); /* -ENOMEM */</span>
<span class="lineNum">    5219 </span>            : 
<span class="lineNum">    5220 </span><span class="lineCov">        955 :                 btrfs_tree_read_lock(cur);</span>
<span class="lineNum">    5221 </span>            : 
<span class="lineNum">    5222 </span><span class="lineCov">        955 :                 path-&gt;locks[level - 1] = BTRFS_READ_LOCK;</span>
<span class="lineNum">    5223 </span><span class="lineCov">        955 :                 path-&gt;nodes[level - 1] = cur;</span>
<span class="lineNum">    5224 </span><span class="lineCov">        955 :                 unlock_up(path, level, 1, 0, NULL);</span>
<span class="lineNum">    5225 </span><span class="lineCov">        955 :                 btrfs_clear_path_blocking(path, NULL, 0);</span>
<span class="lineNum">    5226 </span><span class="lineCov">        955 :         }</span>
<span class="lineNum">    5227 </span>            : out:
<span class="lineNum">    5228 </span><span class="lineCov">       2536 :         if (ret == 0)</span>
<span class="lineNum">    5229 </span><span class="lineCov">       2277 :                 memcpy(min_key, &amp;found_key, sizeof(found_key));</span>
<span class="lineNum">    5230 </span><span class="lineCov">       2536 :         btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5231 </span><span class="lineCov">       2536 :         return ret;</span>
<a name="5232"><span class="lineNum">    5232 </span>            : }</a>
<span class="lineNum">    5233 </span>            : 
<span class="lineNum">    5234 </span><span class="lineCov">         25 : static void tree_move_down(struct btrfs_root *root,</span>
<span class="lineNum">    5235 </span>            :                            struct btrfs_path *path,
<span class="lineNum">    5236 </span>            :                            int *level, int root_level)
<span class="lineNum">    5237 </span>            : {
<span class="lineNum">    5238 </span><span class="lineCov">         25 :         BUG_ON(*level == 0);</span>
<span class="lineNum">    5239 </span><span class="lineCov">         25 :         path-&gt;nodes[*level - 1] = read_node_slot(root, path-&gt;nodes[*level],</span>
<span class="lineNum">    5240 </span>            :                                         path-&gt;slots[*level]);
<span class="lineNum">    5241 </span><span class="lineCov">         25 :         path-&gt;slots[*level - 1] = 0;</span>
<span class="lineNum">    5242 </span><span class="lineCov">         25 :         (*level)--;</span>
<a name="5243"><span class="lineNum">    5243 </span><span class="lineCov">         25 : }</span></a>
<span class="lineNum">    5244 </span>            : 
<span class="lineNum">    5245 </span><span class="lineCov">       3684 : static int tree_move_next_or_upnext(struct btrfs_root *root,</span>
<span class="lineNum">    5246 </span>            :                                     struct btrfs_path *path,
<span class="lineNum">    5247 </span>            :                                     int *level, int root_level)
<span class="lineNum">    5248 </span>            : {
<span class="lineNum">    5249 </span>            :         int ret = 0;
<span class="lineNum">    5250 </span>            :         int nritems;
<span class="lineNum">    5251 </span><span class="lineCov">       7393 :         nritems = btrfs_header_nritems(path-&gt;nodes[*level]);</span>
<span class="lineNum">    5252 </span>            : 
<span class="lineNum">    5253 </span><span class="lineCov">       3684 :         path-&gt;slots[*level]++;</span>
<span class="lineNum">    5254 </span>            : 
<span class="lineNum">    5255 </span><span class="lineCov">       3709 :         while (path-&gt;slots[*level] &gt;= nritems) {</span>
<span class="lineNum">    5256 </span><span class="lineCov">         57 :                 if (*level == root_level)</span>
<span class="lineNum">    5257 </span>            :                         return -1;
<span class="lineNum">    5258 </span>            : 
<span class="lineNum">    5259 </span>            :                 /* move upnext */
<span class="lineNum">    5260 </span><span class="lineCov">         25 :                 path-&gt;slots[*level] = 0;</span>
<span class="lineNum">    5261 </span><span class="lineCov">         25 :                 free_extent_buffer(path-&gt;nodes[*level]);</span>
<span class="lineNum">    5262 </span><span class="lineCov">         25 :                 path-&gt;nodes[*level] = NULL;</span>
<span class="lineNum">    5263 </span><span class="lineCov">         25 :                 (*level)++;</span>
<span class="lineNum">    5264 </span><span class="lineCov">         25 :                 path-&gt;slots[*level]++;</span>
<span class="lineNum">    5265 </span>            : 
<span class="lineNum">    5266 </span><span class="lineCov">         50 :                 nritems = btrfs_header_nritems(path-&gt;nodes[*level]);</span>
<span class="lineNum">    5267 </span>            :                 ret = 1;
<span class="lineNum">    5268 </span>            :         }
<span class="lineNum">    5269 </span>            :         return ret;
<span class="lineNum">    5270 </span>            : }
<span class="lineNum">    5271 </span>            : 
<span class="lineNum">    5272 </span>            : /*
<span class="lineNum">    5273 </span>            :  * Returns 1 if it had to move up and next. 0 is returned if it moved only next
<a name="5274"><span class="lineNum">    5274 </span>            :  * or down.</a>
<span class="lineNum">    5275 </span>            :  */
<span class="lineNum">    5276 </span><span class="lineCov">       3709 : static int tree_advance(struct btrfs_root *root,</span>
<span class="lineNum">    5277 </span>            :                         struct btrfs_path *path,
<span class="lineNum">    5278 </span>            :                         int *level, int root_level,
<span class="lineNum">    5279 </span>            :                         int allow_down,
<span class="lineNum">    5280 </span>            :                         struct btrfs_key *key)
<span class="lineNum">    5281 </span>            : {
<span class="lineNum">    5282 </span>            :         int ret;
<span class="lineNum">    5283 </span>            : 
<span class="lineNum">    5284 </span><span class="lineCov">       3709 :         if (*level == 0 || !allow_down) {</span>
<span class="lineNum">    5285 </span><span class="lineCov">       3684 :                 ret = tree_move_next_or_upnext(root, path, level, root_level);</span>
<span class="lineNum">    5286 </span>            :         } else {
<span class="lineNum">    5287 </span><span class="lineCov">         25 :                 tree_move_down(root, path, level, root_level);</span>
<span class="lineNum">    5288 </span>            :                 ret = 0;
<span class="lineNum">    5289 </span>            :         }
<span class="lineNum">    5290 </span><span class="lineCov">       3709 :         if (ret &gt;= 0) {</span>
<span class="lineNum">    5291 </span><span class="lineCov">       3677 :                 if (*level == 0)</span>
<span class="lineNum">    5292 </span><span class="lineCov">       3650 :                         btrfs_item_key_to_cpu(path-&gt;nodes[*level], key,</span>
<span class="lineNum">    5293 </span>            :                                         path-&gt;slots[*level]);
<span class="lineNum">    5294 </span>            :                 else
<span class="lineNum">    5295 </span><span class="lineCov">         27 :                         btrfs_node_key_to_cpu(path-&gt;nodes[*level], key,</span>
<span class="lineNum">    5296 </span>            :                                         path-&gt;slots[*level]);
<span class="lineNum">    5297 </span>            :         }
<span class="lineNum">    5298 </span><span class="lineCov">       3709 :         return ret;</span>
<a name="5299"><span class="lineNum">    5299 </span>            : }</a>
<span class="lineNum">    5300 </span>            : 
<span class="lineNum">    5301 </span><span class="lineCov">        807 : static int tree_compare_item(struct btrfs_root *left_root,</span>
<span class="lineNum">    5302 </span>            :                              struct btrfs_path *left_path,
<span class="lineNum">    5303 </span>            :                              struct btrfs_path *right_path,
<span class="lineNum">    5304 </span>            :                              char *tmp_buf)
<span class="lineNum">    5305 </span>            : {
<span class="lineNum">    5306 </span>            :         int cmp;
<span class="lineNum">    5307 </span>            :         int len1, len2;
<span class="lineNum">    5308 </span>            :         unsigned long off1, off2;
<span class="lineNum">    5309 </span>            : 
<span class="lineNum">    5310 </span><span class="lineCov">       1614 :         len1 = btrfs_item_size_nr(left_path-&gt;nodes[0], left_path-&gt;slots[0]);</span>
<span class="lineNum">    5311 </span><span class="lineCov">       1614 :         len2 = btrfs_item_size_nr(right_path-&gt;nodes[0], right_path-&gt;slots[0]);</span>
<span class="lineNum">    5312 </span><span class="lineCov">        807 :         if (len1 != len2)</span>
<span class="lineNum">    5313 </span>            :                 return 1;
<span class="lineNum">    5314 </span>            : 
<span class="lineNum">    5315 </span><span class="lineCov">       1586 :         off1 = btrfs_item_ptr_offset(left_path-&gt;nodes[0], left_path-&gt;slots[0]);</span>
<span class="lineNum">    5316 </span><span class="lineCov">       1586 :         off2 = btrfs_item_ptr_offset(right_path-&gt;nodes[0],</span>
<span class="lineNum">    5317 </span>            :                                 right_path-&gt;slots[0]);
<span class="lineNum">    5318 </span>            : 
<span class="lineNum">    5319 </span><span class="lineCov">        793 :         read_extent_buffer(left_path-&gt;nodes[0], tmp_buf, off1, len1);</span>
<span class="lineNum">    5320 </span>            : 
<span class="lineNum">    5321 </span><span class="lineCov">        793 :         cmp = memcmp_extent_buffer(right_path-&gt;nodes[0], tmp_buf, off2, len1);</span>
<span class="lineNum">    5322 </span><span class="lineCov">        793 :         if (cmp)</span>
<span class="lineNum">    5323 </span>            :                 return 1;
<span class="lineNum">    5324 </span>            :         return 0;
<span class="lineNum">    5325 </span>            : }
<span class="lineNum">    5326 </span>            : 
<span class="lineNum">    5327 </span>            : #define ADVANCE 1
<span class="lineNum">    5328 </span>            : #define ADVANCE_ONLY_NEXT -1
<span class="lineNum">    5329 </span>            : 
<span class="lineNum">    5330 </span>            : /*
<span class="lineNum">    5331 </span>            :  * This function compares two trees and calls the provided callback for
<span class="lineNum">    5332 </span>            :  * every changed/new/deleted item it finds.
<span class="lineNum">    5333 </span>            :  * If shared tree blocks are encountered, whole subtrees are skipped, making
<span class="lineNum">    5334 </span>            :  * the compare pretty fast on snapshotted subvolumes.
<span class="lineNum">    5335 </span>            :  *
<span class="lineNum">    5336 </span>            :  * This currently works on commit roots only. As commit roots are read only,
<span class="lineNum">    5337 </span>            :  * we don't do any locking. The commit roots are protected with transactions.
<span class="lineNum">    5338 </span>            :  * Transactions are ended and rejoined when a commit is tried in between.
<span class="lineNum">    5339 </span>            :  *
<span class="lineNum">    5340 </span>            :  * This function checks for modifications done to the trees while comparing.
<span class="lineNum">    5341 </span>            :  * If it detects a change, it aborts immediately.
<span class="lineNum">    5342 </span>            :  */
<span class="lineNum">    5343 </span><span class="lineCov">         16 : int btrfs_compare_trees(struct btrfs_root *left_root,</span>
<span class="lineNum">    5344 </span>            :                         struct btrfs_root *right_root,
<span class="lineNum">    5345 </span>            :                         btrfs_changed_cb_t changed_cb, void *ctx)
<span class="lineNum">    5346 </span>            : {
<span class="lineNum">    5347 </span>            :         int ret;
<span class="lineNum">    5348 </span>            :         int cmp;
<span class="lineNum">    5349 </span>            :         struct btrfs_path *left_path = NULL;
<span class="lineNum">    5350 </span>            :         struct btrfs_path *right_path = NULL;
<span class="lineNum">    5351 </span>            :         struct btrfs_key left_key;
<span class="lineNum">    5352 </span>            :         struct btrfs_key right_key;
<span class="lineNum">    5353 </span>            :         char *tmp_buf = NULL;
<span class="lineNum">    5354 </span>            :         int left_root_level;
<span class="lineNum">    5355 </span>            :         int right_root_level;
<span class="lineNum">    5356 </span>            :         int left_level;
<span class="lineNum">    5357 </span>            :         int right_level;
<span class="lineNum">    5358 </span>            :         int left_end_reached;
<span class="lineNum">    5359 </span>            :         int right_end_reached;
<span class="lineNum">    5360 </span>            :         int advance_left;
<span class="lineNum">    5361 </span>            :         int advance_right;
<span class="lineNum">    5362 </span>            :         u64 left_blockptr;
<span class="lineNum">    5363 </span>            :         u64 right_blockptr;
<span class="lineNum">    5364 </span>            :         u64 left_gen;
<span class="lineNum">    5365 </span>            :         u64 right_gen;
<span class="lineNum">    5366 </span>            : 
<span class="lineNum">    5367 </span>            :         left_path = btrfs_alloc_path();
<span class="lineNum">    5368 </span><span class="lineCov">         16 :         if (!left_path) {</span>
<span class="lineNum">    5369 </span>            :                 ret = -ENOMEM;
<span class="lineNum">    5370 </span>            :                 goto out;
<span class="lineNum">    5371 </span>            :         }
<span class="lineNum">    5372 </span>            :         right_path = btrfs_alloc_path();
<span class="lineNum">    5373 </span><span class="lineCov">         16 :         if (!right_path) {</span>
<span class="lineNum">    5374 </span>            :                 ret = -ENOMEM;
<span class="lineNum">    5375 </span>            :                 goto out;
<span class="lineNum">    5376 </span>            :         }
<span class="lineNum">    5377 </span>            : 
<span class="lineNum">    5378 </span><span class="lineCov">         16 :         tmp_buf = kmalloc(left_root-&gt;leafsize, GFP_NOFS);</span>
<span class="lineNum">    5379 </span><span class="lineCov">         16 :         if (!tmp_buf) {</span>
<span class="lineNum">    5380 </span>            :                 ret = -ENOMEM;
<span class="lineNum">    5381 </span>            :                 goto out;
<span class="lineNum">    5382 </span>            :         }
<span class="lineNum">    5383 </span>            : 
<span class="lineNum">    5384 </span><span class="lineCov">         16 :         left_path-&gt;search_commit_root = 1;</span>
<span class="lineNum">    5385 </span><span class="lineCov">         16 :         left_path-&gt;skip_locking = 1;</span>
<span class="lineNum">    5386 </span><span class="lineCov">         16 :         right_path-&gt;search_commit_root = 1;</span>
<span class="lineNum">    5387 </span><span class="lineCov">         16 :         right_path-&gt;skip_locking = 1;</span>
<span class="lineNum">    5388 </span>            : 
<span class="lineNum">    5389 </span>            :         /*
<span class="lineNum">    5390 </span>            :          * Strategy: Go to the first items of both trees. Then do
<span class="lineNum">    5391 </span>            :          *
<span class="lineNum">    5392 </span>            :          * If both trees are at level 0
<span class="lineNum">    5393 </span>            :          *   Compare keys of current items
<span class="lineNum">    5394 </span>            :          *     If left &lt; right treat left item as new, advance left tree
<span class="lineNum">    5395 </span>            :          *       and repeat
<span class="lineNum">    5396 </span>            :          *     If left &gt; right treat right item as deleted, advance right tree
<span class="lineNum">    5397 </span>            :          *       and repeat
<span class="lineNum">    5398 </span>            :          *     If left == right do deep compare of items, treat as changed if
<span class="lineNum">    5399 </span>            :          *       needed, advance both trees and repeat
<span class="lineNum">    5400 </span>            :          * If both trees are at the same level but not at level 0
<span class="lineNum">    5401 </span>            :          *   Compare keys of current nodes/leafs
<span class="lineNum">    5402 </span>            :          *     If left &lt; right advance left tree and repeat
<span class="lineNum">    5403 </span>            :          *     If left &gt; right advance right tree and repeat
<span class="lineNum">    5404 </span>            :          *     If left == right compare blockptrs of the next nodes/leafs
<span class="lineNum">    5405 </span>            :          *       If they match advance both trees but stay at the same level
<span class="lineNum">    5406 </span>            :          *         and repeat
<span class="lineNum">    5407 </span>            :          *       If they don't match advance both trees while allowing to go
<span class="lineNum">    5408 </span>            :          *         deeper and repeat
<span class="lineNum">    5409 </span>            :          * If tree levels are different
<span class="lineNum">    5410 </span>            :          *   Advance the tree that needs it and repeat
<span class="lineNum">    5411 </span>            :          *
<span class="lineNum">    5412 </span>            :          * Advancing a tree means:
<span class="lineNum">    5413 </span>            :          *   If we are at level 0, try to go to the next slot. If that's not
<span class="lineNum">    5414 </span>            :          *   possible, go one level up and repeat. Stop when we found a level
<span class="lineNum">    5415 </span>            :          *   where we could go to the next slot. We may at this point be on a
<span class="lineNum">    5416 </span>            :          *   node or a leaf.
<span class="lineNum">    5417 </span>            :          *
<span class="lineNum">    5418 </span>            :          *   If we are not at level 0 and not on shared tree blocks, go one
<span class="lineNum">    5419 </span>            :          *   level deeper.
<span class="lineNum">    5420 </span>            :          *
<span class="lineNum">    5421 </span>            :          *   If we are not at level 0 and on shared tree blocks, go one slot to
<span class="lineNum">    5422 </span>            :          *   the right if possible or go up and right.
<span class="lineNum">    5423 </span>            :          */
<span class="lineNum">    5424 </span>            : 
<span class="lineNum">    5425 </span><span class="lineCov">         16 :         down_read(&amp;left_root-&gt;fs_info-&gt;commit_root_sem);</span>
<span class="lineNum">    5426 </span><span class="lineCov">         32 :         left_level = btrfs_header_level(left_root-&gt;commit_root);</span>
<span class="lineNum">    5427 </span>            :         left_root_level = left_level;
<span class="lineNum">    5428 </span><span class="lineCov">         16 :         left_path-&gt;nodes[left_level] = left_root-&gt;commit_root;</span>
<span class="lineNum">    5429 </span><span class="lineCov">         16 :         extent_buffer_get(left_path-&gt;nodes[left_level]);</span>
<span class="lineNum">    5430 </span>            : 
<span class="lineNum">    5431 </span><span class="lineCov">         32 :         right_level = btrfs_header_level(right_root-&gt;commit_root);</span>
<span class="lineNum">    5432 </span>            :         right_root_level = right_level;
<span class="lineNum">    5433 </span><span class="lineCov">         16 :         right_path-&gt;nodes[right_level] = right_root-&gt;commit_root;</span>
<span class="lineNum">    5434 </span><span class="lineCov">         16 :         extent_buffer_get(right_path-&gt;nodes[right_level]);</span>
<span class="lineNum">    5435 </span><span class="lineCov">         16 :         up_read(&amp;left_root-&gt;fs_info-&gt;commit_root_sem);</span>
<span class="lineNum">    5436 </span>            : 
<span class="lineNum">    5437 </span><span class="lineCov">         16 :         if (left_level == 0)</span>
<span class="lineNum">    5438 </span><span class="lineCov">         12 :                 btrfs_item_key_to_cpu(left_path-&gt;nodes[left_level],</span>
<span class="lineNum">    5439 </span>            :                                 &amp;left_key, left_path-&gt;slots[left_level]);
<span class="lineNum">    5440 </span>            :         else
<span class="lineNum">    5441 </span><span class="lineCov">          4 :                 btrfs_node_key_to_cpu(left_path-&gt;nodes[left_level],</span>
<span class="lineNum">    5442 </span>            :                                 &amp;left_key, left_path-&gt;slots[left_level]);
<span class="lineNum">    5443 </span><span class="lineCov">         16 :         if (right_level == 0)</span>
<span class="lineNum">    5444 </span><span class="lineCov">         12 :                 btrfs_item_key_to_cpu(right_path-&gt;nodes[right_level],</span>
<span class="lineNum">    5445 </span>            :                                 &amp;right_key, right_path-&gt;slots[right_level]);
<span class="lineNum">    5446 </span>            :         else
<span class="lineNum">    5447 </span><span class="lineCov">          4 :                 btrfs_node_key_to_cpu(right_path-&gt;nodes[right_level],</span>
<span class="lineNum">    5448 </span>            :                                 &amp;right_key, right_path-&gt;slots[right_level]);
<span class="lineNum">    5449 </span>            : 
<span class="lineNum">    5450 </span>            :         left_end_reached = right_end_reached = 0;
<span class="lineNum">    5451 </span>            :         advance_left = advance_right = 0;
<span class="lineNum">    5452 </span>            : 
<span class="lineNum">    5453 </span>            :         while (1) {
<span class="lineNum">    5454 </span><span class="lineCov">       2907 :                 if (advance_left &amp;&amp; !left_end_reached) {</span>
<span class="lineNum">    5455 </span><span class="lineCov">       1234 :                         ret = tree_advance(left_root, left_path, &amp;left_level,</span>
<span class="lineNum">    5456 </span>            :                                         left_root_level,
<span class="lineNum">    5457 </span>            :                                         advance_left != ADVANCE_ONLY_NEXT,
<span class="lineNum">    5458 </span>            :                                         &amp;left_key);
<span class="lineNum">    5459 </span><span class="lineCov">       1234 :                         if (ret &lt; 0)</span>
<span class="lineNum">    5460 </span>            :                                 left_end_reached = ADVANCE;
<span class="lineNum">    5461 </span>            :                         advance_left = 0;
<span class="lineNum">    5462 </span>            :                 }
<span class="lineNum">    5463 </span><span class="lineCov">       2907 :                 if (advance_right &amp;&amp; !right_end_reached) {</span>
<span class="lineNum">    5464 </span><span class="lineCov">       2475 :                         ret = tree_advance(right_root, right_path, &amp;right_level,</span>
<span class="lineNum">    5465 </span>            :                                         right_root_level,
<span class="lineNum">    5466 </span>            :                                         advance_right != ADVANCE_ONLY_NEXT,
<span class="lineNum">    5467 </span>            :                                         &amp;right_key);
<span class="lineNum">    5468 </span><span class="lineCov">       2475 :                         if (ret &lt; 0)</span>
<span class="lineNum">    5469 </span>            :                                 right_end_reached = ADVANCE;
<span class="lineNum">    5470 </span>            :                         advance_right = 0;
<span class="lineNum">    5471 </span>            :                 }
<span class="lineNum">    5472 </span>            : 
<span class="lineNum">    5473 </span><span class="lineCov">       2907 :                 if (left_end_reached &amp;&amp; right_end_reached) {</span>
<span class="lineNum">    5474 </span>            :                         ret = 0;
<span class="lineNum">    5475 </span>            :                         goto out;
<span class="lineNum">    5476 </span><span class="lineCov">       2891 :                 } else if (left_end_reached) {</span>
<span class="lineNum">    5477 </span><span class="lineCov">       1421 :                         if (right_level == 0) {</span>
<span class="lineNum">    5478 </span><span class="lineCov">       1413 :                                 ret = changed_cb(left_root, right_root,</span>
<span class="lineNum">    5479 </span>            :                                                 left_path, right_path,
<span class="lineNum">    5480 </span>            :                                                 &amp;right_key,
<span class="lineNum">    5481 </span>            :                                                 BTRFS_COMPARE_TREE_DELETED,
<span class="lineNum">    5482 </span>            :                                                 ctx);
<span class="lineNum">    5483 </span><span class="lineCov">       1413 :                                 if (ret &lt; 0)</span>
<span class="lineNum">    5484 </span>            :                                         goto out;
<span class="lineNum">    5485 </span>            :                         }
<span class="lineNum">    5486 </span>            :                         advance_right = ADVANCE;
<span class="lineNum">    5487 </span><span class="lineCov">       1421 :                         continue;</span>
<span class="lineNum">    5488 </span><span class="lineCov">       1470 :                 } else if (right_end_reached) {</span>
<span class="lineNum">    5489 </span><span class="lineCov">        150 :                         if (left_level == 0) {</span>
<span class="lineNum">    5490 </span><span class="lineCov">        149 :                                 ret = changed_cb(left_root, right_root,</span>
<span class="lineNum">    5491 </span>            :                                                 left_path, right_path,
<span class="lineNum">    5492 </span>            :                                                 &amp;left_key,
<span class="lineNum">    5493 </span>            :                                                 BTRFS_COMPARE_TREE_NEW,
<span class="lineNum">    5494 </span>            :                                                 ctx);
<span class="lineNum">    5495 </span><span class="lineCov">        149 :                                 if (ret &lt; 0)</span>
<span class="lineNum">    5496 </span>            :                                         goto out;
<span class="lineNum">    5497 </span>            :                         }
<span class="lineNum">    5498 </span>            :                         advance_left = ADVANCE;
<span class="lineNum">    5499 </span><span class="lineCov">        150 :                         continue;</span>
<span class="lineNum">    5500 </span>            :                 }
<span class="lineNum">    5501 </span>            : 
<span class="lineNum">    5502 </span><span class="lineCov">       1320 :                 if (left_level == 0 &amp;&amp; right_level == 0) {</span>
<span class="lineNum">    5503 </span>            :                         cmp = btrfs_comp_cpu_keys(&amp;left_key, &amp;right_key);
<span class="lineNum">    5504 </span><span class="lineCov">       1305 :                         if (cmp &lt; 0) {</span>
<span class="lineNum">    5505 </span><span class="lineCov">        264 :                                 ret = changed_cb(left_root, right_root,</span>
<span class="lineNum">    5506 </span>            :                                                 left_path, right_path,
<span class="lineNum">    5507 </span>            :                                                 &amp;left_key,
<span class="lineNum">    5508 </span>            :                                                 BTRFS_COMPARE_TREE_NEW,
<span class="lineNum">    5509 </span>            :                                                 ctx);
<span class="lineNum">    5510 </span><span class="lineCov">        264 :                                 if (ret &lt; 0)</span>
<span class="lineNum">    5511 </span>            :                                         goto out;
<span class="lineNum">    5512 </span>            :                                 advance_left = ADVANCE;
<span class="lineNum">    5513 </span><span class="lineCov">       1041 :                         } else if (cmp &gt; 0) {</span>
<span class="lineNum">    5514 </span><span class="lineCov">        234 :                                 ret = changed_cb(left_root, right_root,</span>
<span class="lineNum">    5515 </span>            :                                                 left_path, right_path,
<span class="lineNum">    5516 </span>            :                                                 &amp;right_key,
<span class="lineNum">    5517 </span>            :                                                 BTRFS_COMPARE_TREE_DELETED,
<span class="lineNum">    5518 </span>            :                                                 ctx);
<span class="lineNum">    5519 </span><span class="lineCov">        234 :                                 if (ret &lt; 0)</span>
<span class="lineNum">    5520 </span>            :                                         goto out;
<span class="lineNum">    5521 </span>            :                                 advance_right = ADVANCE;
<span class="lineNum">    5522 </span>            :                         } else {
<span class="lineNum">    5523 </span>            :                                 enum btrfs_compare_tree_result cmp;
<span class="lineNum">    5524 </span>            : 
<span class="lineNum">    5525 </span><span class="lineCov">        807 :                                 WARN_ON(!extent_buffer_uptodate(left_path-&gt;nodes[0]));</span>
<span class="lineNum">    5526 </span><span class="lineCov">        807 :                                 ret = tree_compare_item(left_root, left_path,</span>
<span class="lineNum">    5527 </span>            :                                                 right_path, tmp_buf);
<span class="lineNum">    5528 </span><span class="lineCov">        807 :                                 if (ret)</span>
<span class="lineNum">    5529 </span>            :                                         cmp = BTRFS_COMPARE_TREE_CHANGED;
<span class="lineNum">    5530 </span>            :                                 else
<span class="lineNum">    5531 </span>            :                                         cmp = BTRFS_COMPARE_TREE_SAME;
<span class="lineNum">    5532 </span><span class="lineCov">        807 :                                 ret = changed_cb(left_root, right_root,</span>
<span class="lineNum">    5533 </span>            :                                                  left_path, right_path,
<span class="lineNum">    5534 </span>            :                                                  &amp;left_key, cmp, ctx);
<span class="lineNum">    5535 </span><span class="lineCov">        807 :                                 if (ret &lt; 0)</span>
<span class="lineNum">    5536 </span>            :                                         goto out;
<span class="lineNum">    5537 </span>            :                                 advance_left = ADVANCE;
<span class="lineNum">    5538 </span>            :                                 advance_right = ADVANCE;
<span class="lineNum">    5539 </span>            :                         }
<span class="lineNum">    5540 </span><span class="lineCov">         15 :                 } else if (left_level == right_level) {</span>
<span class="lineNum">    5541 </span>            :                         cmp = btrfs_comp_cpu_keys(&amp;left_key, &amp;right_key);
<span class="lineNum">    5542 </span><span class="lineCov">         11 :                         if (cmp &lt; 0) {</span>
<span class="lineNum">    5543 </span>            :                                 advance_left = ADVANCE;
<span class="lineNum">    5544 </span><span class="lineCov">         11 :                         } else if (cmp &gt; 0) {</span>
<span class="lineNum">    5545 </span>            :                                 advance_right = ADVANCE;
<span class="lineNum">    5546 </span>            :                         } else {
<span class="lineNum">    5547 </span><span class="lineCov">         11 :                                 left_blockptr = btrfs_node_blockptr(</span>
<span class="lineNum">    5548 </span>            :                                                 left_path-&gt;nodes[left_level],
<span class="lineNum">    5549 </span>            :                                                 left_path-&gt;slots[left_level]);
<span class="lineNum">    5550 </span><span class="lineCov">         11 :                                 right_blockptr = btrfs_node_blockptr(</span>
<span class="lineNum">    5551 </span>            :                                                 right_path-&gt;nodes[right_level],
<span class="lineNum">    5552 </span>            :                                                 right_path-&gt;slots[right_level]);
<span class="lineNum">    5553 </span><span class="lineCov">         11 :                                 left_gen = btrfs_node_ptr_generation(</span>
<span class="lineNum">    5554 </span>            :                                                 left_path-&gt;nodes[left_level],
<span class="lineNum">    5555 </span>            :                                                 left_path-&gt;slots[left_level]);
<span class="lineNum">    5556 </span><span class="lineCov">         11 :                                 right_gen = btrfs_node_ptr_generation(</span>
<span class="lineNum">    5557 </span>            :                                                 right_path-&gt;nodes[right_level],
<span class="lineNum">    5558 </span>            :                                                 right_path-&gt;slots[right_level]);
<span class="lineNum">    5559 </span><span class="lineCov">         22 :                                 if (left_blockptr == right_blockptr &amp;&amp;</span>
<span class="lineNum">    5560 </span><span class="lineCov">         11 :                                     left_gen == right_gen) {</span>
<span class="lineNum">    5561 </span>            :                                         /*
<span class="lineNum">    5562 </span>            :                                          * As we're on a shared block, don't
<span class="lineNum">    5563 </span>            :                                          * allow to go deeper.
<span class="lineNum">    5564 </span>            :                                          */
<span class="lineNum">    5565 </span>            :                                         advance_left = ADVANCE_ONLY_NEXT;
<span class="lineNum">    5566 </span>            :                                         advance_right = ADVANCE_ONLY_NEXT;
<span class="lineNum">    5567 </span>            :                                 } else {
<span class="lineNum">    5568 </span>            :                                         advance_left = ADVANCE;
<span class="lineNum">    5569 </span>            :                                         advance_right = ADVANCE;
<span class="lineNum">    5570 </span>            :                                 }
<span class="lineNum">    5571 </span>            :                         }
<span class="lineNum">    5572 </span><span class="lineCov">          4 :                 } else if (left_level &lt; right_level) {</span>
<span class="lineNum">    5573 </span>            :                         advance_right = ADVANCE;
<span class="lineNum">    5574 </span>            :                 } else {
<span class="lineNum">    5575 </span>            :                         advance_left = ADVANCE;
<span class="lineNum">    5576 </span>            :                 }
<span class="lineNum">    5577 </span>            :         }
<span class="lineNum">    5578 </span>            : 
<span class="lineNum">    5579 </span>            : out:
<span class="lineNum">    5580 </span><span class="lineCov">         16 :         btrfs_free_path(left_path);</span>
<span class="lineNum">    5581 </span><span class="lineCov">         16 :         btrfs_free_path(right_path);</span>
<span class="lineNum">    5582 </span><span class="lineCov">         16 :         kfree(tmp_buf);</span>
<span class="lineNum">    5583 </span><span class="lineCov">         16 :         return ret;</span>
<span class="lineNum">    5584 </span>            : }
<span class="lineNum">    5585 </span>            : 
<span class="lineNum">    5586 </span>            : /*
<span class="lineNum">    5587 </span>            :  * this is similar to btrfs_next_leaf, but does not try to preserve
<span class="lineNum">    5588 </span>            :  * and fixup the path.  It looks for and returns the next key in the
<span class="lineNum">    5589 </span>            :  * tree based on the current path and the min_trans parameters.
<span class="lineNum">    5590 </span>            :  *
<span class="lineNum">    5591 </span>            :  * 0 is returned if another key is found, &lt; 0 if there are any errors
<span class="lineNum">    5592 </span>            :  * and 1 is returned if there are no higher keys in the tree
<span class="lineNum">    5593 </span>            :  *
<span class="lineNum">    5594 </span>            :  * path-&gt;keep_locks should be set to 1 on the search made before
<a name="5595"><span class="lineNum">    5595 </span>            :  * calling this function.</a>
<span class="lineNum">    5596 </span>            :  */
<span class="lineNum">    5597 </span><span class="lineCov">        346 : int btrfs_find_next_key(struct btrfs_root *root, struct btrfs_path *path,</span>
<span class="lineNum">    5598 </span>            :                         struct btrfs_key *key, int level, u64 min_trans)
<span class="lineNum">    5599 </span>            : {
<span class="lineNum">    5600 </span>            :         int slot;
<span class="lineNum">    5601 </span><span class="lineCov">        585 :         struct extent_buffer *c;</span>
<span class="lineNum">    5602 </span>            : 
<span class="lineNum">    5603 </span><span class="lineCov">        346 :         WARN_ON(!path-&gt;keep_locks);</span>
<span class="lineNum">    5604 </span><span class="lineCov">        465 :         while (level &lt; BTRFS_MAX_LEVEL) {</span>
<span class="lineNum">    5605 </span><span class="lineCov">        465 :                 if (!path-&gt;nodes[level])</span>
<span class="lineNum">    5606 </span>            :                         return 1;
<span class="lineNum">    5607 </span>            : 
<span class="lineNum">    5608 </span><span class="lineCov">        465 :                 slot = path-&gt;slots[level] + 1;</span>
<span class="lineNum">    5609 </span>            :                 c = path-&gt;nodes[level];
<span class="lineNum">    5610 </span>            : next:
<span class="lineNum">    5611 </span><span class="lineCov">       1170 :                 if (slot &gt;= btrfs_header_nritems(c)) {</span>
<span class="lineNum">    5612 </span>            :                         int ret;
<span class="lineNum">    5613 </span>            :                         int orig_lowest;
<span class="lineNum">    5614 </span>            :                         struct btrfs_key cur_key;
<span class="lineNum">    5615 </span><span class="lineCov">        748 :                         if (level + 1 &gt;= BTRFS_MAX_LEVEL ||</span>
<span class="lineNum">    5616 </span><span class="lineCov">        374 :                             !path-&gt;nodes[level + 1])</span>
<span class="lineNum">    5617 </span><span class="lineCov">        255 :                                 return 1;</span>
<span class="lineNum">    5618 </span>            : 
<span class="lineNum">    5619 </span><span class="lineCov">        119 :                         if (path-&gt;locks[level + 1]) {</span>
<span class="lineNum">    5620 </span>            :                                 level++;
<span class="lineNum">    5621 </span><span class="lineCov">        119 :                                 continue;</span>
<span class="lineNum">    5622 </span>            :                         }
<span class="lineNum">    5623 </span>            : 
<span class="lineNum">    5624 </span><span class="lineNoCov">          0 :                         slot = btrfs_header_nritems(c) - 1;</span>
<span class="lineNum">    5625 </span><span class="lineNoCov">          0 :                         if (level == 0)</span>
<span class="lineNum">    5626 </span><span class="lineNoCov">          0 :                                 btrfs_item_key_to_cpu(c, &amp;cur_key, slot);</span>
<span class="lineNum">    5627 </span>            :                         else
<span class="lineNum">    5628 </span>            :                                 btrfs_node_key_to_cpu(c, &amp;cur_key, slot);
<span class="lineNum">    5629 </span>            : 
<span class="lineNum">    5630 </span><span class="lineNoCov">          0 :                         orig_lowest = path-&gt;lowest_level;</span>
<span class="lineNum">    5631 </span><span class="lineNoCov">          0 :                         btrfs_release_path(path);</span>
<span class="lineNum">    5632 </span><span class="lineNoCov">          0 :                         path-&gt;lowest_level = level;</span>
<span class="lineNum">    5633 </span><span class="lineNoCov">          0 :                         ret = btrfs_search_slot(NULL, root, &amp;cur_key, path,</span>
<span class="lineNum">    5634 </span>            :                                                 0, 0);
<span class="lineNum">    5635 </span><span class="lineNoCov">          0 :                         path-&gt;lowest_level = orig_lowest;</span>
<span class="lineNum">    5636 </span><span class="lineNoCov">          0 :                         if (ret &lt; 0)</span>
<span class="lineNum">    5637 </span>            :                                 return ret;
<span class="lineNum">    5638 </span>            : 
<span class="lineNum">    5639 </span><span class="lineNoCov">          0 :                         c = path-&gt;nodes[level];</span>
<span class="lineNum">    5640 </span><span class="lineNoCov">          0 :                         slot = path-&gt;slots[level];</span>
<span class="lineNum">    5641 </span><span class="lineNoCov">          0 :                         if (ret == 0)</span>
<span class="lineNum">    5642 </span><span class="lineNoCov">          0 :                                 slot++;</span>
<span class="lineNum">    5643 </span><span class="lineNoCov">          0 :                         goto next;</span>
<span class="lineNum">    5644 </span>            :                 }
<span class="lineNum">    5645 </span>            : 
<span class="lineNum">    5646 </span><span class="lineCov">        211 :                 if (level == 0)</span>
<span class="lineNum">    5647 </span><span class="lineNoCov">          0 :                         btrfs_item_key_to_cpu(c, key, slot);</span>
<span class="lineNum">    5648 </span>            :                 else {
<span class="lineNum">    5649 </span>            :                         u64 gen = btrfs_node_ptr_generation(c, slot);
<span class="lineNum">    5650 </span>            : 
<span class="lineNum">    5651 </span><span class="lineCov">        211 :                         if (gen &lt; min_trans) {</span>
<span class="lineNum">    5652 </span><span class="lineCov">        120 :                                 slot++;</span>
<span class="lineNum">    5653 </span><span class="lineCov">        120 :                                 goto next;</span>
<span class="lineNum">    5654 </span>            :                         }
<span class="lineNum">    5655 </span>            :                         btrfs_node_key_to_cpu(c, key, slot);
<span class="lineNum">    5656 </span>            :                 }
<span class="lineNum">    5657 </span>            :                 return 0;
<span class="lineNum">    5658 </span>            :         }
<span class="lineNum">    5659 </span>            :         return 1;
<span class="lineNum">    5660 </span>            : }
<span class="lineNum">    5661 </span>            : 
<span class="lineNum">    5662 </span>            : /*
<span class="lineNum">    5663 </span>            :  * search the tree again to find a leaf with greater keys
<span class="lineNum">    5664 </span>            :  * returns 0 if it found something or 1 if there are no greater leaves.
<a name="5665"><span class="lineNum">    5665 </span>            :  * returns &lt; 0 on io errors.</a>
<span class="lineNum">    5666 </span>            :  */
<span class="lineNum">    5667 </span><span class="lineCov">      25598 : int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)</span>
<span class="lineNum">    5668 </span>            : {
<span class="lineNum">    5669 </span><span class="lineCov">      25697 :         return btrfs_next_old_leaf(root, path, 0);</span>
<a name="5670"><span class="lineNum">    5670 </span>            : }</a>
<span class="lineNum">    5671 </span>            : 
<span class="lineNum">    5672 </span><span class="lineCov">      49082 : int btrfs_next_old_leaf(struct btrfs_root *root, struct btrfs_path *path,</span>
<span class="lineNum">    5673 </span>            :                         u64 time_seq)
<span class="lineNum">    5674 </span>            : {
<span class="lineNum">    5675 </span>            :         int slot;
<span class="lineNum">    5676 </span>            :         int level;
<span class="lineNum">    5677 </span><span class="lineCov">      38739 :         struct extent_buffer *c;</span>
<span class="lineNum">    5678 </span>            :         struct extent_buffer *next;
<span class="lineNum">    5679 </span>            :         struct btrfs_key key;
<span class="lineNum">    5680 </span>            :         u32 nritems;
<span class="lineNum">    5681 </span>            :         int ret;
<span class="lineNum">    5682 </span><span class="lineCov">      49082 :         int old_spinning = path-&gt;leave_spinning;</span>
<span class="lineNum">    5683 </span>            :         int next_rw_lock = 0;
<span class="lineNum">    5684 </span>            : 
<span class="lineNum">    5685 </span><span class="lineCov">      97032 :         nritems = btrfs_header_nritems(path-&gt;nodes[0]);</span>
<span class="lineNum">    5686 </span><span class="lineCov">      49082 :         if (nritems == 0)</span>
<span class="lineNum">    5687 </span>            :                 return 1;
<span class="lineNum">    5688 </span>            : 
<span class="lineNum">    5689 </span><span class="lineCov">      47896 :         btrfs_item_key_to_cpu(path-&gt;nodes[0], &amp;key, nritems - 1);</span>
<span class="lineNum">    5690 </span>            : again:
<span class="lineNum">    5691 </span>            :         level = 1;
<span class="lineNum">    5692 </span><span class="lineCov">      47944 :         next = NULL;</span>
<span class="lineNum">    5693 </span>            :         next_rw_lock = 0;
<span class="lineNum">    5694 </span><span class="lineCov">      47944 :         btrfs_release_path(path);</span>
<span class="lineNum">    5695 </span>            : 
<span class="lineNum">    5696 </span><span class="lineCov">      47953 :         path-&gt;keep_locks = 1;</span>
<span class="lineNum">    5697 </span><span class="lineCov">      47953 :         path-&gt;leave_spinning = 1;</span>
<span class="lineNum">    5698 </span>            : 
<span class="lineNum">    5699 </span><span class="lineCov">      47953 :         if (time_seq)</span>
<span class="lineNum">    5700 </span><span class="lineCov">         71 :                 ret = btrfs_search_old_slot(root, &amp;key, path, time_seq);</span>
<span class="lineNum">    5701 </span>            :         else
<span class="lineNum">    5702 </span><span class="lineCov">      47882 :                 ret = btrfs_search_slot(NULL, root, &amp;key, path, 0, 0);</span>
<span class="lineNum">    5703 </span><span class="lineCov">      47950 :         path-&gt;keep_locks = 0;</span>
<span class="lineNum">    5704 </span>            : 
<span class="lineNum">    5705 </span><span class="lineCov">      47950 :         if (ret &lt; 0)</span>
<span class="lineNum">    5706 </span>            :                 return ret;
<span class="lineNum">    5707 </span>            : 
<span class="lineNum">    5708 </span><span class="lineCov">      47950 :         nritems = btrfs_header_nritems(path-&gt;nodes[0]);</span>
<span class="lineNum">    5709 </span>            :         /*
<span class="lineNum">    5710 </span>            :          * by releasing the path above we dropped all our locks.  A balance
<span class="lineNum">    5711 </span>            :          * could have added more items next to the key that used to be
<span class="lineNum">    5712 </span>            :          * at the very end of the block.  So, check again here and
<span class="lineNum">    5713 </span>            :          * advance the path if there are now more items available.
<span class="lineNum">    5714 </span>            :          */
<span class="lineNum">    5715 </span><span class="lineCov">      47950 :         if (nritems &gt; 0 &amp;&amp; path-&gt;slots[0] &lt; nritems - 1) {</span>
<span class="lineNum">    5716 </span><span class="lineCov">        207 :                 if (ret == 0)</span>
<span class="lineNum">    5717 </span><span class="lineCov">        207 :                         path-&gt;slots[0]++;</span>
<span class="lineNum">    5718 </span>            :                 ret = 0;
<span class="lineNum">    5719 </span>            :                 goto done;
<span class="lineNum">    5720 </span>            :         }
<span class="lineNum">    5721 </span>            :         /*
<span class="lineNum">    5722 </span>            :          * So the above check misses one case:
<span class="lineNum">    5723 </span>            :          * - after releasing the path above, someone has removed the item that
<span class="lineNum">    5724 </span>            :          *   used to be at the very end of the block, and balance between leafs
<span class="lineNum">    5725 </span>            :          *   gets another one with bigger key.offset to replace it.
<span class="lineNum">    5726 </span>            :          *
<span class="lineNum">    5727 </span>            :          * This one should be returned as well, or we can get leaf corruption
<span class="lineNum">    5728 </span>            :          * later(esp. in __btrfs_drop_extents()).
<span class="lineNum">    5729 </span>            :          *
<span class="lineNum">    5730 </span>            :          * And a bit more explanation about this check,
<span class="lineNum">    5731 </span>            :          * with ret &gt; 0, the key isn't found, the path points to the slot
<span class="lineNum">    5732 </span>            :          * where it should be inserted, so the path-&gt;slots[0] item must be the
<span class="lineNum">    5733 </span>            :          * bigger one.
<span class="lineNum">    5734 </span>            :          */
<span class="lineNum">    5735 </span><span class="lineCov">      47743 :         if (nritems &gt; 0 &amp;&amp; ret &gt; 0 &amp;&amp; path-&gt;slots[0] == nritems - 1) {</span>
<span class="lineNum">    5736 </span>            :                 ret = 0;
<span class="lineNum">    5737 </span>            :                 goto done;
<span class="lineNum">    5738 </span>            :         }
<span class="lineNum">    5739 </span>            : 
<span class="lineNum">    5740 </span><span class="lineCov">      60633 :         while (level &lt; BTRFS_MAX_LEVEL) {</span>
<span class="lineNum">    5741 </span><span class="lineCov">      60629 :                 if (!path-&gt;nodes[level]) {</span>
<span class="lineNum">    5742 </span>            :                         ret = 1;
<span class="lineNum">    5743 </span>            :                         goto done;
<span class="lineNum">    5744 </span>            :                 }
<span class="lineNum">    5745 </span>            : 
<span class="lineNum">    5746 </span><span class="lineCov">      38739 :                 slot = path-&gt;slots[level] + 1;</span>
<span class="lineNum">    5747 </span>            :                 c = path-&gt;nodes[level];
<span class="lineNum">    5748 </span><span class="lineCov">      77478 :                 if (slot &gt;= btrfs_header_nritems(c)) {</span>
<span class="lineNum">    5749 </span><span class="lineCov">      12891 :                         level++;</span>
<span class="lineNum">    5750 </span><span class="lineCov">      12891 :                         if (level == BTRFS_MAX_LEVEL) {</span>
<span class="lineNum">    5751 </span>            :                                 ret = 1;
<span class="lineNum">    5752 </span>            :                                 goto done;
<span class="lineNum">    5753 </span>            :                         }
<span class="lineNum">    5754 </span><span class="lineCov">      12889 :                         continue;</span>
<span class="lineNum">    5755 </span>            :                 }
<span class="lineNum">    5756 </span>            : 
<span class="lineNum">    5757 </span><span class="lineCov">      25848 :                 if (next) {</span>
<span class="lineNum">    5758 </span><span class="lineNoCov">          0 :                         btrfs_tree_unlock_rw(next, next_rw_lock);</span>
<span class="lineNum">    5759 </span><span class="lineNoCov">          0 :                         free_extent_buffer(next);</span>
<span class="lineNum">    5760 </span>            :                 }
<span class="lineNum">    5761 </span>            : 
<span class="lineNum">    5762 </span><span class="lineCov">      25848 :                 next = c;</span>
<span class="lineNum">    5763 </span><span class="lineCov">      25848 :                 next_rw_lock = path-&gt;locks[level];</span>
<span class="lineNum">    5764 </span><span class="lineCov">      25848 :                 ret = read_block_for_search(NULL, root, path, &amp;next, level,</span>
<span class="lineNum">    5765 </span>            :                                             slot, &amp;key, 0);
<span class="lineNum">    5766 </span><span class="lineCov">      25848 :                 if (ret == -EAGAIN)</span>
<span class="lineNum">    5767 </span>            :                         goto again;
<span class="lineNum">    5768 </span>            : 
<span class="lineNum">    5769 </span><span class="lineCov">      25800 :                 if (ret &lt; 0) {</span>
<span class="lineNum">    5770 </span><span class="lineNoCov">          0 :                         btrfs_release_path(path);</span>
<span class="lineNum">    5771 </span><span class="lineNoCov">          0 :                         goto done;</span>
<span class="lineNum">    5772 </span>            :                 }
<span class="lineNum">    5773 </span>            : 
<span class="lineNum">    5774 </span><span class="lineCov">      25800 :                 if (!path-&gt;skip_locking) {</span>
<span class="lineNum">    5775 </span><span class="lineCov">       2814 :                         ret = btrfs_try_tree_read_lock(next);</span>
<span class="lineNum">    5776 </span><span class="lineCov">       2814 :                         if (!ret &amp;&amp; time_seq) {</span>
<span class="lineNum">    5777 </span>            :                                 /*
<span class="lineNum">    5778 </span>            :                                  * If we don't get the lock, we may be racing
<span class="lineNum">    5779 </span>            :                                  * with push_leaf_left, holding that lock while
<span class="lineNum">    5780 </span>            :                                  * itself waiting for the leaf we've currently
<span class="lineNum">    5781 </span>            :                                  * locked. To solve this situation, we give up
<span class="lineNum">    5782 </span>            :                                  * on our lock and cycle.
<span class="lineNum">    5783 </span>            :                                  */
<span class="lineNum">    5784 </span><span class="lineNoCov">          0 :                                 free_extent_buffer(next);</span>
<span class="lineNum">    5785 </span><span class="lineNoCov">          0 :                                 btrfs_release_path(path);</span>
<span class="lineNum">    5786 </span><span class="lineNoCov">          0 :                                 cond_resched();</span>
<span class="lineNum">    5787 </span><span class="lineNoCov">          0 :                                 goto again;</span>
<span class="lineNum">    5788 </span>            :                         }
<span class="lineNum">    5789 </span><span class="lineCov">       2814 :                         if (!ret) {</span>
<span class="lineNum">    5790 </span><span class="lineNoCov">          0 :                                 btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5791 </span><span class="lineNoCov">          0 :                                 btrfs_tree_read_lock(next);</span>
<span class="lineNum">    5792 </span><span class="lineNoCov">          0 :                                 btrfs_clear_path_blocking(path, next,</span>
<span class="lineNum">    5793 </span>            :                                                           BTRFS_READ_LOCK);
<span class="lineNum">    5794 </span>            :                         }
<span class="lineNum">    5795 </span>            :                         next_rw_lock = BTRFS_READ_LOCK;
<span class="lineNum">    5796 </span>            :                 }
<span class="lineNum">    5797 </span>            :                 break;
<span class="lineNum">    5798 </span>            :         }
<span class="lineNum">    5799 </span><span class="lineCov">      25800 :         path-&gt;slots[level] = slot;</span>
<span class="lineNum">    5800 </span>            :         while (1) {
<span class="lineNum">    5801 </span><span class="lineCov">      25824 :                 level--;</span>
<span class="lineNum">    5802 </span><span class="lineCov">      25824 :                 c = path-&gt;nodes[level];</span>
<span class="lineNum">    5803 </span><span class="lineCov">      25824 :                 if (path-&gt;locks[level])</span>
<span class="lineNum">    5804 </span><span class="lineCov">       2836 :                         btrfs_tree_unlock_rw(c, path-&gt;locks[level]);</span>
<span class="lineNum">    5805 </span>            : 
<span class="lineNum">    5806 </span><span class="lineCov">      25824 :                 free_extent_buffer(c);</span>
<span class="lineNum">    5807 </span><span class="lineCov">      25824 :                 path-&gt;nodes[level] = next;</span>
<span class="lineNum">    5808 </span><span class="lineCov">      25824 :                 path-&gt;slots[level] = 0;</span>
<span class="lineNum">    5809 </span><span class="lineCov">      25824 :                 if (!path-&gt;skip_locking)</span>
<span class="lineNum">    5810 </span><span class="lineCov">       2836 :                         path-&gt;locks[level] = next_rw_lock;</span>
<span class="lineNum">    5811 </span><span class="lineCov">      25824 :                 if (!level)</span>
<span class="lineNum">    5812 </span>            :                         break;
<span class="lineNum">    5813 </span>            : 
<span class="lineNum">    5814 </span><span class="lineCov">         24 :                 ret = read_block_for_search(NULL, root, path, &amp;next, level,</span>
<span class="lineNum">    5815 </span>            :                                             0, &amp;key, 0);
<span class="lineNum">    5816 </span><span class="lineCov">         24 :                 if (ret == -EAGAIN)</span>
<span class="lineNum">    5817 </span>            :                         goto again;
<span class="lineNum">    5818 </span>            : 
<span class="lineNum">    5819 </span><span class="lineCov">         24 :                 if (ret &lt; 0) {</span>
<span class="lineNum">    5820 </span><span class="lineNoCov">          0 :                         btrfs_release_path(path);</span>
<span class="lineNum">    5821 </span><span class="lineNoCov">          0 :                         goto done;</span>
<span class="lineNum">    5822 </span>            :                 }
<span class="lineNum">    5823 </span>            : 
<span class="lineNum">    5824 </span><span class="lineCov">         24 :                 if (!path-&gt;skip_locking) {</span>
<span class="lineNum">    5825 </span><span class="lineCov">         22 :                         ret = btrfs_try_tree_read_lock(next);</span>
<span class="lineNum">    5826 </span><span class="lineCov">         22 :                         if (!ret) {</span>
<span class="lineNum">    5827 </span><span class="lineNoCov">          0 :                                 btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5828 </span><span class="lineNoCov">          0 :                                 btrfs_tree_read_lock(next);</span>
<span class="lineNum">    5829 </span><span class="lineNoCov">          0 :                                 btrfs_clear_path_blocking(path, next,</span>
<span class="lineNum">    5830 </span>            :                                                           BTRFS_READ_LOCK);
<span class="lineNum">    5831 </span>            :                         }
<span class="lineNum">    5832 </span>            :                         next_rw_lock = BTRFS_READ_LOCK;
<span class="lineNum">    5833 </span>            :                 }
<span class="lineNum">    5834 </span>            :         }
<span class="lineNum">    5835 </span>            :         ret = 0;
<span class="lineNum">    5836 </span>            : done:
<span class="lineNum">    5837 </span><span class="lineCov">      47898 :         unlock_up(path, 0, 1, 0, NULL);</span>
<span class="lineNum">    5838 </span><span class="lineCov">      47901 :         path-&gt;leave_spinning = old_spinning;</span>
<span class="lineNum">    5839 </span><span class="lineCov">      47901 :         if (!old_spinning)</span>
<span class="lineNum">    5840 </span><span class="lineCov">      47832 :                 btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5841 </span>            : 
<span class="lineNum">    5842 </span><span class="lineCov">      47920 :         return ret;</span>
<span class="lineNum">    5843 </span>            : }
<span class="lineNum">    5844 </span>            : 
<span class="lineNum">    5845 </span>            : /*
<span class="lineNum">    5846 </span>            :  * this uses btrfs_prev_leaf to walk backwards in the tree, and keeps
<span class="lineNum">    5847 </span>            :  * searching until it gets past min_objectid or finds an item of 'type'
<span class="lineNum">    5848 </span>            :  *
<a name="5849"><span class="lineNum">    5849 </span>            :  * returns 0 if something is found, 1 if nothing was found and &lt; 0 on error</a>
<span class="lineNum">    5850 </span>            :  */
<span class="lineNum">    5851 </span><span class="lineCov">        282 : int btrfs_previous_item(struct btrfs_root *root,</span>
<span class="lineNum">    5852 </span>            :                         struct btrfs_path *path, u64 min_objectid,
<span class="lineNum">    5853 </span>            :                         int type)
<span class="lineNum">    5854 </span>            : {
<span class="lineNum">    5855 </span>            :         struct btrfs_key found_key;
<span class="lineNum">    5856 </span><span class="lineCov">        282 :         struct extent_buffer *leaf;</span>
<span class="lineNum">    5857 </span>            :         u32 nritems;
<span class="lineNum">    5858 </span>            :         int ret;
<span class="lineNum">    5859 </span>            : 
<span class="lineNum">    5860 </span>            :         while (1) {
<span class="lineNum">    5861 </span><span class="lineCov">        320 :                 if (path-&gt;slots[0] == 0) {</span>
<span class="lineNum">    5862 </span><span class="lineCov">         38 :                         btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5863 </span><span class="lineCov">         38 :                         ret = btrfs_prev_leaf(root, path);</span>
<span class="lineNum">    5864 </span><span class="lineCov">         38 :                         if (ret != 0)</span>
<span class="lineNum">    5865 </span>            :                                 return ret;
<span class="lineNum">    5866 </span>            :                 } else {
<span class="lineNum">    5867 </span><span class="lineCov">        282 :                         path-&gt;slots[0]--;</span>
<span class="lineNum">    5868 </span>            :                 }
<span class="lineNum">    5869 </span><span class="lineCov">        282 :                 leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    5870 </span>            :                 nritems = btrfs_header_nritems(leaf);
<span class="lineNum">    5871 </span><span class="lineCov">        282 :                 if (nritems == 0)</span>
<span class="lineNum">    5872 </span>            :                         return 1;
<span class="lineNum">    5873 </span><span class="lineCov">        282 :                 if (path-&gt;slots[0] == nritems)</span>
<span class="lineNum">    5874 </span><span class="lineNoCov">          0 :                         path-&gt;slots[0]--;</span>
<span class="lineNum">    5875 </span>            : 
<span class="lineNum">    5876 </span><span class="lineCov">        282 :                 btrfs_item_key_to_cpu(leaf, &amp;found_key, path-&gt;slots[0]);</span>
<span class="lineNum">    5877 </span><span class="lineCov">        282 :                 if (found_key.objectid &lt; min_objectid)</span>
<span class="lineNum">    5878 </span>            :                         break;
<span class="lineNum">    5879 </span><span class="lineCov">        218 :                 if (found_key.type == type)</span>
<span class="lineNum">    5880 </span>            :                         return 0;
<span class="lineNum">    5881 </span><span class="lineCov">         38 :                 if (found_key.objectid == min_objectid &amp;&amp;</span>
<span class="lineNum">    5882 </span>            :                     found_key.type &lt; type)
<span class="lineNum">    5883 </span>            :                         break;
<span class="lineNum">    5884 </span>            :         }
<span class="lineNum">    5885 </span>            :         return 1;
<span class="lineNum">    5886 </span>            : }
<span class="lineNum">    5887 </span>            : 
<span class="lineNum">    5888 </span>            : /*
<span class="lineNum">    5889 </span>            :  * search in extent tree to find a previous Metadata/Data extent item with
<span class="lineNum">    5890 </span>            :  * min objecitd.
<span class="lineNum">    5891 </span>            :  *
<a name="5892"><span class="lineNum">    5892 </span>            :  * returns 0 if something is found, 1 if nothing was found and &lt; 0 on error</a>
<span class="lineNum">    5893 </span>            :  */
<span class="lineNum">    5894 </span><span class="lineCov">      33368 : int btrfs_previous_extent_item(struct btrfs_root *root,</span>
<span class="lineNum">    5895 </span>            :                         struct btrfs_path *path, u64 min_objectid)
<span class="lineNum">    5896 </span>            : {
<span class="lineNum">    5897 </span>            :         struct btrfs_key found_key;
<span class="lineNum">    5898 </span><span class="lineCov">      33697 :         struct extent_buffer *leaf;</span>
<span class="lineNum">    5899 </span>            :         u32 nritems;
<span class="lineNum">    5900 </span>            :         int ret;
<span class="lineNum">    5901 </span>            : 
<span class="lineNum">    5902 </span>            :         while (1) {
<span class="lineNum">    5903 </span><span class="lineCov">      33738 :                 if (path-&gt;slots[0] == 0) {</span>
<span class="lineNum">    5904 </span><span class="lineCov">        105 :                         btrfs_set_path_blocking(path);</span>
<span class="lineNum">    5905 </span><span class="lineCov">        105 :                         ret = btrfs_prev_leaf(root, path);</span>
<span class="lineNum">    5906 </span><span class="lineCov">        105 :                         if (ret != 0)</span>
<span class="lineNum">    5907 </span>            :                                 return ret;
<span class="lineNum">    5908 </span>            :                 } else {
<span class="lineNum">    5909 </span><span class="lineCov">      33633 :                         path-&gt;slots[0]--;</span>
<span class="lineNum">    5910 </span>            :                 }
<span class="lineNum">    5911 </span><span class="lineCov">      33697 :                 leaf = path-&gt;nodes[0];</span>
<span class="lineNum">    5912 </span>            :                 nritems = btrfs_header_nritems(leaf);
<span class="lineNum">    5913 </span><span class="lineCov">      33697 :                 if (nritems == 0)</span>
<span class="lineNum">    5914 </span>            :                         return 1;
<span class="lineNum">    5915 </span><span class="lineCov">      33697 :                 if (path-&gt;slots[0] == nritems)</span>
<span class="lineNum">    5916 </span><span class="lineCov">         63 :                         path-&gt;slots[0]--;</span>
<span class="lineNum">    5917 </span>            : 
<span class="lineNum">    5918 </span><span class="lineCov">      33697 :                 btrfs_item_key_to_cpu(leaf, &amp;found_key, path-&gt;slots[0]);</span>
<span class="lineNum">    5919 </span><span class="lineCov">      33697 :                 if (found_key.objectid &lt; min_objectid)</span>
<span class="lineNum">    5920 </span>            :                         break;
<span class="lineNum">    5921 </span><span class="lineCov">      33697 :                 if (found_key.type == BTRFS_EXTENT_ITEM_KEY ||</span>
<span class="lineNum">    5922 </span>            :                     found_key.type == BTRFS_METADATA_ITEM_KEY)
<span class="lineNum">    5923 </span>            :                         return 0;
<span class="lineNum">    5924 </span><span class="lineCov">        370 :                 if (found_key.objectid == min_objectid &amp;&amp;</span>
<span class="lineNum">    5925 </span>            :                     found_key.type &lt; BTRFS_EXTENT_ITEM_KEY)
<span class="lineNum">    5926 </span>            :                         break;
<span class="lineNum">    5927 </span>            :         }
<span class="lineNum">    5928 </span>            :         return 1;
<span class="lineNum">    5929 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
