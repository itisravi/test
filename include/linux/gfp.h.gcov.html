<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - btrfstest.info - include/linux/gfp.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">include/linux</a> - gfp.h<span style="font-size: 80%;"> (source / <a href="gfp.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">btrfstest.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2014-11-28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef __LINUX_GFP_H</a>
<span class="lineNum">       2 </span>            : #define __LINUX_GFP_H
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : #include &lt;linux/mmdebug.h&gt;
<span class="lineNum">       5 </span>            : #include &lt;linux/mmzone.h&gt;
<span class="lineNum">       6 </span>            : #include &lt;linux/stddef.h&gt;
<span class="lineNum">       7 </span>            : #include &lt;linux/linkage.h&gt;
<span class="lineNum">       8 </span>            : #include &lt;linux/topology.h&gt;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : struct vm_area_struct;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : /* Plain integer GFP bitmasks. Do not use this directly. */
<span class="lineNum">      13 </span>            : #define ___GFP_DMA              0x01u
<span class="lineNum">      14 </span>            : #define ___GFP_HIGHMEM          0x02u
<span class="lineNum">      15 </span>            : #define ___GFP_DMA32            0x04u
<span class="lineNum">      16 </span>            : #define ___GFP_MOVABLE          0x08u
<span class="lineNum">      17 </span>            : #define ___GFP_WAIT             0x10u
<span class="lineNum">      18 </span>            : #define ___GFP_HIGH             0x20u
<span class="lineNum">      19 </span>            : #define ___GFP_IO               0x40u
<span class="lineNum">      20 </span>            : #define ___GFP_FS               0x80u
<span class="lineNum">      21 </span>            : #define ___GFP_COLD             0x100u
<span class="lineNum">      22 </span>            : #define ___GFP_NOWARN           0x200u
<span class="lineNum">      23 </span>            : #define ___GFP_REPEAT           0x400u
<span class="lineNum">      24 </span>            : #define ___GFP_NOFAIL           0x800u
<span class="lineNum">      25 </span>            : #define ___GFP_NORETRY          0x1000u
<span class="lineNum">      26 </span>            : #define ___GFP_MEMALLOC         0x2000u
<span class="lineNum">      27 </span>            : #define ___GFP_COMP             0x4000u
<span class="lineNum">      28 </span>            : #define ___GFP_ZERO             0x8000u
<span class="lineNum">      29 </span>            : #define ___GFP_NOMEMALLOC       0x10000u
<span class="lineNum">      30 </span>            : #define ___GFP_HARDWALL         0x20000u
<span class="lineNum">      31 </span>            : #define ___GFP_THISNODE         0x40000u
<span class="lineNum">      32 </span>            : #define ___GFP_RECLAIMABLE      0x80000u
<span class="lineNum">      33 </span>            : #define ___GFP_NOTRACK          0x200000u
<span class="lineNum">      34 </span>            : #define ___GFP_NO_KSWAPD        0x400000u
<span class="lineNum">      35 </span>            : #define ___GFP_OTHER_NODE       0x800000u
<span class="lineNum">      36 </span>            : #define ___GFP_WRITE            0x1000000u
<span class="lineNum">      37 </span>            : /* If the above are modified, __GFP_BITS_SHIFT may need updating */
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /*
<span class="lineNum">      40 </span>            :  * GFP bitmasks..
<span class="lineNum">      41 </span>            :  *
<span class="lineNum">      42 </span>            :  * Zone modifiers (see linux/mmzone.h - low three bits)
<span class="lineNum">      43 </span>            :  *
<span class="lineNum">      44 </span>            :  * Do not put any conditional on these. If necessary modify the definitions
<span class="lineNum">      45 </span>            :  * without the underscores and use them consistently. The definitions here may
<span class="lineNum">      46 </span>            :  * be used in bit comparisons.
<span class="lineNum">      47 </span>            :  */
<span class="lineNum">      48 </span>            : #define __GFP_DMA       ((__force gfp_t)___GFP_DMA)
<span class="lineNum">      49 </span>            : #define __GFP_HIGHMEM   ((__force gfp_t)___GFP_HIGHMEM)
<span class="lineNum">      50 </span>            : #define __GFP_DMA32     ((__force gfp_t)___GFP_DMA32)
<span class="lineNum">      51 </span>            : #define __GFP_MOVABLE   ((__force gfp_t)___GFP_MOVABLE)  /* Page is movable */
<span class="lineNum">      52 </span>            : #define GFP_ZONEMASK    (__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)
<span class="lineNum">      53 </span>            : /*
<span class="lineNum">      54 </span>            :  * Action modifiers - doesn't change the zoning
<span class="lineNum">      55 </span>            :  *
<span class="lineNum">      56 </span>            :  * __GFP_REPEAT: Try hard to allocate the memory, but the allocation attempt
<span class="lineNum">      57 </span>            :  * _might_ fail.  This depends upon the particular VM implementation.
<span class="lineNum">      58 </span>            :  *
<span class="lineNum">      59 </span>            :  * __GFP_NOFAIL: The VM implementation _must_ retry infinitely: the caller
<span class="lineNum">      60 </span>            :  * cannot handle allocation failures.  This modifier is deprecated and no new
<span class="lineNum">      61 </span>            :  * users should be added.
<span class="lineNum">      62 </span>            :  *
<span class="lineNum">      63 </span>            :  * __GFP_NORETRY: The VM implementation must not retry indefinitely.
<span class="lineNum">      64 </span>            :  *
<span class="lineNum">      65 </span>            :  * __GFP_MOVABLE: Flag that this page will be movable by the page migration
<span class="lineNum">      66 </span>            :  * mechanism or reclaimed
<span class="lineNum">      67 </span>            :  */
<span class="lineNum">      68 </span>            : #define __GFP_WAIT      ((__force gfp_t)___GFP_WAIT)    /* Can wait and reschedule? */
<span class="lineNum">      69 </span>            : #define __GFP_HIGH      ((__force gfp_t)___GFP_HIGH)    /* Should access emergency pools? */
<span class="lineNum">      70 </span>            : #define __GFP_IO        ((__force gfp_t)___GFP_IO)      /* Can start physical IO? */
<span class="lineNum">      71 </span>            : #define __GFP_FS        ((__force gfp_t)___GFP_FS)      /* Can call down to low-level FS? */
<span class="lineNum">      72 </span>            : #define __GFP_COLD      ((__force gfp_t)___GFP_COLD)    /* Cache-cold page required */
<span class="lineNum">      73 </span>            : #define __GFP_NOWARN    ((__force gfp_t)___GFP_NOWARN)  /* Suppress page allocation failure warning */
<span class="lineNum">      74 </span>            : #define __GFP_REPEAT    ((__force gfp_t)___GFP_REPEAT)  /* See above */
<span class="lineNum">      75 </span>            : #define __GFP_NOFAIL    ((__force gfp_t)___GFP_NOFAIL)  /* See above */
<span class="lineNum">      76 </span>            : #define __GFP_NORETRY   ((__force gfp_t)___GFP_NORETRY) /* See above */
<span class="lineNum">      77 </span>            : #define __GFP_MEMALLOC  ((__force gfp_t)___GFP_MEMALLOC)/* Allow access to emergency reserves */
<span class="lineNum">      78 </span>            : #define __GFP_COMP      ((__force gfp_t)___GFP_COMP)    /* Add compound page metadata */
<span class="lineNum">      79 </span>            : #define __GFP_ZERO      ((__force gfp_t)___GFP_ZERO)    /* Return zeroed page on success */
<span class="lineNum">      80 </span>            : #define __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC) /* Don't use emergency reserves.
<span class="lineNum">      81 </span>            :                                                          * This takes precedence over the
<span class="lineNum">      82 </span>            :                                                          * __GFP_MEMALLOC flag if both are
<span class="lineNum">      83 </span>            :                                                          * set
<span class="lineNum">      84 </span>            :                                                          */
<span class="lineNum">      85 </span>            : #define __GFP_HARDWALL   ((__force gfp_t)___GFP_HARDWALL) /* Enforce hardwall cpuset memory allocs */
<span class="lineNum">      86 </span>            : #define __GFP_THISNODE  ((__force gfp_t)___GFP_THISNODE)/* No fallback, no policies */
<span class="lineNum">      87 </span>            : #define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE) /* Page is reclaimable */
<span class="lineNum">      88 </span>            : #define __GFP_NOTRACK   ((__force gfp_t)___GFP_NOTRACK)  /* Don't track with kmemcheck */
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : #define __GFP_NO_KSWAPD ((__force gfp_t)___GFP_NO_KSWAPD)
<span class="lineNum">      91 </span>            : #define __GFP_OTHER_NODE ((__force gfp_t)___GFP_OTHER_NODE) /* On behalf of other node */
<span class="lineNum">      92 </span>            : #define __GFP_WRITE     ((__force gfp_t)___GFP_WRITE)   /* Allocator intends to dirty page */
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : /*
<span class="lineNum">      95 </span>            :  * This may seem redundant, but it's a way of annotating false positives vs.
<span class="lineNum">      96 </span>            :  * allocations that simply cannot be supported (e.g. page tables).
<span class="lineNum">      97 </span>            :  */
<span class="lineNum">      98 </span>            : #define __GFP_NOTRACK_FALSE_POSITIVE (__GFP_NOTRACK)
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : #define __GFP_BITS_SHIFT 25     /* Room for N __GFP_FOO bits */
<span class="lineNum">     101 </span>            : #define __GFP_BITS_MASK ((__force gfp_t)((1 &lt;&lt; __GFP_BITS_SHIFT) - 1))
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            : /* This equals 0, but use constants in case they ever change */
<span class="lineNum">     104 </span>            : #define GFP_NOWAIT      (GFP_ATOMIC &amp; ~__GFP_HIGH)
<span class="lineNum">     105 </span>            : /* GFP_ATOMIC means both !wait (__GFP_WAIT not set) and use emergency pool */
<span class="lineNum">     106 </span>            : #define GFP_ATOMIC      (__GFP_HIGH)
<span class="lineNum">     107 </span>            : #define GFP_NOIO        (__GFP_WAIT)
<span class="lineNum">     108 </span>            : #define GFP_NOFS        (__GFP_WAIT | __GFP_IO)
<span class="lineNum">     109 </span>            : #define GFP_KERNEL      (__GFP_WAIT | __GFP_IO | __GFP_FS)
<span class="lineNum">     110 </span>            : #define GFP_TEMPORARY   (__GFP_WAIT | __GFP_IO | __GFP_FS | \
<span class="lineNum">     111 </span>            :                          __GFP_RECLAIMABLE)
<span class="lineNum">     112 </span>            : #define GFP_USER        (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
<span class="lineNum">     113 </span>            : #define GFP_HIGHUSER    (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL | \
<span class="lineNum">     114 </span>            :                          __GFP_HIGHMEM)
<span class="lineNum">     115 </span>            : #define GFP_HIGHUSER_MOVABLE    (__GFP_WAIT | __GFP_IO | __GFP_FS | \
<span class="lineNum">     116 </span>            :                                  __GFP_HARDWALL | __GFP_HIGHMEM | \
<span class="lineNum">     117 </span>            :                                  __GFP_MOVABLE)
<span class="lineNum">     118 </span>            : #define GFP_IOFS        (__GFP_IO | __GFP_FS)
<span class="lineNum">     119 </span>            : #define GFP_TRANSHUGE   (GFP_HIGHUSER_MOVABLE | __GFP_COMP | \
<span class="lineNum">     120 </span>            :                          __GFP_NOMEMALLOC | __GFP_NORETRY | __GFP_NOWARN | \
<span class="lineNum">     121 </span>            :                          __GFP_NO_KSWAPD)
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /*
<span class="lineNum">     124 </span>            :  * GFP_THISNODE does not perform any reclaim, you most likely want to
<span class="lineNum">     125 </span>            :  * use __GFP_THISNODE to allocate from a given node without fallback!
<span class="lineNum">     126 </span>            :  */
<span class="lineNum">     127 </span>            : #ifdef CONFIG_NUMA
<span class="lineNum">     128 </span>            : #define GFP_THISNODE    (__GFP_THISNODE | __GFP_NOWARN | __GFP_NORETRY)
<span class="lineNum">     129 </span>            : #else
<span class="lineNum">     130 </span>            : #define GFP_THISNODE    ((__force gfp_t)0)
<span class="lineNum">     131 </span>            : #endif
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : /* This mask makes up all the page movable related flags */
<span class="lineNum">     134 </span>            : #define GFP_MOVABLE_MASK (__GFP_RECLAIMABLE|__GFP_MOVABLE)
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : /* Control page allocator reclaim behavior */
<span class="lineNum">     137 </span>            : #define GFP_RECLAIM_MASK (__GFP_WAIT|__GFP_HIGH|__GFP_IO|__GFP_FS|\
<span class="lineNum">     138 </span>            :                         __GFP_NOWARN|__GFP_REPEAT|__GFP_NOFAIL|\
<span class="lineNum">     139 </span>            :                         __GFP_NORETRY|__GFP_MEMALLOC|__GFP_NOMEMALLOC)
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : /* Control slab gfp mask during early boot */
<span class="lineNum">     142 </span>            : #define GFP_BOOT_MASK (__GFP_BITS_MASK &amp; ~(__GFP_WAIT|__GFP_IO|__GFP_FS))
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : /* Control allocation constraints */
<span class="lineNum">     145 </span>            : #define GFP_CONSTRAINT_MASK (__GFP_HARDWALL|__GFP_THISNODE)
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : /* Do not use these with a slab allocator */
<span class="lineNum">     148 </span>            : #define GFP_SLAB_BUG_MASK (__GFP_DMA32|__GFP_HIGHMEM|~__GFP_BITS_MASK)
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            : /* Flag - indicates that the buffer will be suitable for DMA.  Ignored on some
<span class="lineNum">     151 </span>            :    platforms, used as appropriate on others */
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : #define GFP_DMA         __GFP_DMA
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : /* 4GB DMA on some platforms */
<span class="lineNum">     156 </span>            : #define GFP_DMA32       __GFP_DMA32
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : /* Convert GFP flags to their corresponding migrate type */
<span class="lineNum">     159 </span>            : static inline int allocflags_to_migratetype(gfp_t gfp_flags)
<span class="lineNum">     160 </span>            : {
<span class="lineNum">     161 </span>            :         WARN_ON((gfp_flags &amp; GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :         if (unlikely(page_group_by_mobility_disabled))
<span class="lineNum">     164 </span>            :                 return MIGRATE_UNMOVABLE;
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :         /* Group based on mobility */
<span class="lineNum">     167 </span>            :         return (((gfp_flags &amp; __GFP_MOVABLE) != 0) &lt;&lt; 1) |
<span class="lineNum">     168 </span>            :                 ((gfp_flags &amp; __GFP_RECLAIMABLE) != 0);
<span class="lineNum">     169 </span>            : }
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : #ifdef CONFIG_HIGHMEM
<span class="lineNum">     172 </span>            : #define OPT_ZONE_HIGHMEM ZONE_HIGHMEM
<span class="lineNum">     173 </span>            : #else
<span class="lineNum">     174 </span>            : #define OPT_ZONE_HIGHMEM ZONE_NORMAL
<span class="lineNum">     175 </span>            : #endif
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : #ifdef CONFIG_ZONE_DMA
<span class="lineNum">     178 </span>            : #define OPT_ZONE_DMA ZONE_DMA
<span class="lineNum">     179 </span>            : #else
<span class="lineNum">     180 </span>            : #define OPT_ZONE_DMA ZONE_NORMAL
<span class="lineNum">     181 </span>            : #endif
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : #ifdef CONFIG_ZONE_DMA32
<span class="lineNum">     184 </span>            : #define OPT_ZONE_DMA32 ZONE_DMA32
<span class="lineNum">     185 </span>            : #else
<span class="lineNum">     186 </span>            : #define OPT_ZONE_DMA32 ZONE_NORMAL
<span class="lineNum">     187 </span>            : #endif
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : /*
<span class="lineNum">     190 </span>            :  * GFP_ZONE_TABLE is a word size bitstring that is used for looking up the
<span class="lineNum">     191 </span>            :  * zone to use given the lowest 4 bits of gfp_t. Entries are ZONE_SHIFT long
<span class="lineNum">     192 </span>            :  * and there are 16 of them to cover all possible combinations of
<span class="lineNum">     193 </span>            :  * __GFP_DMA, __GFP_DMA32, __GFP_MOVABLE and __GFP_HIGHMEM.
<span class="lineNum">     194 </span>            :  *
<span class="lineNum">     195 </span>            :  * The zone fallback order is MOVABLE=&gt;HIGHMEM=&gt;NORMAL=&gt;DMA32=&gt;DMA.
<span class="lineNum">     196 </span>            :  * But GFP_MOVABLE is not only a zone specifier but also an allocation
<span class="lineNum">     197 </span>            :  * policy. Therefore __GFP_MOVABLE plus another zone selector is valid.
<span class="lineNum">     198 </span>            :  * Only 1 bit of the lowest 3 bits (DMA,DMA32,HIGHMEM) can be set to &quot;1&quot;.
<span class="lineNum">     199 </span>            :  *
<span class="lineNum">     200 </span>            :  *       bit       result
<span class="lineNum">     201 </span>            :  *       =================
<span class="lineNum">     202 </span>            :  *       0x0    =&gt; NORMAL
<span class="lineNum">     203 </span>            :  *       0x1    =&gt; DMA or NORMAL
<span class="lineNum">     204 </span>            :  *       0x2    =&gt; HIGHMEM or NORMAL
<span class="lineNum">     205 </span>            :  *       0x3    =&gt; BAD (DMA+HIGHMEM)
<span class="lineNum">     206 </span>            :  *       0x4    =&gt; DMA32 or DMA or NORMAL
<span class="lineNum">     207 </span>            :  *       0x5    =&gt; BAD (DMA+DMA32)
<span class="lineNum">     208 </span>            :  *       0x6    =&gt; BAD (HIGHMEM+DMA32)
<span class="lineNum">     209 </span>            :  *       0x7    =&gt; BAD (HIGHMEM+DMA32+DMA)
<span class="lineNum">     210 </span>            :  *       0x8    =&gt; NORMAL (MOVABLE+0)
<span class="lineNum">     211 </span>            :  *       0x9    =&gt; DMA or NORMAL (MOVABLE+DMA)
<span class="lineNum">     212 </span>            :  *       0xa    =&gt; MOVABLE (Movable is valid only if HIGHMEM is set too)
<span class="lineNum">     213 </span>            :  *       0xb    =&gt; BAD (MOVABLE+HIGHMEM+DMA)
<span class="lineNum">     214 </span>            :  *       0xc    =&gt; DMA32 (MOVABLE+DMA32)
<span class="lineNum">     215 </span>            :  *       0xd    =&gt; BAD (MOVABLE+DMA32+DMA)
<span class="lineNum">     216 </span>            :  *       0xe    =&gt; BAD (MOVABLE+DMA32+HIGHMEM)
<span class="lineNum">     217 </span>            :  *       0xf    =&gt; BAD (MOVABLE+DMA32+HIGHMEM+DMA)
<span class="lineNum">     218 </span>            :  *
<span class="lineNum">     219 </span>            :  * ZONES_SHIFT must be &lt;= 2 on 32 bit platforms.
<span class="lineNum">     220 </span>            :  */
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : #if 16 * ZONES_SHIFT &gt; BITS_PER_LONG
<span class="lineNum">     223 </span>            : #error ZONES_SHIFT too large to create GFP_ZONE_TABLE integer
<span class="lineNum">     224 </span>            : #endif
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : #define GFP_ZONE_TABLE ( \
<span class="lineNum">     227 </span>            :         (ZONE_NORMAL &lt;&lt; 0 * ZONES_SHIFT)                                \
<span class="lineNum">     228 </span>            :         | (OPT_ZONE_DMA &lt;&lt; ___GFP_DMA * ZONES_SHIFT)                            \
<span class="lineNum">     229 </span>            :         | (OPT_ZONE_HIGHMEM &lt;&lt; ___GFP_HIGHMEM * ZONES_SHIFT)                    \
<span class="lineNum">     230 </span>            :         | (OPT_ZONE_DMA32 &lt;&lt; ___GFP_DMA32 * ZONES_SHIFT)                \
<span class="lineNum">     231 </span>            :         | (ZONE_NORMAL &lt;&lt; ___GFP_MOVABLE * ZONES_SHIFT)                         \
<span class="lineNum">     232 </span>            :         | (OPT_ZONE_DMA &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA) * ZONES_SHIFT)         \
<span class="lineNum">     233 </span>            :         | (ZONE_MOVABLE &lt;&lt; (___GFP_MOVABLE | ___GFP_HIGHMEM) * ZONES_SHIFT)   \
<span class="lineNum">     234 </span>            :         | (OPT_ZONE_DMA32 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32) * ZONES_SHIFT)   \
<span class="lineNum">     235 </span>            : )
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : /*
<span class="lineNum">     238 </span>            :  * GFP_ZONE_BAD is a bitmap for all combinations of __GFP_DMA, __GFP_DMA32
<span class="lineNum">     239 </span>            :  * __GFP_HIGHMEM and __GFP_MOVABLE that are not permitted. One flag per
<span class="lineNum">     240 </span>            :  * entry starting with bit 0. Bit is set if the combination is not
<span class="lineNum">     241 </span>            :  * allowed.
<span class="lineNum">     242 </span>            :  */
<span class="lineNum">     243 </span>            : #define GFP_ZONE_BAD ( \
<span class="lineNum">     244 </span>            :         1 &lt;&lt; (___GFP_DMA | ___GFP_HIGHMEM)                                      \
<span class="lineNum">     245 </span>            :         | 1 &lt;&lt; (___GFP_DMA | ___GFP_DMA32)                                      \
<span class="lineNum">     246 </span>            :         | 1 &lt;&lt; (___GFP_DMA32 | ___GFP_HIGHMEM)                                  \
<span class="lineNum">     247 </span>            :         | 1 &lt;&lt; (___GFP_DMA | ___GFP_DMA32 | ___GFP_HIGHMEM)                     \
<span class="lineNum">     248 </span>            :         | 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_HIGHMEM | ___GFP_DMA)                   \
<span class="lineNum">     249 </span>            :         | 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA)                     \
<span class="lineNum">     250 </span>            :         | 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_HIGHMEM)                 \
<span class="lineNum">     251 </span>            :         | 1 &lt;&lt; (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA | ___GFP_HIGHMEM)  \
<span class="lineNum">     252 </span>            : )
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : static inline enum zone_type gfp_zone(gfp_t flags)
<span class="lineNum">     255 </span>            : {
<span class="lineNum">     256 </span>            :         enum zone_type z;
<span class="lineNum">     257 </span>            :         int bit = (__force int) (flags &amp; GFP_ZONEMASK);
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :         z = (GFP_ZONE_TABLE &gt;&gt; (bit * ZONES_SHIFT)) &amp;
<span class="lineNum">     260 </span>            :                                          ((1 &lt;&lt; ZONES_SHIFT) - 1);
<span class="lineNum">     261 </span>            :         VM_BUG_ON((GFP_ZONE_BAD &gt;&gt; bit) &amp; 1);
<span class="lineNum">     262 </span>            :         return z;
<span class="lineNum">     263 </span>            : }
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : /*
<span class="lineNum">     266 </span>            :  * There is only one page-allocator function, and two main namespaces to
<span class="lineNum">     267 </span>            :  * it. The alloc_page*() variants return 'struct page *' and as such
<span class="lineNum">     268 </span>            :  * can allocate highmem pages, the *get*page*() variants return
<span class="lineNum">     269 </span>            :  * virtual kernel addresses to the allocated page(s).
<span class="lineNum">     270 </span>            :  */
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : static inline int gfp_zonelist(gfp_t flags)
<span class="lineNum">     273 </span>            : {
<span class="lineNum">     274 </span>            :         if (IS_ENABLED(CONFIG_NUMA) &amp;&amp; unlikely(flags &amp; __GFP_THISNODE))
<span class="lineNum">     275 </span>            :                 return 1;
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :         return 0;
<span class="lineNum">     278 </span>            : }
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            : /*
<span class="lineNum">     281 </span>            :  * We get the zone list from the current node and the gfp_mask.
<span class="lineNum">     282 </span>            :  * This zone list contains a maximum of MAXNODES*MAX_NR_ZONES zones.
<span class="lineNum">     283 </span>            :  * There are two zonelists per node, one for all zones with memory and
<span class="lineNum">     284 </span>            :  * one containing just zones from the node the zonelist belongs to.
<span class="lineNum">     285 </span>            :  *
<span class="lineNum">     286 </span>            :  * For the normal case of non-DISCONTIGMEM systems the NODE_DATA() gets
<span class="lineNum">     287 </span>            :  * optimized to &amp;contig_page_data at compile-time.
<span class="lineNum">     288 </span>            :  */
<span class="lineNum">     289 </span>            : static inline struct zonelist *node_zonelist(int nid, gfp_t flags)
<span class="lineNum">     290 </span>            : {
<span class="lineNum">     291 </span>            :         return NODE_DATA(nid)-&gt;node_zonelists + gfp_zonelist(flags);
<span class="lineNum">     292 </span>            : }
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : #ifndef HAVE_ARCH_FREE_PAGE
<span class="lineNum">     295 </span>            : static inline void arch_free_page(struct page *page, int order) { }
<span class="lineNum">     296 </span>            : #endif
<span class="lineNum">     297 </span>            : #ifndef HAVE_ARCH_ALLOC_PAGE
<span class="lineNum">     298 </span>            : static inline void arch_alloc_page(struct page *page, int order) { }
<span class="lineNum">     299 </span>            : #endif
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : struct page *
<span class="lineNum">     302 </span>            : __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,
<span class="lineNum">     303 </span>            :                        struct zonelist *zonelist, nodemask_t *nodemask);
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : static inline struct page *
<span class="lineNum">     306 </span>            : __alloc_pages(gfp_t gfp_mask, unsigned int order,
<span class="lineNum">     307 </span>            :                 struct zonelist *zonelist)
<span class="lineNum">     308 </span>            : {
<span class="lineNum">     309 </span>            :         return __alloc_pages_nodemask(gfp_mask, order, zonelist, NULL);
<span class="lineNum">     310 </span>            : }
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,
<span class="lineNum">     313 </span>            :                                                 unsigned int order)
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span>            :         /* Unknown node is current node */
<span class="lineNum">     316 </span>            :         if (nid &lt; 0)
<span class="lineNum">     317 </span>            :                 nid = numa_node_id();
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :         return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));
<span class="lineNum">     320 </span>            : }
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : static inline struct page *alloc_pages_exact_node(int nid, gfp_t gfp_mask,
<span class="lineNum">     323 </span>            :                                                 unsigned int order)
<span class="lineNum">     324 </span>            : {
<span class="lineNum">     325 </span>            :         VM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES || !node_online(nid));
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :         return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));
<span class="lineNum">     328 </span>            : }
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : #ifdef CONFIG_NUMA
<span class="lineNum">     331 </span>            : extern struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : static inline struct page *
<span class="lineNum">     334 </span>            : alloc_pages(gfp_t gfp_mask, unsigned int order)
<span class="lineNum">     335 </span>            : {
<span class="lineNum">     336 </span><span class="lineCov">    4193440 :         return alloc_pages_current(gfp_mask, order);</span>
<span class="lineNum">     337 </span>            : }
<span class="lineNum">     338 </span>            : extern struct page *alloc_pages_vma(gfp_t gfp_mask, int order,
<span class="lineNum">     339 </span>            :                         struct vm_area_struct *vma, unsigned long addr,
<span class="lineNum">     340 </span>            :                         int node);
<span class="lineNum">     341 </span>            : #else
<span class="lineNum">     342 </span>            : #define alloc_pages(gfp_mask, order) \
<span class="lineNum">     343 </span>            :                 alloc_pages_node(numa_node_id(), gfp_mask, order)
<span class="lineNum">     344 </span>            : #define alloc_pages_vma(gfp_mask, order, vma, addr, node)       \
<span class="lineNum">     345 </span>            :         alloc_pages(gfp_mask, order)
<span class="lineNum">     346 </span>            : #endif
<span class="lineNum">     347 </span>            : #define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)
<span class="lineNum">     348 </span>            : #define alloc_page_vma(gfp_mask, vma, addr)                     \
<span class="lineNum">     349 </span>            :         alloc_pages_vma(gfp_mask, 0, vma, addr, numa_node_id())
<span class="lineNum">     350 </span>            : #define alloc_page_vma_node(gfp_mask, vma, addr, node)          \
<span class="lineNum">     351 </span>            :         alloc_pages_vma(gfp_mask, 0, vma, addr, node)
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            : extern struct page *alloc_kmem_pages(gfp_t gfp_mask, unsigned int order);
<span class="lineNum">     354 </span>            : extern struct page *alloc_kmem_pages_node(int nid, gfp_t gfp_mask,
<span class="lineNum">     355 </span>            :                                           unsigned int order);
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : extern unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);
<span class="lineNum">     358 </span>            : extern unsigned long get_zeroed_page(gfp_t gfp_mask);
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            : void *alloc_pages_exact(size_t size, gfp_t gfp_mask);
<span class="lineNum">     361 </span>            : void free_pages_exact(void *virt, size_t size);
<span class="lineNum">     362 </span>            : /* This is different from alloc_pages_exact_node !!! */
<span class="lineNum">     363 </span>            : void * __meminit alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask);
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : #define __get_free_page(gfp_mask) \
<span class="lineNum">     366 </span>            :                 __get_free_pages((gfp_mask), 0)
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            : #define __get_dma_pages(gfp_mask, order) \
<span class="lineNum">     369 </span>            :                 __get_free_pages((gfp_mask) | GFP_DMA, (order))
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : extern void __free_pages(struct page *page, unsigned int order);
<span class="lineNum">     372 </span>            : extern void free_pages(unsigned long addr, unsigned int order);
<span class="lineNum">     373 </span>            : extern void free_hot_cold_page(struct page *page, bool cold);
<span class="lineNum">     374 </span>            : extern void free_hot_cold_page_list(struct list_head *list, bool cold);
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : extern void __free_kmem_pages(struct page *page, unsigned int order);
<span class="lineNum">     377 </span>            : extern void free_kmem_pages(unsigned long addr, unsigned int order);
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            : #define __free_page(page) __free_pages((page), 0)
<span class="lineNum">     380 </span>            : #define free_page(addr) free_pages((addr), 0)
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : void page_alloc_init(void);
<span class="lineNum">     383 </span>            : void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp);
<span class="lineNum">     384 </span>            : void drain_all_pages(void);
<span class="lineNum">     385 </span>            : void drain_local_pages(void *dummy);
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : /*
<span class="lineNum">     388 </span>            :  * gfp_allowed_mask is set to GFP_BOOT_MASK during early boot to restrict what
<span class="lineNum">     389 </span>            :  * GFP flags are used before interrupts are enabled. Once interrupts are
<span class="lineNum">     390 </span>            :  * enabled, it is set to __GFP_BITS_MASK while the system is running. During
<span class="lineNum">     391 </span>            :  * hibernation, it is used by PM to avoid I/O during memory allocation while
<span class="lineNum">     392 </span>            :  * devices are suspended.
<span class="lineNum">     393 </span>            :  */
<span class="lineNum">     394 </span>            : extern gfp_t gfp_allowed_mask;
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : /* Returns true if the gfp_mask allows use of ALLOC_NO_WATERMARK */
<span class="lineNum">     397 </span>            : bool gfp_pfmemalloc_allowed(gfp_t gfp_mask);
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : extern void pm_restrict_gfp_mask(void);
<span class="lineNum">     400 </span>            : extern void pm_restore_gfp_mask(void);
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            : #ifdef CONFIG_PM_SLEEP
<span class="lineNum">     403 </span>            : extern bool pm_suspended_storage(void);
<span class="lineNum">     404 </span>            : #else
<span class="lineNum">     405 </span>            : static inline bool pm_suspended_storage(void)
<span class="lineNum">     406 </span>            : {
<span class="lineNum">     407 </span>            :         return false;
<span class="lineNum">     408 </span>            : }
<span class="lineNum">     409 </span>            : #endif /* CONFIG_PM_SLEEP */
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : #ifdef CONFIG_CMA
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : /* The below functions must be run on a range from a single zone. */
<span class="lineNum">     414 </span>            : extern int alloc_contig_range(unsigned long start, unsigned long end,
<span class="lineNum">     415 </span>            :                               unsigned migratetype);
<span class="lineNum">     416 </span>            : extern void free_contig_range(unsigned long pfn, unsigned nr_pages);
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : /* CMA stuff */
<span class="lineNum">     419 </span>            : extern void init_cma_reserved_pageblock(struct page *page);
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            : #endif
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : #endif /* __LINUX_GFP_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
